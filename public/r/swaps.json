{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swaps",
  "type": "registry:component",
  "title": "Swaps",
  "description": "Swap tokens across chains (Exact In)",
  "dependencies": [
    "@avail-project/nexus-core@1.1.0",
    "lucide-react"
  ],
  "registryDependencies": [
    "https://elements.nexus.availproject.org/r/accordion.json",
    "https://elements.nexus.availproject.org/r/button.json",
    "https://elements.nexus.availproject.org/r/checkbox.json",
    "https://elements.nexus.availproject.org/r/dialog.json",
    "https://elements.nexus.availproject.org/r/label.json",
    "https://elements.nexus.availproject.org/r/nexus-provider.json",
    "https://elements.nexus.availproject.org/r/select.json",
    "https://elements.nexus.availproject.org/r/separator.json",
    "https://elements.nexus.availproject.org/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/nexus-elements/swaps/components/amount-input.tsx",
      "content": "import { type FC, useRef } from \"react\";\n\ninterface AmountInputProps {\n  amount?: string;\n  onChange?: (value: string) => void;\n  onFocus?: () => void;\n  disabled?: boolean;\n}\n\nconst AmountInput: FC<AmountInputProps> = ({\n  amount,\n  onChange,\n  onFocus,\n  disabled,\n}) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n  const mirrorRef = useRef<HTMLDivElement>(null);\n\n  return (\n    <div className=\"relative flex items-start gap-2 text-4xl font-medium transition-all duration-150 ease-out w-full\">\n      <div\n        ref={mirrorRef}\n        className=\"absolute invisible pointer-events-none text-4xl font-medium whitespace-pre\"\n        style={{\n          fontVariantNumeric: \"proportional-nums\",\n        }}\n      >\n        {amount || \"0\"}\n      </div>\n\n      <input\n        ref={inputRef}\n        type=\"text\"\n        inputMode=\"decimal\"\n        placeholder=\"0\"\n        value={amount}\n        onChange={(e) => {\n          onChange?.(e.target.value);\n        }}\n        onFocus={onFocus}\n        maxLength={18}\n        autoFocus\n        className=\"bg-transparent w-full text-foreground text-4xl font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-50\"\n        disabled={disabled}\n      />\n      <div className=\"absolute -inset-1 -z-10 blur-sm pointer-events-none opacity-0\" />\n    </div>\n  );\n};\n\nexport default AmountInput;\n",
      "type": "registry:component",
      "target": "components/swaps/components/amount-input.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/destination-asset-select.tsx",
      "content": "\"use client\";\nimport { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport {\n  type SUPPORTED_CHAINS_IDS,\n  CHAIN_METADATA,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { DESTINATION_SWAP_TOKENS } from \"../config/destination\";\nimport { DialogClose } from \"../../ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n} from \"../../ui/select\";\nimport { Link2, Search, X } from \"lucide-react\";\nimport { SHORT_CHAIN_NAME, usdFormatter } from \"../../common\";\nimport { TokenIcon } from \"./token-icon\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { type DestinationTokenInfo } from \"../hooks/useSwaps\";\n\ninterface DestinationAssetSelectProps {\n  swapBalance: UserAsset[] | null;\n  onSelect: (\n    chainId: SUPPORTED_CHAINS_IDS,\n    token: DestinationTokenInfo\n  ) => void;\n}\n\nconst DestinationAssetSelect: FC<DestinationAssetSelectProps> = ({\n  swapBalance,\n  onSelect,\n}) => {\n  const { nexusSDK } = useNexus();\n  const [tempChain, setTempChain] = useState<number | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n\n  // Get all tokens from all chains with their chain info\n  const allTokens: DestinationTokenInfo[] = useMemo(() => {\n    const tokens: DestinationTokenInfo[] = [];\n    for (const [chainId, chainTokens] of DESTINATION_SWAP_TOKENS.entries()) {\n      for (const token of chainTokens) {\n        tokens.push({\n          ...token,\n          chainId,\n        });\n      }\n    }\n    return tokens.map((token) => {\n      const balance = swapBalance\n        ?.find((t) => t.symbol === token.symbol)\n        ?.breakdown?.find((chain) => chain.chain?.id === token.chainId);\n      return {\n        ...token,\n        balance: nexusSDK?.utils?.formatTokenBalance(balance?.balance ?? \"0\", {\n          symbol: token.symbol,\n          decimals: balance?.decimals ?? 0,\n        }),\n        balanceInFiat: usdFormatter.format(balance?.balanceInFiat ?? 0),\n      };\n    });\n  }, [swapBalance]);\n\n  // Only show chains that have tokens\n  const chainsWithTokens = useMemo(() => {\n    return Array.from(DESTINATION_SWAP_TOKENS.keys());\n  }, []);\n\n  // Filter tokens by selected chain and search query\n  const displayedTokens: DestinationTokenInfo[] = useMemo(() => {\n    let filtered = allTokens;\n\n    // Filter by chain\n    if (tempChain) {\n      filtered = filtered.filter((t) => t.chainId === tempChain);\n    }\n\n    // Filter by search query\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase().trim();\n      filtered = filtered.filter(\n        (t) =>\n          t.symbol.toLowerCase().includes(query) ||\n          t.name.toLowerCase().includes(query) ||\n          t.tokenAddress.toLowerCase().includes(query)\n      );\n    }\n\n    return filtered;\n  }, [tempChain, allTokens, searchQuery]);\n\n  const handlePick = (tok: DestinationTokenInfo) => {\n    const chainId = tempChain ?? tok.chainId;\n    if (!chainId) return;\n    onSelect(chainId as SUPPORTED_CHAINS_IDS, tok);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"w-full flex flex-col gap-y-3\">\n        <Select\n          value={tempChain ? CHAIN_METADATA[tempChain].name : \"\"}\n          onValueChange={(value) => {\n            const matchedChain = chainsWithTokens.find(\n              (chain) => String(chain) === value\n            );\n            if (matchedChain) {\n              setTempChain(matchedChain);\n            }\n          }}\n        >\n          <div className=\"flex bg-input/30 w-full px-2 py-1.5\">\n            <div className=\"flex items-center gap-x-2 w-full justify-between\">\n              <Search className=\"size-5 opacity-65\" />\n              <input\n                placeholder=\"Search tokens...\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                className=\"bg-transparent w-full text-foreground text-base font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-80\"\n              />\n              {searchQuery && (\n                <button\n                  type=\"button\"\n                  onClick={() => setSearchQuery(\"\")}\n                  className=\"p-0.5 hover:bg-muted rounded-full transition-colors\"\n                >\n                  <X className=\"size-4 opacity-65\" />\n                </button>\n              )}\n            </div>\n            <SelectTrigger className=\"rounded-full border-none cursor-pointer bg-transparent!\">\n              {tempChain ? (\n                <img\n                  src={CHAIN_METADATA[tempChain].logo}\n                  alt={CHAIN_METADATA[tempChain].name}\n                  width={24}\n                  height={24}\n                  className=\"rounded-full size-6\"\n                />\n              ) : (\n                <div className=\"size-8 rounded-full flex items-center justify-center border border-border\">\n                  <Link2 className=\"size-4\" />\n                </div>\n              )}\n            </SelectTrigger>\n          </div>\n          <SelectContent>\n            <SelectGroup>\n              {chainsWithTokens.map((c) => (\n                <SelectItem key={c} value={String(c)}>\n                  <div className=\"flex items-center justify-between gap-x-2\">\n                    <img\n                      src={CHAIN_METADATA[c].logo}\n                      alt={CHAIN_METADATA[c].name}\n                      width={20}\n                      height={20}\n                      className=\"rounded-full size-5\"\n                    />\n                    <span className=\"text-sm\">{CHAIN_METADATA[c].name}</span>\n                  </div>\n                </SelectItem>\n              ))}\n            </SelectGroup>\n          </SelectContent>\n        </Select>\n        <p className=\"text-sm\">\n          {tempChain\n            ? `Tokens on ${SHORT_CHAIN_NAME[tempChain]}`\n            : \"All Tokens\"}\n        </p>\n        <div className=\"rounded-md px-2 max-h-80 overflow-y-auto no-scrollbar\">\n          <div className=\"flex flex-col items-center sm:items-start gap-y-4 w-full no-scrollbar\">\n            {displayedTokens.length > 0 ? (\n              displayedTokens.map((t) => (\n                <DialogClose asChild key={`${t.tokenAddress}-${t.chainId}`}>\n                  <Button\n                    variant={\"ghost\"}\n                    onClick={() => handlePick(t)}\n                    className=\"flex items-center justify-between gap-x-2 p-2 rounded w-full h-max\"\n                  >\n                    <div className=\"flex items-center gap-x-2\">\n                      {t.symbol ? (\n                        <div className=\"relative\">\n                          <TokenIcon\n                            symbol={t.symbol}\n                            tokenLogo={t.logo}\n                            chainLogo={CHAIN_METADATA[t.chainId ?? 1]?.logo}\n                            className=\"border border-border rounded-full\"\n                          />\n                        </div>\n                      ) : null}\n                    </div>\n                    <div className=\"flex flex-col items-end\">\n                      <p className=\"text-base text-foreground\">{t.balance}</p>\n                      <p className=\"text-sm text-muted-foreground\">\n                        {t.balanceInFiat}\n                      </p>\n                    </div>\n                  </Button>\n                </DialogClose>\n              ))\n            ) : (\n              <p className=\"text-xs text-muted-foreground\">No Tokens Found</p>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default DestinationAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/destination-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/destination-container.tsx",
      "content": "import React, { type RefObject, useMemo } from \"react\";\nimport { Label } from \"../../ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  CHAIN_METADATA,\n  type OnSwapIntentHookData,\n  type SUPPORTED_CHAINS_IDS,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport {\n  type SwapInputs,\n  type SwapMode,\n  type TransactionStatus,\n} from \"../hooks/useSwaps\";\nimport { Button } from \"../../ui/button\";\nimport { TokenIcon } from \"./token-icon\";\nimport AmountInput from \"./amount-input\";\nimport { usdFormatter } from \"../../common\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { ChevronDown } from \"lucide-react\";\nimport DestinationAssetSelect from \"./destination-asset-select\";\n\ninterface DestinationContainerProps {\n  destinationHovered: boolean;\n  inputs: SwapInputs;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  destinationBalance?: UserAsset[\"breakdown\"][0];\n  swapBalance: UserAsset[] | null;\n  availableStables: UserAsset[];\n  swapMode: SwapMode;\n  status: TransactionStatus;\n  setInputs: (inputs: Partial<SwapInputs>) => void;\n  setSwapMode: (mode: SwapMode) => void;\n  getFiatValue: (amount: number, token: string) => number;\n  formatBalance: (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number\n  ) => string | undefined;\n}\n\nconst DestinationContainer: React.FC<DestinationContainerProps> = ({\n  destinationHovered,\n  inputs,\n  swapIntent,\n  destinationBalance,\n  swapBalance,\n  availableStables,\n  swapMode,\n  status,\n  setInputs,\n  setSwapMode,\n  getFiatValue,\n  formatBalance,\n}) => {\n  // In exactOut mode, show user's input; in exactIn mode, show calculated destination\n  const displayedAmount =\n    swapMode === \"exactOut\"\n      ? inputs.toAmount ?? \"\"\n      : formatBalance(\n          swapIntent?.current?.intent?.destination?.amount,\n          swapIntent?.current?.intent?.destination?.token?.symbol,\n          swapIntent?.current?.intent?.destination?.token?.decimals\n        ) ?? \"\";\n\n  const quickPickTokens = useMemo(\n    () =>\n      availableStables\n        .map((token) => {\n          const breakdown =\n            token.breakdown?.find(\n              (entry) => Number.parseFloat(entry.balance ?? \"0\") > 0,\n            ) ?? token.breakdown?.[0];\n          if (!breakdown) return null;\n          return { token, breakdown };\n        })\n        .filter(\n          (\n            item,\n          ): item is {\n            token: UserAsset;\n            breakdown: UserAsset[\"breakdown\"][number];\n          } => item !== null,\n        ),\n    [availableStables],\n  );\n\n  return (\n    <div className=\"bg-background rounded-xl flex flex-col items-center w-full gap-y-4\">\n      <div className=\"w-full flex items-center justify-between\">\n        <Label className=\"text-lg font-medium text-foreground\">Buy</Label>\n        {(!inputs?.toToken || !inputs?.toChainID) && (\n          <div\n            className={cn(\n              \"flex transition-all duration-150 ease-out w-full justify-end gap-x-2\",\n              destinationHovered\n                ? \"opacity-100 translate-y-0\"\n                : \"opacity-0 -translate-y-1\"\n            )}\n          >\n            {quickPickTokens.map(({ token, breakdown }) => (\n              <Button\n                key={`${token.symbol}-${breakdown.chain.id}`}\n                size={\"icon-sm\"}\n                variant={\"secondary\"}\n                onClick={() => {\n                  if (!token) return;\n                  setInputs({\n                    ...inputs,\n                    toToken: {\n                      tokenAddress: breakdown.contractAddress,\n                      decimals: token.decimals,\n                      logo: token.icon ?? \"\",\n                      name: token.symbol,\n                      symbol: token.symbol,\n                    },\n                    toChainID: breakdown.chain.id as SUPPORTED_CHAINS_IDS,\n                  });\n                }}\n                className=\"bg-transparent rounded-full hover:-translate-y-1 hover:object-scale-down\"\n              >\n                <TokenIcon\n                  symbol={token?.symbol}\n                  tokenLogo={token?.icon}\n                  chainLogo={breakdown.chain.logo}\n                  size=\"sm\"\n                />\n              </Button>\n            ))}\n          </div>\n        )}\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        <AmountInput\n          amount={displayedAmount}\n          onChange={(val) => {\n            setSwapMode(\"exactOut\");\n            setInputs({ toAmount: val, fromAmount: undefined });\n          }}\n          disabled={status === \"simulating\" || status === \"swapping\"}\n        />\n        <Dialog>\n          <DialogTrigger asChild>\n            <div className=\"flex items-center gap-x-3 bg-card/50 hover:bg-card-foreground/10 border border-border min-w-max rounded-full p-1 cursor-pointer transition-colors\">\n              <TokenIcon\n                symbol={inputs?.toToken?.symbol}\n                tokenLogo={inputs?.toToken?.logo}\n                chainLogo={\n                  inputs?.toChainID\n                    ? CHAIN_METADATA[inputs?.toChainID]?.logo\n                    : undefined\n                }\n                size=\"lg\"\n              />\n              <span className=\"font-medium\">{inputs?.toToken?.symbol}</span>\n              <ChevronDown size={16} className=\"mr-1\" />\n            </div>\n          </DialogTrigger>\n          <DialogContent className=\"max-w-md!\">\n            <DialogHeader>\n              <DialogTitle>Select Destination</DialogTitle>\n            </DialogHeader>\n            <DestinationAssetSelect\n              swapBalance={swapBalance}\n              onSelect={(toChainID, toToken) =>\n                setInputs({ ...inputs, toChainID, toToken })\n              }\n            />\n          </DialogContent>\n        </Dialog>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        {swapIntent?.current?.intent?.destination?.amount && inputs?.toToken ? (\n          <span className=\"text-sm text-accent-foreground\">\n            {usdFormatter.format(\n              getFiatValue(\n                Number.parseFloat(\n                  swapIntent?.current?.intent?.destination?.amount\n                ),\n                inputs.toToken?.symbol\n              )\n            )}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n        {inputs?.toToken ? (\n          <span className=\"text-sm text-muted-foreground\">\n            {formatBalance(\n              destinationBalance?.balance,\n              inputs?.toToken?.symbol,\n              destinationBalance?.decimals\n            ) ?? \"\"}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default DestinationContainer;\n",
      "type": "registry:component",
      "target": "components/swaps/components/destination-container.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/source-asset-select.tsx",
      "content": "\"use client\";\nimport { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport {\n  type UserAsset,\n  type SUPPORTED_CHAINS_IDS,\n  CHAIN_METADATA,\n} from \"@avail-project/nexus-core\";\nimport { TOKEN_IMAGES } from \"../config/destination\";\nimport { Link2, Loader2, Search, X } from \"lucide-react\";\nimport { DialogClose } from \"../../ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n} from \"../../ui/select\";\nimport { TokenIcon } from \"./token-icon\";\nimport { SHORT_CHAIN_NAME } from \"../../common\";\nimport { type SourceTokenInfo } from \"../hooks/useSwaps\";\n\ninterface SourceAssetSelectProps {\n  onSelect: (chainId: SUPPORTED_CHAINS_IDS, token: SourceTokenInfo) => void;\n  swapBalance: UserAsset[] | null;\n}\n\nconst SourceAssetSelect: FC<SourceAssetSelectProps> = ({\n  onSelect,\n  swapBalance,\n}) => {\n  const { swapSupportedChainsAndTokens, nexusSDK } = useNexus();\n  const [tempChain, setTempChain] = useState<{\n    id: number;\n    logo: string;\n    name: string;\n  } | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n\n  // Get all tokens from swapBalance with their chain info\n  const allTokens: SourceTokenInfo[] = useMemo(() => {\n    if (!swapBalance) return [];\n    const tokens: SourceTokenInfo[] = [];\n\n    for (const asset of swapBalance) {\n      if (!asset?.breakdown?.length) continue;\n      for (const breakdown of asset.breakdown) {\n        if (Number.parseFloat(breakdown.balance) <= 0) continue;\n\n        tokens.push({\n          contractAddress: breakdown.contractAddress,\n          decimals: breakdown.decimals ?? asset.decimals,\n          logo: TOKEN_IMAGES[asset.symbol] ?? \"\",\n          name: asset.symbol,\n          symbol: asset.symbol,\n          balance: nexusSDK?.utils?.formatTokenBalance(breakdown?.balance, {\n            symbol: asset.symbol,\n            decimals: asset.decimals,\n          }),\n          balanceInFiat: `$${breakdown.balanceInFiat}`,\n          chainId: breakdown.chain?.id,\n        });\n      }\n    }\n\n    // Dedupe by contractAddress + chainId\n    const unique = new Map<string, SourceTokenInfo>();\n    for (const t of tokens) {\n      const key = `${t.contractAddress.toLowerCase()}-${t.chainId}`;\n      unique.set(key, t);\n    }\n    return Array.from(unique.values());\n  }, [swapBalance, nexusSDK]);\n\n  // Only show chains that have tokens with balance\n  const chainsWithTokens = useMemo(() => {\n    if (!swapSupportedChainsAndTokens || !allTokens.length) return [];\n    const chainIdsWithTokens = new Set(allTokens.map((t) => t.chainId));\n    return swapSupportedChainsAndTokens.filter((c) =>\n      chainIdsWithTokens.has(c.id)\n    );\n  }, [swapSupportedChainsAndTokens, allTokens]);\n\n  // Filter tokens by selected chain and search query\n  const displayedTokens: SourceTokenInfo[] = useMemo(() => {\n    let filtered = allTokens;\n\n    // Filter by chain\n    if (tempChain) {\n      filtered = filtered.filter((t) => t.chainId === tempChain.id);\n    }\n\n    // Filter by search query\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase().trim();\n      filtered = filtered.filter(\n        (t) =>\n          t.symbol.toLowerCase().includes(query) ||\n          t.name.toLowerCase().includes(query) ||\n          t.contractAddress.toLowerCase().includes(query)\n      );\n    }\n\n    return filtered;\n  }, [tempChain, allTokens, searchQuery]);\n\n  const handlePick = (tok: SourceTokenInfo) => {\n    const chainId = tempChain?.id ?? tok.chainId;\n    if (!chainId) return;\n    onSelect(chainId as SUPPORTED_CHAINS_IDS, tok);\n  };\n\n  if (!swapBalance)\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-y-3\">\n        <p className=\"text-sm text-muted-foreground\">\n          Fetching swappable assets\n        </p>\n        <Loader2 className=\"animate-spin size-5\" />\n      </div>\n    );\n\n  return (\n    <div className=\"w-full flex flex-col gap-y-3\">\n      <Select\n        value={tempChain?.name}\n        onValueChange={(value) => {\n          const matchedChain = chainsWithTokens.find(\n            (chain) => chain.name === value\n          );\n          if (matchedChain) {\n            setTempChain(matchedChain);\n          }\n        }}\n      >\n        <div className=\"flex bg-input/30 w-full px-2 py-1.5\">\n          <div className=\"flex items-center gap-x-2 w-full justify-between\">\n            <Search className=\"size-5 opacity-65\" />\n            <input\n              placeholder=\"Search tokens...\"\n              value={searchQuery}\n              onChange={(e) => setSearchQuery(e.target.value)}\n              className=\"bg-transparent w-full text-foreground text-base font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-80\"\n            />\n            {searchQuery && (\n              <button\n                type=\"button\"\n                onClick={() => setSearchQuery(\"\")}\n                className=\"p-0.5 hover:bg-muted rounded-full transition-colors\"\n              >\n                <X className=\"size-4 opacity-65\" />\n              </button>\n            )}\n          </div>\n          <SelectTrigger className=\"rounded-full border-none cursor-pointer bg-transparent!\">\n            {tempChain ? (\n              <img\n                src={tempChain?.logo}\n                alt={tempChain?.name}\n                width={24}\n                height={24}\n                className=\"rounded-full size-6\"\n              />\n            ) : (\n              <div className=\"size-8 rounded-full flex items-center justify-center border border-border\">\n                <Link2 className=\"size-4\" />\n              </div>\n            )}\n          </SelectTrigger>\n        </div>\n        <SelectContent>\n          <SelectGroup>\n            {chainsWithTokens.map((c) => (\n              <SelectItem key={c.id} value={c.name}>\n                <div className=\"flex items-center justify-between gap-x-2\">\n                  <img\n                    src={c.logo}\n                    alt={c.name}\n                    width={20}\n                    height={20}\n                    className=\"rounded-full size-5\"\n                  />\n                  <span className=\"text-sm\">{c.name}</span>\n                </div>\n              </SelectItem>\n            ))}\n          </SelectGroup>\n        </SelectContent>\n      </Select>\n      <p className=\"text-sm\">\n        {tempChain?.id\n          ? `Tokens on ${SHORT_CHAIN_NAME[tempChain.id]}`\n          : \"All Tokens\"}\n      </p>\n      <div className=\"rounded-md max-h-80 overflow-y-auto no-scrollbar\">\n        <div className=\"flex flex-col items-center sm:items-start gap-y-4 w-full no-scrollbar\">\n          {displayedTokens.length > 0 ? (\n            displayedTokens.map((t) => (\n              <DialogClose asChild key={`${t.contractAddress}-${t.chainId}`}>\n                <Button\n                  variant={\"ghost\"}\n                  onClick={() => handlePick(t)}\n                  className=\"flex items-center justify-between gap-x-2 p-2 rounded w-full h-max\"\n                >\n                  <div className=\"flex  items-center gap-x-4\">\n                    {t.symbol ? (\n                      <div className=\"relative\">\n                        <TokenIcon\n                          symbol={t.symbol}\n                          tokenLogo={t.logo}\n                          chainLogo={CHAIN_METADATA[t.chainId ?? 1]?.logo}\n                          className=\"border border-border rounded-full\"\n                        />\n                      </div>\n                    ) : null}\n                  </div>\n                  <div className=\"flex flex-col items-end\">\n                    <p className=\"text-base text-foreground\">{t.balance}</p>\n                    <p className=\"text-sm text-muted-foreground\">\n                      {t.balanceInFiat}\n                    </p>\n                  </div>\n                </Button>\n              </DialogClose>\n            ))\n          ) : (\n            <p className=\"text-xs text-muted-foreground\">No Tokens Found</p>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SourceAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/source-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/source-container.tsx",
      "content": "import React, { type RefObject } from \"react\";\nimport { Label } from \"../../ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"../../ui/button\";\nimport {\n  type TransactionStatus,\n  type SwapInputs,\n  type SwapMode,\n} from \"../hooks/useSwaps\";\nimport { computeAmountFromFraction, usdFormatter } from \"../../common\";\nimport {\n  CHAIN_METADATA,\n  type UserAsset,\n  type OnSwapIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport AmountInput from \"./amount-input\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { TokenIcon } from \"./token-icon\";\nimport { ChevronDown } from \"lucide-react\";\nimport SourceAssetSelect from \"./source-asset-select\";\n\nconst RANGE_OPTIONS = [\n  {\n    label: \"25%\",\n    value: 0.25,\n  },\n  {\n    label: \"50%\",\n    value: 0.5,\n  },\n  {\n    label: \"75%\",\n    value: 0.75,\n  },\n  {\n    label: \"MAX\",\n    value: 1,\n  },\n];\n\nconst SAFETY_MARGIN = 0.05;\n\ninterface SourceContainerProps {\n  status: TransactionStatus;\n  sourceHovered: boolean;\n  inputs: SwapInputs;\n  availableBalance?: UserAsset[\"breakdown\"][0];\n  swapBalance: UserAsset[] | null;\n  swapMode: SwapMode;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  setInputs: (inputs: Partial<SwapInputs>) => void;\n  setSwapMode: (mode: SwapMode) => void;\n  setTxError: (error: string | null) => void;\n  getFiatValue: (amount: number, token: string) => number;\n  formatBalance: (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number\n  ) => string | undefined;\n}\n\nconst SourceContainer: React.FC<SourceContainerProps> = ({\n  status,\n  sourceHovered,\n  inputs,\n  availableBalance,\n  swapBalance,\n  swapMode,\n  swapIntent,\n  setInputs,\n  setSwapMode,\n  setTxError,\n  getFiatValue,\n  formatBalance,\n}) => {\n  const isExactOut = swapMode === \"exactOut\";\n\n  // In exactIn mode, show user's input; in exactOut mode, show calculated source from intent\n  const displayedAmount =\n    swapMode === \"exactIn\"\n      ? inputs.fromAmount ?? \"\"\n      : formatBalance(\n          swapIntent?.current?.intent?.sources?.[0]?.amount,\n          swapIntent?.current?.intent?.sources?.[0]?.token?.symbol,\n          swapIntent?.current?.intent?.sources?.[0]?.token?.decimals\n        ) ?? \"\";\n\n  const isDisabled =\n    isExactOut || status === \"simulating\" || status === \"swapping\";\n\n  // Render exact-out read-only view\n  if (isExactOut) {\n    return (\n      <div className=\"bg-background rounded-xl flex flex-col items-center w-full gap-y-4 h-[134px]\">\n        <div className=\"w-full flex items-center justify-between\">\n          <Label className=\"text-lg font-medium text-foreground\">Sell</Label>\n        </div>\n        <div className=\"flex items-center justify-center w-full py-4\">\n          <p className=\"text-sm text-muted-foreground text-center\">\n            Enter destination token, chain and amount.\n            <br />\n            We&apos;ll calculate the best sources for you.\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-background rounded-xl flex flex-col items-center w-full gap-y-4\">\n      <div className=\"w-full flex items-center justify-between\">\n        <Label className=\"text-lg font-medium text-foreground\">Sell</Label>\n        <div\n          className={cn(\n            \"flex transition-all duration-150 ease-out w-full justify-end gap-x-2\",\n            sourceHovered\n              ? \"opacity-100 translate-y-0\"\n              : \"opacity-0 -translate-y-1\"\n          )}\n        >\n          {RANGE_OPTIONS.map((option) => (\n            <Button\n              key={option.label}\n              size={\"icon-sm\"}\n              variant={\"secondary\"}\n              disabled={!inputs.fromChainID || !inputs.fromToken}\n              onClick={() => {\n                if (!inputs.fromToken) return 0;\n                setSwapMode(\"exactIn\");\n                const amount = computeAmountFromFraction(\n                  availableBalance?.balance ?? \"0\",\n                  option.value,\n                  inputs?.fromToken?.decimals,\n                  SAFETY_MARGIN\n                );\n                setInputs({ fromAmount: amount, toAmount: undefined });\n              }}\n              className=\"px-5 py-1.5 rounded-full hover:-translate-y-1 hover:object-scale-down\"\n            >\n              <p className=\"text-xs font-medium\">{option.label}</p>\n            </Button>\n          ))}\n        </div>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        <AmountInput\n          amount={displayedAmount}\n          onChange={(val) => {\n            if (availableBalance?.balance) {\n              const parsedAvailableBalance = Number.parseFloat(\n                availableBalance?.balance\n              );\n              const parsedVal = Number.parseFloat(val);\n              if (parsedVal > parsedAvailableBalance) {\n                setTxError(\"Insufficient Balance\");\n                return;\n              }\n            }\n            setSwapMode(\"exactIn\");\n            setInputs({ fromAmount: val, toAmount: undefined });\n          }}\n          disabled={isDisabled}\n        />\n\n        <Dialog>\n          <DialogTrigger asChild>\n            <div\n              className={cn(\n                \"flex items-center gap-x-3 bg-card/50 hover:bg-card-foreground/10 border border-border min-w-max rounded-full p-1 cursor-pointer transition-colors\",\n                isDisabled ? \"pointer-events-none select-none opacity-50\" : \"\"\n              )}\n            >\n              <TokenIcon\n                symbol={inputs?.fromToken?.symbol}\n                tokenLogo={inputs?.fromToken?.logo}\n                chainLogo={\n                  inputs?.fromChainID\n                    ? CHAIN_METADATA[inputs?.fromChainID]?.logo\n                    : undefined\n                }\n                size=\"lg\"\n              />\n              <span className=\"font-medium\">{inputs?.fromToken?.symbol}</span>\n              <ChevronDown size={16} className=\"mr-1\" />\n            </div>\n          </DialogTrigger>\n          <DialogContent className=\"max-w-md!\">\n            <DialogHeader>\n              <DialogTitle>Select a Token</DialogTitle>\n            </DialogHeader>\n            <SourceAssetSelect\n              onSelect={(fromChainID, fromToken) =>\n                setInputs({ ...inputs, fromChainID, fromToken })\n              }\n              swapBalance={swapBalance}\n            />\n          </DialogContent>\n        </Dialog>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        {inputs.fromAmount && inputs?.fromToken ? (\n          <span className=\"text-sm text-accent-foreground\">\n            {usdFormatter.format(\n              getFiatValue(\n                Number.parseFloat(inputs.fromAmount),\n                inputs.fromToken?.symbol\n              )\n            )}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n\n        <span className=\"text-sm text-muted-foreground\">\n          {formatBalance(\n            availableBalance?.balance ?? \"0\",\n            inputs?.fromToken?.symbol,\n            availableBalance?.decimals\n          )}\n        </span>\n      </div>\n    </div>\n  );\n};\n\nexport default SourceContainer;\n",
      "type": "registry:component",
      "target": "components/swaps/components/source-container.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/stacked-token-icons.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\n\ntype StackedIconSize = \"sm\" | \"md\" | \"lg\";\n\nconst SIZE_MAP: Record<StackedIconSize, number> = {\n  sm: 24,\n  md: 32,\n  lg: 40,\n};\n\nconst OVERLAP_MAP: Record<StackedIconSize, number> = {\n  sm: 12,\n  md: 16,\n  lg: 20,\n};\n\ninterface TokenSource {\n  tokenLogo?: string;\n  chainLogo?: string;\n  symbol?: string;\n}\n\ninterface StackedTokenIconsProps {\n  sources: TokenSource[];\n  size?: StackedIconSize;\n  maxDisplay?: number;\n  className?: string;\n}\n\nexport const StackedTokenIcons = ({\n  sources,\n  size = \"md\",\n  maxDisplay = 4,\n  className,\n}: StackedTokenIconsProps) => {\n  const dimension = SIZE_MAP[size];\n  const overlap = OVERLAP_MAP[size];\n\n  const displaySources = sources.slice(0, maxDisplay);\n  const remainingCount = sources.length - maxDisplay;\n\n  // Calculate total width based on number of icons\n  const totalWidth =\n    displaySources.length > 0\n      ? dimension + (displaySources.length - 1) * (dimension - overlap)\n      : 0;\n\n  return (\n    <span\n      className={cn(\"relative inline-flex items-center\", className)}\n      style={{ width: totalWidth, height: dimension }}\n    >\n      {displaySources.map((source, index) => (\n        <span\n          key={`${source.symbol}-${index}`}\n          className=\"absolute inline-flex\"\n          style={{\n            left: index * (dimension - overlap),\n            zIndex: displaySources.length - index,\n          }}\n        >\n          <span className=\"relative inline-flex\">\n            {source.tokenLogo ? (\n              <img\n                src={source.tokenLogo}\n                alt={source.symbol ?? \"token\"}\n                width={dimension}\n                height={dimension}\n                className=\"rounded-full object-cover border-2 border-background\"\n              />\n            ) : (\n              <span\n                className={cn(\n                  \"rounded-full bg-ring/80 text-muted-foreground flex items-center justify-center font-semibold uppercase border-2 border-background\",\n                  {\n                    \"h-6 w-6 text-xs\": size === \"sm\",\n                    \"h-8 w-8 text-sm\": size === \"md\",\n                    \"h-10 w-10 text-base\": size === \"lg\",\n                  }\n                )}\n              >\n                {source.symbol?.charAt(0) ?? \"?\"}\n              </span>\n            )}\n            {source.chainLogo && (\n              <span className=\"absolute -bottom-0.5 -right-0.5 rounded-full border border-background bg-background\">\n                <img\n                  src={source.chainLogo}\n                  alt=\"chain logo\"\n                  width={Math.max(12, dimension * 0.35)}\n                  height={Math.max(12, dimension * 0.35)}\n                  className=\"rounded-full object-cover\"\n                />\n              </span>\n            )}\n          </span>\n        </span>\n      ))}\n      {remainingCount > 0 && (\n        <span\n          className=\"absolute inline-flex\"\n          style={{\n            left: displaySources.length * (dimension - overlap),\n            zIndex: 0,\n          }}\n        >\n          <span\n            className={cn(\n              \"rounded-full bg-muted text-muted-foreground flex items-center justify-center font-medium border-2 border-background\",\n              {\n                \"h-6 w-6 text-[10px]\": size === \"sm\",\n                \"h-8 w-8 text-xs\": size === \"md\",\n                \"h-10 w-10 text-sm\": size === \"lg\",\n              }\n            )}\n          >\n            +{remainingCount}\n          </span>\n        </span>\n      )}\n    </span>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/swaps/components/stacked-token-icons.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/step-flow.tsx",
      "content": "import { type FC, Fragment, memo } from \"react\";\nimport { TokenIcon } from \"./token-icon\";\nimport { StackedTokenIcons } from \"./stacked-token-icons\";\nimport { cn } from \"@/lib/utils\";\nimport { Atom, CircleCheck, SquareArrowOutUpRight } from \"lucide-react\";\nimport { type DisplayStep } from \"./transaction-progress\";\n\ninterface TokenSource {\n  tokenLogo: string;\n  chainLogo: string;\n  symbol: string;\n}\n\ninterface StepFlowProps {\n  steps: DisplayStep[];\n  currentIndex: number;\n  totalSteps: number;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  sourceSymbol: string;\n  destinationSymbol: string;\n  sourceLogos: {\n    token: string;\n    chain: string;\n  };\n  destinationLogos: {\n    token: string;\n    chain: string;\n  };\n  allCompleted: boolean;\n  hasMultipleSources?: boolean;\n  sources?: TokenSource[];\n}\n\ninterface StepItemProps {\n  step: DisplayStep;\n  symbol: string;\n  logos: {\n    token: string;\n    chain: string;\n  };\n  explorerUrl: string | null;\n  isCompleted: boolean;\n  isCurrent: boolean;\n  totalSteps: number;\n  index: number;\n  allCompleted: boolean;\n  hasMultipleSources?: boolean;\n  sources?: TokenSource[];\n}\n\nconst StepItem: FC<StepItemProps> = memo(\n  ({\n    step,\n    isCompleted,\n    isCurrent,\n    logos,\n    symbol,\n    totalSteps,\n    index,\n    explorerUrl,\n    allCompleted,\n    hasMultipleSources,\n    sources,\n  }) => {\n    const isSecondLast = index === totalSteps - 2;\n\n    // Determine opacity based on step state\n    const getOpacity = () => {\n      if (allCompleted) return \"opacity-100\";\n      if (isCompleted) return \"opacity-100\";\n      if (isCurrent) return \"opacity-100\";\n      return \"opacity-50\";\n    };\n\n    // Render the appropriate icon based on state\n    const renderIcon = () => {\n      if (isSecondLast) {\n        return <Atom className=\"size-4 animate-spin\" />;\n      }\n      if (hasMultipleSources && sources && sources.length > 0) {\n        return <StackedTokenIcons sources={sources} size=\"sm\" maxDisplay={3} />;\n      }\n      return (\n        <TokenIcon\n          size=\"sm\"\n          symbol={symbol}\n          chainLogo={logos.chain}\n          tokenLogo={logos.token}\n          className=\"w-full h-full object-cover\"\n        />\n      );\n    };\n\n    return (\n      <div\n        className={cn(\n          \"flex gap-x-4 items-center rounded-lg w-full py-1 transition-opacity duration-300\",\n          getOpacity()\n        )}\n      >\n        {/* Left Indicator */}\n        {isCurrent ? (\n          <div className=\"rounded-full relative\">\n            <div\n              className={cn(\n                \"rounded-full flex items-center justify-center ring-2 ring-chart-1 ring-offset-2 ring-offset-background transition-all duration-300 animate-pulse\",\n                hasMultipleSources ? \"min-w-max px-1\" : \"size-6\"\n              )}\n            >\n              {renderIcon()}\n            </div>\n          </div>\n        ) : isCompleted ? (\n          <div className=\"size-6 flex items-center justify-center rounded-full bg-chart-1/10\">\n            <span className=\"size-2 rounded-full bg-chart-1\" />\n          </div>\n        ) : (\n          <div className=\"size-6 flex items-center justify-center rounded-full\">\n            <span className=\"size-2 rounded-full bg-muted-foreground/50\" />\n          </div>\n        )}\n\n        {/* Content */}\n        <div className=\"flex w-full items-center justify-between\">\n          <div className=\"flex flex-col items-start gap-y-0.5\">\n            <h3\n              className={cn(\n                \"font-medium text-sm transition-colors duration-300\",\n                isCompleted || isCurrent\n                  ? \"text-foreground\"\n                  : \"text-muted-foreground\"\n              )}\n            >\n              {step.label}\n            </h3>\n            {explorerUrl &&\n              isCompleted &&\n              (isSecondLast || index === totalSteps - 1) && (\n                <a\n                  href={explorerUrl}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                  className=\"text-xs text-muted-foreground hover:text-foreground inline-flex items-center gap-x-1 transition-colors\"\n                >\n                  <SquareArrowOutUpRight className=\"size-3\" /> View Transaction\n                </a>\n              )}\n          </div>\n\n          {/* Right Actions */}\n          {isCurrent && !isCompleted && (\n            <p className=\"text-xs text-muted-foreground\">\n              Step {index + 1} of {totalSteps}\n            </p>\n          )}\n          {isCompleted && <CircleCheck className=\"size-5 text-chart-1\" />}\n        </div>\n      </div>\n    );\n  }\n);\n\nStepItem.displayName = \"StepItem\";\n\nexport const StepFlow: FC<StepFlowProps> = memo(\n  ({\n    steps,\n    currentIndex,\n    totalSteps,\n    sourceSymbol,\n    destinationSymbol,\n    sourceLogos,\n    destinationLogos,\n    explorerUrls,\n    allCompleted,\n    hasMultipleSources,\n    sources,\n  }) => {\n    return (\n      <div className=\"flex flex-col gap-y-0 w-full\">\n        {steps.map((step, index) => {\n          const isCompleted = !!step.completed;\n          const isCurrent =\n            currentIndex === -1 ? false : index === currentIndex;\n          const isLast = index === steps.length - 1;\n          const url = isLast\n            ? explorerUrls.destinationExplorerUrl\n            : index === steps.length - 2\n            ? explorerUrls.sourceExplorerUrl\n            : null;\n\n          // For source steps (not the last step), pass multiple sources info\n          const isSourceStep = !isLast;\n          const showMultipleSources = isSourceStep && hasMultipleSources;\n\n          return (\n            <Fragment key={step.id}>\n              <StepItem\n                step={step}\n                isCompleted={isCompleted}\n                isCurrent={isCurrent}\n                index={index}\n                symbol={isLast ? destinationSymbol : sourceSymbol}\n                logos={isLast ? destinationLogos : sourceLogos}\n                totalSteps={totalSteps}\n                explorerUrl={url}\n                allCompleted={allCompleted}\n                hasMultipleSources={showMultipleSources}\n                sources={showMultipleSources ? sources : undefined}\n              />\n\n              {!isLast && (\n                <div className=\"flex w-max ml-[11px]\">\n                  <div\n                    className={cn(\n                      \"w-0.5 h-5 border border-dashed transition-colors duration-300\",\n                      isCompleted ? \"border-chart-1/50\" : \"border-border\"\n                    )}\n                  />\n                </div>\n              )}\n            </Fragment>\n          );\n        })}\n      </div>\n    );\n  }\n);\n\nStepFlow.displayName = \"StepFlow\";\n",
      "type": "registry:component",
      "target": "components/swaps/components/step-flow.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/token-icon.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\n\ntype TokenIconSize = \"sm\" | \"md\" | \"lg\";\n\nconst SIZE_MAP: Record<TokenIconSize, number> = {\n  sm: 24,\n  md: 32,\n  lg: 40,\n};\n\ninterface TokenIconProps {\n  symbol?: string;\n  tokenLogo?: string;\n  chainLogo?: string;\n  size?: TokenIconSize;\n  className?: string;\n}\n\nexport const TokenIcon = ({\n  symbol,\n  tokenLogo,\n  chainLogo,\n  size = \"md\",\n  className,\n}: TokenIconProps) => {\n  const dimension = SIZE_MAP[size];\n\n  return (\n    <span className={cn(\"relative inline-flex\", className)}>\n      {tokenLogo ? (\n        <img\n          src={tokenLogo}\n          alt={symbol ?? \"token\"}\n          width={dimension}\n          height={dimension}\n          className={cn(\"rounded-full object-cover\")}\n        />\n      ) : (\n        <span\n          className={cn(\n            \"rounded-full bg-ring/80 text-muted-foreground flex items-center justify-center font-semibold uppercase\",\n            {\n              \"h-6 w-6 text-xs\": size === \"sm\",\n              \"h-8 w-8 text-sm\": size === \"md\",\n              \"h-10 w-10 text-base\": size === \"lg\",\n            },\n          )}\n        >\n          {\" \"}\n        </span>\n      )}\n      {chainLogo ? (\n        <span className=\"absolute -bottom-0.5 -right-0.5 rounded-full border border-background bg-background\">\n          <img\n            src={chainLogo}\n            alt=\"chain logo\"\n            width={Math.max(14, dimension * 0.4)}\n            height={Math.max(14, dimension * 0.4)}\n            className=\"rounded-full object-cover\"\n          />\n        </span>\n      ) : (\n        <span\n          className={cn(\n            \"absolute -bottom-0.5 -right-0.5 rounded-full bg-ring text-muted-foreground flex items-center justify-center font-semibold uppercase size-6\",\n          )}\n        >\n          {\" \"}\n        </span>\n      )}\n    </span>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/swaps/components/token-icon.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/transaction-progress.tsx",
      "content": "import { type FC, useMemo } from \"react\";\nimport {\n  type BridgeStepType,\n  type SwapStepType,\n} from \"@avail-project/nexus-core\";\nimport { StepFlow } from \"./step-flow\";\n\nexport type DisplayStep = { id: string; label: string; completed: boolean };\ntype ProgressStep = BridgeStepType | SwapStepType;\n\ninterface TokenSource {\n  tokenLogo: string;\n  chainLogo: string;\n  symbol: string;\n}\n\ninterface TransactionProgressProps {\n  steps: Array<{ id: number; completed: boolean; step: ProgressStep }>;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  sourceSymbol: string;\n  destinationSymbol: string;\n  sourceLogos: {\n    token: string;\n    chain: string;\n  };\n  destinationLogos: {\n    token: string;\n    chain: string;\n  };\n  hasMultipleSources?: boolean;\n  sources?: TokenSource[];\n}\n\nconst STEP_TYPES = {\n  INTENT_VERIFICATION: [\"CREATE_PERMIT_FOR_SOURCE_SWAP\"],\n  SOURCE_STEP_TYPES: [\n    \"CREATE_PERMIT_EOA_TO_EPHEMERAL\",\n    \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    \"SOURCE_SWAP_BATCH_TX\",\n    \"SOURCE_SWAP_HASH\",\n  ],\n  SOURCE_TRANSACTION: [\"SOURCE_SWAP_HASH\", \"SOURCE_SWAP_BATCH_TX\"],\n  DESTINATION_STEP_TYPES: [\n    \"DESTINATION_SWAP_BATCH_TX\",\n    \"DESTINATION_SWAP_HASH\",\n    \"SWAP_COMPLETE\",\n  ],\n  TRANSACTION_COMPLETE: [\"SWAP_COMPLETE\"],\n};\n\nconst TransactionProgress: FC<TransactionProgressProps> = ({\n  steps,\n  explorerUrls,\n  sourceSymbol,\n  destinationSymbol,\n  sourceLogos,\n  destinationLogos,\n  hasMultipleSources,\n  sources,\n}) => {\n  const { effectiveSteps, currentIndex, allCompleted } = useMemo(() => {\n    const completedTypes = new Set<string | undefined>(\n      steps?.filter((s) => s?.completed).map((s) => s?.step?.type)\n    );\n    // Consider only steps that were actually emitted by the SDK (ignore pre-seeded placeholders)\n    const eventfulTypes = new Set<string | undefined>(\n      steps\n        ?.filter((s) => {\n          const st = s?.step ?? {};\n          return (\n            \"explorerURL\" in st || \"chain\" in st || \"completed\" in st // present when event args were merged into step\n          );\n        })\n        .map((s) => s?.step?.type)\n    );\n    const hasAny = (types: string[]) =>\n      types.some((t) => completedTypes.has(t));\n    const sawAny = (types: string[]) => types.some((t) => eventfulTypes.has(t));\n\n    const intentVerified = hasAny([\"DETERMINING_SWAP\", \"SWAP_START\"]);\n\n    // If the flow does not include SOURCE_* steps, consider it implicitly collected\n\n    const collectedOnSources =\n      (sawAny(STEP_TYPES.SOURCE_STEP_TYPES) &&\n        hasAny(STEP_TYPES.SOURCE_TRANSACTION)) ||\n      (!sawAny(STEP_TYPES.SOURCE_STEP_TYPES) &&\n        hasAny(STEP_TYPES.DESTINATION_STEP_TYPES));\n\n    const filledOnDestination = hasAny(STEP_TYPES.DESTINATION_STEP_TYPES);\n\n    const displaySteps: DisplayStep[] = [\n      { id: \"intent\", label: \"Intent verified\", completed: intentVerified },\n      {\n        id: \"collected\",\n        label: \"Collected on sources\",\n        completed: collectedOnSources,\n      },\n      {\n        id: \"filled\",\n        label: \"Filled on destination\",\n        completed: filledOnDestination,\n      },\n    ];\n\n    // Mark overall completion ONLY when the SDK reports SWAP_COMPLETE\n    const done = hasAny(STEP_TYPES.TRANSACTION_COMPLETE);\n    const current = displaySteps.findIndex((st) => !st.completed);\n    return {\n      effectiveSteps: displaySteps,\n      currentIndex: current,\n      allCompleted: done,\n    };\n  }, [steps]);\n\n  return (\n    <div className=\"w-full flex flex-col items-start\">\n      <StepFlow\n        steps={effectiveSteps}\n        currentIndex={currentIndex}\n        totalSteps={effectiveSteps.length}\n        sourceLogos={sourceLogos}\n        sourceSymbol={sourceSymbol}\n        destinationLogos={destinationLogos}\n        destinationSymbol={destinationSymbol}\n        explorerUrls={explorerUrls}\n        allCompleted={allCompleted}\n        hasMultipleSources={hasMultipleSources}\n        sources={sources}\n      />\n    </div>\n  );\n};\n\nexport default TransactionProgress;\n",
      "type": "registry:component",
      "target": "components/swaps/components/transaction-progress.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/view-transaction.tsx",
      "content": "import React, { FC, type RefObject, useMemo } from \"react\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n} from \"../../ui/dialog\";\nimport {\n  NexusSDK,\n  type SwapStepType,\n  type OnSwapIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport { MoveDown, XIcon } from \"lucide-react\";\nimport { TokenIcon } from \"./token-icon\";\nimport { StackedTokenIcons } from \"./stacked-token-icons\";\nimport { type GenericStep, usdFormatter } from \"../../common\";\nimport { TOKEN_IMAGES } from \"../config/destination\";\nimport { Button } from \"../../ui/button\";\nimport {\n  type ExactOutSourceOption,\n  type SwapMode,\n  type TransactionStatus,\n} from \"../hooks/useSwaps\";\nimport { getIntentMatchedOptionKeys } from \"../utils/source-matching\";\nimport TransactionProgress from \"./transaction-progress\";\nimport { Separator } from \"../../ui/separator\";\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"../../ui/accordion\";\nimport { Checkbox } from \"../../ui/checkbox\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ViewTransactionProps {\n  steps: GenericStep<SwapStepType>[];\n  status: TransactionStatus;\n  swapMode: SwapMode;\n  nexusSDK: NexusSDK | null;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  getFiatValue: (amount: number, token: string) => number;\n  continueSwap: () => void | Promise<void>;\n  exactOutSourceOptions: ExactOutSourceOption[];\n  exactOutSelectedKeys: string[];\n  toggleExactOutSource: (key: string) => void;\n  isExactOutSourceSelectionDirty: boolean;\n  updatingExactOutSources: boolean;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  reset: () => void;\n  txError: string | null;\n}\n\ninterface TokenBreakdownProps\n  extends Omit<\n    ViewTransactionProps,\n    | \"swapIntent\"\n    | \"continueSwap\"\n    | \"status\"\n    | \"explorerUrls\"\n    | \"steps\"\n    | \"reset\"\n    | \"txError\"\n    | \"swapMode\"\n    | \"exactOutSourceOptions\"\n    | \"exactOutSelectedKeys\"\n    | \"toggleExactOutSource\"\n    | \"isExactOutSourceSelectionDirty\"\n    | \"updatingExactOutSources\"\n  > {\n  tokenLogo: string;\n  chainLogo: string;\n  symbol: string;\n  amount: number;\n  decimals: number;\n}\n\nconst TokenBreakdown = ({\n  nexusSDK,\n  getFiatValue,\n  tokenLogo,\n  chainLogo,\n  symbol,\n  amount,\n  decimals,\n}: TokenBreakdownProps) => {\n  return (\n    <div className=\"flex items-center w-full justify-between\">\n      <div className=\"flex flex-col items-start gap-y-1\">\n        <p className=\"text-xl font-medium \">\n          {nexusSDK?.utils.formatTokenBalance(amount, {\n            symbol: symbol,\n            decimals: decimals,\n          })}\n        </p>\n        <p className=\"text-base text-muted-foreground font-medium \">\n          {usdFormatter.format(getFiatValue(amount, symbol))}\n        </p>\n      </div>\n      <TokenIcon\n        symbol={symbol}\n        chainLogo={chainLogo}\n        tokenLogo={tokenLogo}\n        size=\"lg\"\n      />\n    </div>\n  );\n};\n\ninterface MultiSourceBreakdownProps {\n  getFiatValue: (amount: number, token: string) => number;\n  sources: NonNullable<OnSwapIntentHookData[\"intent\"]>[\"sources\"];\n}\n\nconst MultiSourceBreakdown = ({\n  getFiatValue,\n  sources,\n}: MultiSourceBreakdownProps) => {\n  // Calculate summed USD value across all sources\n  const totalUsdValue = useMemo(() => {\n    return sources.reduce((sum, source) => {\n      const amount = Number.parseFloat(source.amount);\n      const fiatValue = getFiatValue(amount, source.token.symbol);\n      return sum + fiatValue;\n    }, 0);\n  }, [sources, getFiatValue]);\n\n  // Prepare sources for stacked icons\n  const stackedSources = useMemo(() => {\n    return sources.map((source) => ({\n      tokenLogo: TOKEN_IMAGES[source.token.symbol] ?? \"\",\n      chainLogo: source.chain.logo,\n      symbol: source.token.symbol,\n    }));\n  }, [sources]);\n\n  return (\n    <div className=\"flex items-center w-full justify-between\">\n      <div className=\"flex flex-col items-start gap-y-1\">\n        <p className=\"text-xl font-medium\">\n          {sources.length} source{sources.length > 1 ? \"s\" : \"\"}\n        </p>\n        <p className=\"text-base text-muted-foreground font-medium\">\n          {usdFormatter.format(totalUsdValue)}\n        </p>\n      </div>\n      <StackedTokenIcons sources={stackedSources} size=\"lg\" maxDisplay={4} />\n    </div>\n  );\n};\n\nconst ViewTransaction: FC<ViewTransactionProps> = ({\n  steps,\n  status,\n  swapMode,\n  nexusSDK,\n  swapIntent,\n  getFiatValue,\n  continueSwap,\n  exactOutSourceOptions,\n  exactOutSelectedKeys,\n  toggleExactOutSource,\n  isExactOutSourceSelectionDirty,\n  updatingExactOutSources,\n  explorerUrls,\n  reset,\n  txError,\n}) => {\n  const transactionIntent = swapIntent.current?.intent;\n  const sources = transactionIntent?.sources ?? [];\n  const hasSources = sources.length > 0;\n  const hasMultipleSources = sources.length > 1;\n  const usedSourceKeys = useMemo(\n    () => getIntentMatchedOptionKeys(sources, exactOutSourceOptions),\n    [sources, exactOutSourceOptions]\n  );\n  const usedSourceKeySet = useMemo(\n    () => new Set(usedSourceKeys),\n    [usedSourceKeys]\n  );\n  const { usedSourceOptions, otherSourceOptions } = useMemo(() => {\n    const usedOrder = new Map(\n      usedSourceKeys.map((key, index) => [key, index] as const)\n    );\n    const used: ExactOutSourceOption[] = [];\n    const other: ExactOutSourceOption[] = [];\n    for (const opt of exactOutSourceOptions) {\n      if (usedSourceKeySet.has(opt.key)) {\n        used.push(opt);\n      } else {\n        other.push(opt);\n      }\n    }\n    used.sort((a, b) => {\n      const aOrder = usedOrder.get(a.key) ?? Number.MAX_SAFE_INTEGER;\n      const bOrder = usedOrder.get(b.key) ?? Number.MAX_SAFE_INTEGER;\n      return aOrder - bOrder;\n    });\n    return { usedSourceOptions: used, otherSourceOptions: other };\n  }, [exactOutSourceOptions, usedSourceKeySet, usedSourceKeys]);\n\n  // Prepare source info for TransactionProgress\n  const sourceInfo = useMemo(() => {\n    if (!hasSources || sources.length === 0) {\n      return {\n        symbol: \"Multiple assets\",\n        logos: { token: \"\", chain: \"\" },\n      };\n    }\n    if (hasMultipleSources) {\n      return {\n        symbol: `${sources.length} sources`,\n        logos: {\n          token: TOKEN_IMAGES[sources[0].token.symbol] ?? \"\",\n          chain: sources[0].chain.logo,\n        },\n      };\n    }\n    return {\n      symbol: sources[0].token.symbol,\n      logos: {\n        token: TOKEN_IMAGES[sources[0].token.symbol] ?? \"\",\n        chain: sources[0].chain.logo,\n      },\n    };\n  }, [sources, hasSources, hasMultipleSources]);\n\n  const shouldShowExactOutSourceSelection =\n    status === \"simulating\" && swapMode === \"exactOut\";\n\n  const exactOutSelectedTotalUsd = useMemo(() => {\n    if (!shouldShowExactOutSourceSelection) return 0;\n    if (!exactOutSourceOptions.length || !exactOutSelectedKeys.length) return 0;\n\n    const selectedSet = new Set(exactOutSelectedKeys);\n    return exactOutSourceOptions.reduce((sum, opt) => {\n      if (!selectedSet.has(opt.key)) return sum;\n      const balance = Number.parseFloat(opt.balance);\n      if (!Number.isFinite(balance) || balance <= 0) return sum;\n      const fiatValue = getFiatValue(balance, opt.tokenSymbol);\n      if (!Number.isFinite(fiatValue) || fiatValue <= 0) return sum;\n      return sum + fiatValue;\n    }, 0);\n  }, [\n    shouldShowExactOutSourceSelection,\n    exactOutSourceOptions,\n    exactOutSelectedKeys,\n    getFiatValue,\n  ]);\n\n  const exactOutRequiredUsd = useMemo(() => {\n    if (!shouldShowExactOutSourceSelection) return 0;\n    const amount = Number.parseFloat(transactionIntent?.destination?.amount ?? \"0\");\n    if (!Number.isFinite(amount) || amount <= 0) return 0;\n    const symbol = transactionIntent?.destination?.token?.symbol;\n    if (!symbol) return 0;\n    const base = getFiatValue(amount, symbol);\n    if (!Number.isFinite(base) || base <= 0) return 0;\n    return base;\n  }, [shouldShowExactOutSourceSelection, transactionIntent, getFiatValue]);\n\n  const isExactOutSourceSelectionInsufficient = useMemo(() => {\n    if (!shouldShowExactOutSourceSelection) return false;\n    if (exactOutRequiredUsd <= 0) return false;\n    return exactOutSelectedTotalUsd < exactOutRequiredUsd;\n  }, [\n    shouldShowExactOutSourceSelection,\n    exactOutRequiredUsd,\n    exactOutSelectedTotalUsd,\n  ]);\n\n  const continueLabel = !hasSources\n    ? \"Waiting for sources...\"\n    : updatingExactOutSources\n      ? \"Updating sources...\"\n      : shouldShowExactOutSourceSelection && isExactOutSourceSelectionDirty\n        ? \"Update sources\"\n        : \"Continue\";\n\n  if (!transactionIntent) return null;\n\n  return (\n    <Dialog\n      defaultOpen={true}\n      onOpenChange={(open) => {\n        if (!open) {\n          reset();\n        }\n      }}\n    >\n      <DialogContent className=\"max-w-md!\" showCloseButton={false}>\n        <DialogHeader className=\"flex-row items-center justify-between w-full\">\n          <p className=\"text-sm font-medium text-muted-foreground\">\n            You&apos;re Swapping\n          </p>\n          <DialogClose>\n            <XIcon className=\"size-5 text-muted-foreground\" />\n          </DialogClose>\n        </DialogHeader>\n        <div className=\"flex flex-col items-start w-full gap-y-4\">\n          {/* Source section - handle empty, single, and multiple sources */}\n          {!hasSources ? (\n            <div className=\"flex items-center w-full justify-between\">\n              <p className=\"text-base text-muted-foreground\">\n                Calculating sources...\n              </p>\n            </div>\n          ) : hasMultipleSources ? (\n            <MultiSourceBreakdown\n              getFiatValue={getFiatValue}\n              sources={sources}\n            />\n          ) : (\n            <TokenBreakdown\n              nexusSDK={nexusSDK}\n              getFiatValue={getFiatValue}\n              tokenLogo={TOKEN_IMAGES[sources[0].token.symbol] ?? \"\"}\n              chainLogo={sources[0].chain.logo}\n              symbol={sources[0].token.symbol}\n              amount={Number.parseFloat(sources[0].amount)}\n              decimals={sources[0].token.decimals}\n            />\n          )}\n          <MoveDown className=\"size-5 -ml-1.5 text-muted-foreground\" />\n          <TokenBreakdown\n            nexusSDK={nexusSDK}\n            getFiatValue={getFiatValue}\n            tokenLogo={\n              TOKEN_IMAGES[transactionIntent?.destination?.token.symbol]\n            }\n            chainLogo={transactionIntent?.destination?.chain.logo}\n            symbol={transactionIntent?.destination?.token.symbol}\n            amount={Number.parseFloat(transactionIntent?.destination?.amount)}\n            decimals={transactionIntent?.destination?.token.decimals}\n          />\n        </div>\n        {status === \"error\" && (\n          <p className=\"text-destructive text-sm\">{txError}</p>\n        )}\n        {shouldShowExactOutSourceSelection &&\n          exactOutSourceOptions.length > 0 && (\n            <Accordion type=\"single\" collapsible className=\"w-full\">\n              <AccordionItem value=\"source-selection\">\n                <AccordionTrigger hideChevron={false} className=\"py-0\">\n                  <div className=\"flex w-full items-center justify-between\">\n                    <p className=\"text-sm font-medium\">Choose sources</p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {exactOutSelectedKeys.length} selected\n                    </p>\n                  </div>\n                </AccordionTrigger>\n                <AccordionContent className=\"mt-3 bg-muted pb-0 px-4 py-3 rounded-lg w-full\">\n                  {isExactOutSourceSelectionInsufficient && (\n                    <div className=\"mb-3 rounded-md border border-amber-500/30 bg-amber-500/10 px-3 py-2 text-sm text-amber-950 dark:text-amber-200\">\n                      Insufficient selected sources balance. Selected{\" \"}\n                      <span className=\"font-medium\">\n                        {usdFormatter.format(exactOutSelectedTotalUsd)}\n                      </span>\n                      , need at least{\" \"}\n                      <span className=\"font-medium\">\n                        {usdFormatter.format(exactOutRequiredUsd)}\n                      </span>{\" \"}\n                      (required for {transactionIntent?.destination?.amount}{\" \"}\n                      {transactionIntent?.destination?.token.symbol}).\n                    </div>\n                  )}\n                  <p className=\"mb-3 text-xs text-muted-foreground\">\n                    {updatingExactOutSources\n                      ? \"Updating sources\"\n                      : isExactOutSourceSelectionDirty\n                        ? \"Changes apply when you press Update sources.\"\n                        : \"Press Continue to proceed with these sources.\"}\n                  </p>\n                  <div className=\"flex max-h-56 flex-col gap-y-3 overflow-auto pr-1\">\n                    {usedSourceOptions.map((opt) => {\n                      const isSelected = exactOutSelectedKeys.includes(opt.key);\n                      const isLastSelected =\n                        isSelected && exactOutSelectedKeys.length === 1;\n                      const isUsed = usedSourceKeySet.has(opt.key);\n                      const tokenLogo =\n                        opt.tokenLogo || TOKEN_IMAGES[opt.tokenSymbol] || \"\";\n                      const formattedBalance =\n                        nexusSDK?.utils?.formatTokenBalance(opt.balance, {\n                          symbol: opt.tokenSymbol,\n                          decimals: opt.decimals,\n                        }) ?? `${opt.balance} ${opt.tokenSymbol}`;\n\n                      return (\n                        <div\n                          key={opt.key}\n                          className={cn(\n                            \"flex w-full select-none items-center justify-between gap-x-3\",\n                            isLastSelected || updatingExactOutSources\n                              ? \"opacity-80 cursor-not-allowed\"\n                              : \"cursor-pointer\"\n                          )}\n                          onClick={() => {\n                            if (isLastSelected || updatingExactOutSources) {\n                              return;\n                            }\n                            toggleExactOutSource(opt.key);\n                          }}\n                          role=\"button\"\n                          tabIndex={0}\n                          onKeyDown={(e) => {\n                            if (isLastSelected || updatingExactOutSources) {\n                              return;\n                            }\n                            if (e.key === \"Enter\" || e.key === \" \") {\n                              e.preventDefault();\n                              toggleExactOutSource(opt.key);\n                            }\n                          }}\n                        >\n                          <div className=\"flex items-center gap-x-2\">\n                            <Checkbox\n                              checked={isSelected}\n                              disabled={isLastSelected || updatingExactOutSources}\n                              onCheckedChange={() => {\n                                if (\n                                  isLastSelected ||\n                                  updatingExactOutSources\n                                ) {\n                                  return;\n                                }\n                                toggleExactOutSource(opt.key);\n                              }}\n                              onClick={(e) => e.stopPropagation()}\n                              aria-label={`Select ${opt.tokenSymbol} on ${opt.chainName} as a source`}\n                            />\n                            <TokenIcon\n                              symbol={opt.tokenSymbol}\n                              tokenLogo={tokenLogo}\n                              chainLogo={opt.chainLogo}\n                              size=\"sm\"\n                            />\n                            <div className=\"flex flex-col leading-tight\">\n                              <p className=\"text-sm font-medium\">\n                                {opt.tokenSymbol}\n                              </p>\n                              <p className=\"text-xs text-muted-foreground\">\n                                {opt.chainName}\n                              </p>\n                            </div>\n                          </div>\n\n                          <div className=\"flex flex-col items-end leading-tight min-w-fit\">\n                            <p className=\"text-sm font-medium\">\n                              {formattedBalance}\n                            </p>\n                            {isUsed && (\n                              <p className=\"text-xs text-muted-foreground\">\n                                Currently used\n                              </p>\n                            )}\n                          </div>\n                        </div>\n                      );\n                    })}\n                    {otherSourceOptions.length > 0 &&\n                      usedSourceOptions.length > 0 && (\n                        <Separator className=\"opacity-40\" />\n                      )}\n                    {otherSourceOptions.map((opt) => {\n                      const isSelected = exactOutSelectedKeys.includes(opt.key);\n                      const isLastSelected =\n                        isSelected && exactOutSelectedKeys.length === 1;\n                      const isUsed = usedSourceKeySet.has(opt.key);\n                      const tokenLogo =\n                        opt.tokenLogo || TOKEN_IMAGES[opt.tokenSymbol] || \"\";\n                      const formattedBalance =\n                        nexusSDK?.utils?.formatTokenBalance(opt.balance, {\n                          symbol: opt.tokenSymbol,\n                          decimals: opt.decimals,\n                        }) ?? `${opt.balance} ${opt.tokenSymbol}`;\n\n                      return (\n                        <div\n                          key={opt.key}\n                          className={cn(\n                            \"flex w-full select-none items-center justify-between gap-x-3\",\n                            isLastSelected || updatingExactOutSources\n                              ? \"opacity-80 cursor-not-allowed\"\n                              : \"cursor-pointer\"\n                          )}\n                          onClick={() => {\n                            if (isLastSelected || updatingExactOutSources) {\n                              return;\n                            }\n                            toggleExactOutSource(opt.key);\n                          }}\n                          role=\"button\"\n                          tabIndex={0}\n                          onKeyDown={(e) => {\n                            if (isLastSelected || updatingExactOutSources) {\n                              return;\n                            }\n                            if (e.key === \"Enter\" || e.key === \" \") {\n                              e.preventDefault();\n                              toggleExactOutSource(opt.key);\n                            }\n                          }}\n                        >\n                          <div className=\"flex items-center gap-x-2\">\n                            <Checkbox\n                              checked={isSelected}\n                              disabled={isLastSelected || updatingExactOutSources}\n                              onCheckedChange={() => {\n                                if (\n                                  isLastSelected ||\n                                  updatingExactOutSources\n                                ) {\n                                  return;\n                                }\n                                toggleExactOutSource(opt.key);\n                              }}\n                              onClick={(e) => e.stopPropagation()}\n                              aria-label={`Select ${opt.tokenSymbol} on ${opt.chainName} as a source`}\n                            />\n                            <TokenIcon\n                              symbol={opt.tokenSymbol}\n                              tokenLogo={tokenLogo}\n                              chainLogo={opt.chainLogo}\n                              size=\"sm\"\n                            />\n                            <div className=\"flex flex-col leading-tight\">\n                              <p className=\"text-sm font-medium\">\n                                {opt.tokenSymbol}\n                              </p>\n                              <p className=\"text-xs text-muted-foreground\">\n                                {opt.chainName}\n                              </p>\n                            </div>\n                          </div>\n\n                          <div className=\"flex flex-col items-end leading-tight min-w-fit\">\n                            <p className=\"text-sm font-medium\">\n                              {formattedBalance}\n                            </p>\n                            {isUsed && (\n                              <p className=\"text-xs text-muted-foreground\">\n                                Currently used\n                              </p>\n                            )}\n                          </div>\n                        </div>\n                      );\n                    })}\n                  </div>\n                  <p className=\"mt-3 text-xs text-muted-foreground\">\n                    Select at least 1 source.\n                  </p>\n                </AccordionContent>\n              </AccordionItem>\n            </Accordion>\n          )}\n        {status === \"simulating\" && (\n          <Button\n            onClick={() => void continueSwap()}\n            disabled={\n              !hasSources ||\n              updatingExactOutSources ||\n              (shouldShowExactOutSourceSelection &&\n                isExactOutSourceSelectionInsufficient)\n            }\n          >\n            {continueLabel}\n          </Button>\n        )}\n\n        {(status === \"swapping\" || status === \"success\") && (\n          <>\n            <Separator className=\"transition-opacity\" />\n            <TransactionProgress\n              steps={steps}\n              explorerUrls={explorerUrls}\n              sourceSymbol={sourceInfo.symbol}\n              destinationSymbol={transactionIntent.destination.token.symbol}\n              sourceLogos={sourceInfo.logos}\n              destinationLogos={{\n                token: TOKEN_IMAGES[transactionIntent.destination.token.symbol],\n                chain: transactionIntent.destination.chain.logo,\n              }}\n              hasMultipleSources={hasMultipleSources}\n              sources={\n                hasMultipleSources\n                  ? sources.map((s) => ({\n                      tokenLogo: TOKEN_IMAGES[s.token.symbol] ?? \"\",\n                      chainLogo: s.chain.logo,\n                      symbol: s.token.symbol,\n                    }))\n                  : undefined\n              }\n            />\n          </>\n        )}\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default ViewTransaction;\n",
      "type": "registry:component",
      "target": "components/swaps/components/view-transaction.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/config/destination.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\n\nexport const DESTINATION_SWAP_TOKENS = new Map<\n  number,\n  {\n    decimals: number;\n    logo: string;\n    name: string;\n    symbol: string;\n    tokenAddress: `0x${string}`;\n  }[]\n>([\n  [\n    SUPPORTED_CHAINS.OPTIMISM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0x94b008aa00579c1307b0ef2c499ad98a8ce58e58\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n        name: \"Optimism\",\n        symbol: \"OP\",\n        tokenAddress: \"0x4200000000000000000000000000000000000042\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n        name: \"Aave Token\",\n        symbol: \"AAVE\",\n        tokenAddress: \"0x76fb31fb4af56892a25e32cfc43de717950c9278\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n        name: \"Uniswap\",\n        symbol: \"UNI\",\n        tokenAddress: \"0x6fd9d7ad17242c41f7131d257212c54a0e816691\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.ARBITRUM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n        name: \"Pepe\",\n        symbol: \"PEPE\",\n        tokenAddress: \"0x25d887ce7a35172c62febfd67a1856f20faebb00\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n        name: \"Lido DAO Token\",\n        symbol: \"LDO\",\n        tokenAddress: \"0x13ad51ed4f1b7e9dc168d8a00cb3f4ddd85efa60\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.SCROLL,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xf55bec9cafdbe8730f096aa55dad6d22d44099df\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BASE,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n        name: \"Dai Stablecoin\",\n        symbol: \"DAI\",\n        tokenAddress: \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n        name: \"LayerZero\",\n        symbol: \"ZRO\",\n        tokenAddress: \"0x6985884c4392d348587b19cb9eaaf157f13271cd\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n        name: \"MANTRA\",\n        symbol: \"OM\",\n        tokenAddress: \"0x3992b27da26848c2b19cea6fd25ad5568b68ab98\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n        name: \"KAITO\",\n        symbol: \"KAITO\",\n        tokenAddress: \"0x98d0baa52b2d063e780de12f615f963fe8537553\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BNB,\n    [\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n        name: \"BNB\",\n        symbol: \"BNB\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n    ],\n  ],\n]);\n\nexport const TOKEN_IMAGES: Record<string, string> = {\n  USDC: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png\",\n  USDT: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n  \"USD0\":\n    \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n  WETH: \"https://assets.coingecko.com/coins/images/279/large/ethereum.png?1595348880\",\n  USDS: \"https://assets.coingecko.com/coins/images/39926/standard/usds.webp?1726666683\",\n  SOPH: \"https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png\",\n  KAIA: \"https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png\",\n  BNB: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n  // Add ETH as fallback for any ETH-related tokens\n  ETH: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n  // Add common token fallbacks\n  POL: \"https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png\",\n  AVAX: \"https://assets.coingecko.com/coins/images/12559/standard/Avalanche_Circle_RedWhite_Trans.png\",\n  FUEL: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png\",\n  HYPE: \"https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png\",\n  // Popular swap tokens\n  DAI: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n  UNI: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n  AAVE: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n  LDO: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n  PEPE: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n  OP: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n  ZRO: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n  OM: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n  KAITO:\n    \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n};\n",
      "type": "registry:component",
      "target": "components/swaps/config/destination.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/hooks/useHover.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\nexport function useEventListener(\n  eventType: string,\n  callback: (event: Event) => void,\n  element: HTMLElement | Window | null\n) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (element == null) return;\n    const handler = (e: Event) => callbackRef.current(e);\n    element.addEventListener(eventType, handler);\n\n    return () => element.removeEventListener(eventType, handler);\n  }, [eventType, element]);\n}\n\nexport default function useHover(ref: React.RefObject<HTMLElement | null>) {\n  const [hovered, setHovered] = useState(false);\n  useEventListener(\"mouseover\", () => setHovered(true), ref?.current);\n  useEventListener(\"mouseout\", () => setHovered(false), ref?.current);\n  return hovered;\n}\n",
      "type": "registry:component",
      "target": "components/swaps/hooks/useHover.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/hooks/useSwaps.ts",
      "content": "import {\n  type RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  NexusSDK,\n  type SUPPORTED_CHAINS_IDS,\n  type ExactInSwapInput,\n  type ExactOutSwapInput,\n  NEXUS_EVENTS,\n  type SwapStepType,\n  type OnSwapIntentHookData,\n  type Source as SwapSource,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport {\n  useTransactionSteps,\n  SWAP_EXPECTED_STEPS,\n  useNexusError,\n  useDebouncedCallback,\n  usePolling,\n} from \"../../common\";\nimport {\n  buildSourceOptionKey,\n  getIntentMatchedOptionKeys,\n  getIntentSourcesSignature,\n} from \"../utils/source-matching\";\n\nexport type SourceTokenInfo = {\n  contractAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n  balance?: string;\n  balanceInFiat?: string;\n  chainId?: number;\n};\n\nexport type DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n  chainId?: number;\n  balance?: string;\n  balanceInFiat?: string;\n};\n\nexport type ExactOutSourceOption = {\n  key: string;\n  chainId: number;\n  chainName: string;\n  chainLogo: string;\n  tokenAddress: `0x${string}`;\n  tokenSymbol: string;\n  tokenLogo: string;\n  balance: string;\n  decimals: number;\n};\n\nexport type TransactionStatus =\n  | \"idle\"\n  | \"simulating\"\n  | \"swapping\"\n  | \"success\"\n  | \"error\";\n\nexport type SwapMode = \"exactIn\" | \"exactOut\";\n\nexport interface SwapInputs {\n  fromChainID?: SUPPORTED_CHAINS_IDS;\n  fromToken?: SourceTokenInfo;\n  fromAmount?: string;\n  toChainID?: SUPPORTED_CHAINS_IDS;\n  toToken?: DestinationTokenInfo;\n  toAmount?: string;\n}\n\nexport type SwapState = {\n  inputs: SwapInputs;\n  swapMode: SwapMode;\n  status: TransactionStatus;\n  error: string | null;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n};\n\ntype Action =\n  | { type: \"setInputs\"; payload: Partial<SwapInputs> }\n  | { type: \"setStatus\"; payload: TransactionStatus }\n  | { type: \"setError\"; payload: string | null }\n  | { type: \"setSwapMode\"; payload: SwapMode }\n  | {\n      type: \"setExplorerUrls\";\n      payload: Partial<SwapState[\"explorerUrls\"]>;\n    }\n  | { type: \"reset\" };\n\nconst initialState: SwapState = {\n  inputs: {\n    fromToken: undefined,\n    toToken: undefined,\n    fromAmount: undefined,\n    toAmount: undefined,\n    fromChainID: undefined,\n    toChainID: undefined,\n  },\n  swapMode: \"exactIn\",\n  status: \"idle\",\n  error: null,\n  explorerUrls: {\n    sourceExplorerUrl: null,\n    destinationExplorerUrl: null,\n  },\n};\n\nfunction reducer(state: SwapState, action: Action): SwapState {\n  switch (action.type) {\n    case \"setInputs\": {\n      return {\n        ...state,\n        inputs: {\n          ...state.inputs,\n          ...action.payload,\n        },\n      };\n    }\n    case \"setStatus\":\n      return { ...state, status: action.payload };\n    case \"setError\":\n      return { ...state, error: action.payload };\n    case \"setSwapMode\":\n      return { ...state, swapMode: action.payload };\n    case \"setExplorerUrls\":\n      return {\n        ...state,\n        explorerUrls: { ...state.explorerUrls, ...action.payload },\n      };\n    case \"reset\":\n      return { ...initialState };\n    default:\n      return state;\n  }\n}\n\ninterface UseSwapsProps {\n  nexusSDK: NexusSDK | null;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  swapBalance: UserAsset[] | null;\n  fetchBalance: () => Promise<void>;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n}\n\nconst useSwaps = ({\n  nexusSDK,\n  swapIntent,\n  swapBalance,\n  fetchBalance,\n  onComplete,\n  onStart,\n  onError,\n}: UseSwapsProps) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const {\n    steps,\n    seed,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<SwapStepType>();\n  const swapRunIdRef = useRef(0);\n  const lastSyncedIntentSourcesSignatureRef = useRef(\"\");\n  const lastSyncedIntentSelectionKeyRef = useRef(\"\");\n\n  const currentIntentSources = swapIntent.current?.intent?.sources ?? [];\n  const currentIntentSourcesSignature = useMemo(\n    () => getIntentSourcesSignature(currentIntentSources),\n    [currentIntentSources]\n  );\n\n  const exactOutSourceOptions = useMemo<ExactOutSourceOption[]>(() => {\n    const optionsByKey = new Map<string, ExactOutSourceOption>();\n    const destinationChainId = state.inputs.toChainID;\n\n    const upsertOption = (option: ExactOutSourceOption) => {\n      optionsByKey.set(option.key, option);\n    };\n\n    for (const asset of swapBalance ?? []) {\n      for (const entry of asset.breakdown ?? []) {\n        const balance = entry.balance ?? \"0\";\n        const parsed = Number.parseFloat(balance);\n        if (!Number.isFinite(parsed) || parsed <= 0) continue;\n\n        const tokenAddress = entry.contractAddress as `0x${string}`;\n        const chainId = entry.chain.id;\n        if (typeof destinationChainId === \"number\" && chainId === destinationChainId) {\n          continue;\n        }\n        upsertOption({\n          key: buildSourceOptionKey(chainId, tokenAddress),\n          chainId,\n          chainName: entry.chain.name,\n          chainLogo: entry.chain.logo,\n          tokenAddress,\n          tokenSymbol: asset.symbol,\n          tokenLogo: asset.icon ?? \"\",\n          balance,\n          decimals: entry.decimals ?? asset.decimals,\n        });\n      }\n    }\n\n    for (const source of currentIntentSources) {\n      const chainId = source.chain.id;\n      if (typeof destinationChainId === \"number\" && chainId === destinationChainId) {\n        continue;\n      }\n      const tokenAddress = source.token.contractAddress as `0x${string}`;\n      const key = buildSourceOptionKey(chainId, tokenAddress);\n      if (optionsByKey.has(key)) continue;\n\n      upsertOption({\n        key,\n        chainId,\n        chainName: source.chain.name,\n        chainLogo: source.chain.logo,\n        tokenAddress,\n        tokenSymbol: source.token.symbol,\n        tokenLogo: \"\",\n        balance: source.amount ?? \"0\",\n        decimals: source.token.decimals,\n      });\n    }\n\n    const options = [...optionsByKey.values()];\n\n    options.sort((a, b) => {\n      if (a.tokenSymbol === b.tokenSymbol) {\n        return a.chainName.localeCompare(b.chainName);\n      }\n      return a.tokenSymbol.localeCompare(b.tokenSymbol);\n    });\n\n    return options;\n  }, [\n    currentIntentSources,\n    currentIntentSourcesSignature,\n    state.inputs.toChainID,\n    swapBalance,\n  ]);\n\n  const exactOutAllSourceKeys = useMemo(\n    () => exactOutSourceOptions.map((opt) => opt.key),\n    [exactOutSourceOptions]\n  );\n\n  const [exactOutSelectedKeys, setExactOutSelectedKeys] = useState<\n    string[] | null\n  >(null);\n  const [appliedExactOutSelectionKey, setAppliedExactOutSelectionKey] =\n    useState(\"ALL\");\n\n  const effectiveExactOutSelectedKeys = useMemo(() => {\n    const allKeys = exactOutAllSourceKeys;\n    if (allKeys.length === 0) return [];\n\n    const selectedKeys = exactOutSelectedKeys ?? allKeys;\n    const selectedSet = new Set(selectedKeys);\n    const filtered = allKeys.filter((key) => selectedSet.has(key));\n    return filtered.length > 0 ? filtered : allKeys;\n  }, [exactOutSelectedKeys, exactOutAllSourceKeys]);\n\n  const isExactOutAllSelected = useMemo(() => {\n    if (exactOutAllSourceKeys.length === 0) return true;\n    return effectiveExactOutSelectedKeys.length === exactOutAllSourceKeys.length;\n  }, [exactOutAllSourceKeys, effectiveExactOutSelectedKeys]);\n\n  const toggleExactOutSource = useCallback(\n    (key: string) => {\n      setExactOutSelectedKeys((prev) => {\n        const allKeys = exactOutAllSourceKeys;\n        if (allKeys.length === 0) return prev;\n\n        const current = prev ?? allKeys;\n        const set = new Set(current);\n        if (set.has(key)) {\n          set.delete(key);\n        } else {\n          set.add(key);\n        }\n\n        const next = allKeys.filter((k) => set.has(k));\n        if (next.length === 0) return prev ?? allKeys; // keep at least 1\n        if (next.length === allKeys.length) return null; // back to default \"all\"\n        return next;\n      });\n    },\n    [exactOutAllSourceKeys]\n  );\n\n  const applyExactOutSelectionKeys = useCallback(\n    (keys: string[]) => {\n      const allKeys = exactOutAllSourceKeys;\n      if (allKeys.length === 0) return;\n\n      const selectedSet = new Set(keys);\n      const filtered = allKeys.filter((k) => selectedSet.has(k));\n      const unique = [...new Set(filtered)];\n      if (unique.length === 0) return;\n\n      const isAllSelected = unique.length === allKeys.length;\n      const selectionKey = isAllSelected\n        ? \"ALL\"\n        : [...unique].sort().join(\"|\");\n\n      setExactOutSelectedKeys(isAllSelected ? null : unique);\n      setAppliedExactOutSelectionKey(selectionKey);\n    },\n    [exactOutAllSourceKeys]\n  );\n\n  const exactOutSelectionKey = useMemo(() => {\n    if (isExactOutAllSelected) return \"ALL\";\n    return [...effectiveExactOutSelectedKeys].sort().join(\"|\");\n  }, [effectiveExactOutSelectedKeys, isExactOutAllSelected]);\n\n  const syncExactOutSelectionFromIntent = useCallback(\n    (\n      intentSources: NonNullable<OnSwapIntentHookData[\"intent\"]>[\"sources\"],\n      force = false\n    ) => {\n      if (intentSources.length === 0 || exactOutSourceOptions.length === 0) {\n        return false;\n      }\n\n      const signature = getIntentSourcesSignature(intentSources);\n      const usedKeys = getIntentMatchedOptionKeys(\n        intentSources,\n        exactOutSourceOptions\n      );\n      if (usedKeys.length === 0) return false;\n      const usedSelectionKey = [...new Set(usedKeys)].sort().join(\"|\");\n      if (\n        !force &&\n        signature === lastSyncedIntentSourcesSignatureRef.current &&\n        usedSelectionKey === lastSyncedIntentSelectionKeyRef.current\n      ) {\n        return false;\n      }\n\n      applyExactOutSelectionKeys(usedKeys);\n      lastSyncedIntentSourcesSignatureRef.current = signature;\n      lastSyncedIntentSelectionKeyRef.current = usedSelectionKey;\n      return true;\n    },\n    [applyExactOutSelectionKeys, exactOutSourceOptions]\n  );\n\n  const exactOutFromSources = useMemo<SwapSource[] | undefined>(() => {\n    if (state.swapMode !== \"exactOut\") return undefined;\n    if (exactOutSourceOptions.length === 0) return undefined;\n\n    const selectedSet = new Set(effectiveExactOutSelectedKeys);\n    const sources: SwapSource[] = [];\n    const seen = new Set<string>();\n\n    for (const opt of exactOutSourceOptions) {\n      if (!selectedSet.has(opt.key)) continue;\n      if (seen.has(opt.key)) continue;\n      seen.add(opt.key);\n      sources.push({ chainId: opt.chainId, tokenAddress: opt.tokenAddress });\n    }\n\n    return sources.length > 0 ? sources : undefined;\n  }, [state.swapMode, effectiveExactOutSelectedKeys, exactOutSourceOptions]);\n  const isExactOutSourceSelectionDirty = useMemo(() => {\n    return (\n      state.swapMode === \"exactOut\" &&\n      exactOutSelectionKey !== appliedExactOutSelectionKey\n    );\n  }, [state.swapMode, exactOutSelectionKey, appliedExactOutSelectionKey]);\n\n  const [updatingExactOutSources, setUpdatingExactOutSources] = useState(false);\n\n  // Validation for exact-in mode\n  const areExactInInputsValid = useMemo(() => {\n    return (\n      state?.inputs?.fromChainID !== undefined &&\n      state?.inputs?.toChainID !== undefined &&\n      state?.inputs?.fromToken &&\n      state?.inputs?.toToken &&\n      state?.inputs?.fromAmount &&\n      Number(state.inputs.fromAmount) > 0\n    );\n  }, [state.inputs]);\n\n  // Validation for exact-out mode\n  const areExactOutInputsValid = useMemo(() => {\n    return (\n      state?.inputs?.toChainID !== undefined &&\n      state?.inputs?.toToken &&\n      state?.inputs?.toAmount &&\n      Number(state.inputs.toAmount) > 0\n    );\n  }, [state.inputs]);\n\n  // Combined validation based on current mode\n  const areInputsValid = useMemo(() => {\n    return state.swapMode === \"exactIn\"\n      ? areExactInInputsValid\n      : areExactOutInputsValid;\n  }, [state.swapMode, areExactInInputsValid, areExactOutInputsValid]);\n\n  const handleNexusError = useNexusError();\n\n  // Event handler shared between exact-in and exact-out\n  const handleSwapEvent = (event: { name: string; args: SwapStepType }) => {\n    if (event.name === NEXUS_EVENTS.SWAP_STEP_COMPLETE) {\n      const step = event.args;\n      if (step?.type === \"SOURCE_SWAP_HASH\" && step.explorerURL) {\n        dispatch({\n          type: \"setExplorerUrls\",\n          payload: { sourceExplorerUrl: step.explorerURL },\n        });\n      }\n      if (step?.type === \"DESTINATION_SWAP_HASH\" && step.explorerURL) {\n        dispatch({\n          type: \"setExplorerUrls\",\n          payload: { destinationExplorerUrl: step.explorerURL },\n        });\n      }\n      onStepComplete(step);\n    }\n  };\n\n  const handleExactInSwap = async (runId: number) => {\n    if (\n      !nexusSDK ||\n      !areExactInInputsValid ||\n      !state?.inputs?.fromToken ||\n      !state?.inputs?.toToken ||\n      !state?.inputs?.fromAmount ||\n      !state?.inputs?.toChainID ||\n      !state?.inputs?.fromChainID\n    )\n      return;\n\n    const amountBigInt = nexusSDK.utils.parseUnits(\n      state.inputs.fromAmount,\n      state.inputs.fromToken.decimals\n    );\n    const swapInput: ExactInSwapInput = {\n      from: [\n        {\n          chainId: state.inputs.fromChainID,\n          amount: amountBigInt,\n          tokenAddress: state.inputs.fromToken.contractAddress,\n        },\n      ],\n      toChainId: state.inputs.toChainID,\n      toTokenAddress: state.inputs.toToken.tokenAddress,\n    };\n\n    const result = await nexusSDK.swapWithExactIn(swapInput, {\n      onEvent: (event) => {\n        if (swapRunIdRef.current !== runId) return;\n        handleSwapEvent(event as { name: string; args: SwapStepType });\n      },\n    });\n\n    if (!result?.success) {\n      throw new Error(result?.error || \"Swap failed\");\n    }\n  };\n\n  const handleExactOutSwap = async (runId: number) => {\n    if (\n      !nexusSDK ||\n      !areExactOutInputsValid ||\n      !state?.inputs?.toToken ||\n      !state?.inputs?.toAmount ||\n      !state?.inputs?.toChainID\n    )\n      return;\n\n    const amountBigInt = nexusSDK.utils.parseUnits(\n      state.inputs.toAmount,\n      state.inputs.toToken.decimals\n    );\n    const swapInput: ExactOutSwapInput = {\n      toAmount: amountBigInt,\n      toChainId: state.inputs.toChainID,\n      toTokenAddress: state.inputs.toToken.tokenAddress,\n      ...(exactOutFromSources ? { fromSources: exactOutFromSources } : {}),\n    };\n\n    const result = await nexusSDK.swapWithExactOut(swapInput, {\n      onEvent: (event) => {\n        if (swapRunIdRef.current !== runId) return;\n        handleSwapEvent(event as { name: string; args: SwapStepType });\n      },\n    });\n    if (!result?.success) {\n      throw new Error(result?.error || \"Swap failed\");\n    }\n  };\n\n  const runSwap = async (runId: number) => {\n    if (!nexusSDK || !areInputsValid) return;\n\n    try {\n      onStart?.();\n      dispatch({ type: \"setStatus\", payload: \"simulating\" });\n      dispatch({ type: \"setError\", payload: null });\n      seed(SWAP_EXPECTED_STEPS);\n\n      if (state.swapMode === \"exactOut\") {\n        setAppliedExactOutSelectionKey(exactOutSelectionKey);\n      } else {\n        setAppliedExactOutSelectionKey(\"ALL\");\n      }\n\n      if (state.swapMode === \"exactIn\") {\n        await handleExactInSwap(runId);\n      } else {\n        await handleExactOutSwap(runId);\n      }\n\n      if (swapRunIdRef.current !== runId) return;\n      dispatch({ type: \"setStatus\", payload: \"success\" });\n      onComplete?.(swapIntent.current?.intent?.destination?.amount);\n      await fetchBalance();\n    } catch (error) {\n      if (swapRunIdRef.current !== runId) return;\n      const { message } = handleNexusError(error);\n      dispatch({ type: \"setStatus\", payload: \"error\" });\n      dispatch({ type: \"setError\", payload: message });\n      onError?.(message);\n      swapIntent.current?.deny();\n      swapIntent.current = null;\n      setExactOutSelectedKeys(null);\n      setAppliedExactOutSelectionKey(\"ALL\");\n      setUpdatingExactOutSources(false);\n      lastSyncedIntentSourcesSignatureRef.current = \"\";\n      lastSyncedIntentSelectionKeyRef.current = \"\";\n      void fetchBalance();\n    }\n  };\n\n  const startSwap = () => {\n    swapRunIdRef.current += 1;\n    const runId = swapRunIdRef.current;\n    void runSwap(runId);\n    return runId;\n  };\n\n  const debouncedSwapStart = useDebouncedCallback(startSwap, 1200);\n\n  const reset = () => {\n    // invalidate any in-flight swap run\n    swapRunIdRef.current += 1;\n    dispatch({ type: \"reset\" });\n    resetSteps();\n    swapIntent.current?.deny();\n    swapIntent.current = null;\n    setExactOutSelectedKeys(null);\n    setAppliedExactOutSelectionKey(\"ALL\");\n    setUpdatingExactOutSources(false);\n    lastSyncedIntentSourcesSignatureRef.current = \"\";\n    lastSyncedIntentSelectionKeyRef.current = \"\";\n  };\n\n  useEffect(() => {\n    if (state.swapMode !== \"exactOut\") return;\n    if (state.status !== \"simulating\") return;\n    if (exactOutSourceOptions.length === 0) return;\n\n    const runId = swapRunIdRef.current;\n    let cancelled = false;\n\n    void (async () => {\n      const start = Date.now();\n      while (!cancelled && Date.now() - start < 10000) {\n        if (swapRunIdRef.current !== runId) return;\n\n        const intentSources = swapIntent.current?.intent?.sources ?? [];\n        if (intentSources.length > 0) {\n          syncExactOutSelectionFromIntent(intentSources);\n          return;\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [\n    currentIntentSourcesSignature,\n    exactOutSourceOptions,\n    state.status,\n    state.swapMode,\n    syncExactOutSelectionFromIntent,\n    swapIntent,\n  ]);\n\n  const availableBalance = useMemo(() => {\n    if (\n      !nexusSDK ||\n      !swapBalance ||\n      !state.inputs?.fromToken ||\n      !state.inputs?.fromChainID\n    )\n      return undefined;\n    return (\n      swapBalance\n        ?.find((token) => token.symbol === state.inputs?.fromToken?.symbol)\n        ?.breakdown?.find(\n          (chain) => chain.chain?.id === state.inputs?.fromChainID\n        ) ?? undefined\n    );\n  }, [\n    state.inputs?.fromToken,\n    state.inputs?.fromChainID,\n    swapBalance,\n    nexusSDK,\n  ]);\n\n  const destinationBalance = useMemo(() => {\n    if (\n      !nexusSDK ||\n      !swapBalance ||\n      !state.inputs?.toToken ||\n      !state.inputs?.toChainID\n    )\n      return undefined;\n    return (\n      swapBalance\n        ?.find((token) => token.symbol === state?.inputs?.toToken?.symbol)\n        ?.breakdown?.find(\n          (chain) => chain.chain?.id === state?.inputs?.toChainID\n        ) ?? undefined\n    );\n  }, [state?.inputs?.toToken, state?.inputs?.toChainID, swapBalance, nexusSDK]);\n\n  const availableStables = useMemo(() => {\n    if (!nexusSDK || !swapBalance) return [];\n    const filteredToken = swapBalance?.filter((token) => {\n      if ([\"USDT\", \"USDC\", \"ETH\", \"DAI\", \"WBTC\"].includes(token.symbol)) {\n        return token;\n      }\n    });\n    return filteredToken ?? [];\n  }, [swapBalance, nexusSDK]);\n\n  const formatBalance = (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number\n  ) => {\n    if (!balance || !symbol || !decimals) return undefined;\n    return nexusSDK?.utils?.formatTokenBalance(balance, {\n      symbol: symbol,\n      decimals: decimals,\n    });\n  };\n\n  useEffect(() => {\n    if (!swapBalance) {\n      fetchBalance();\n    }\n  }, [swapBalance]);\n\n  useEffect(() => {\n    // Check validity based on current swap mode\n    const isValidForCurrentMode =\n      state.swapMode === \"exactIn\"\n        ? areExactInInputsValid &&\n          state?.inputs?.fromAmount &&\n          state?.inputs?.fromChainID &&\n          state?.inputs?.fromToken &&\n          state?.inputs?.toChainID &&\n          state?.inputs?.toToken\n        : areExactOutInputsValid &&\n          state?.inputs?.toAmount &&\n          state?.inputs?.toChainID &&\n          state?.inputs?.toToken;\n\n    if (!isValidForCurrentMode) {\n      swapIntent.current?.deny();\n      swapIntent.current = null;\n      lastSyncedIntentSourcesSignatureRef.current = \"\";\n      lastSyncedIntentSelectionKeyRef.current = \"\";\n      return;\n    }\n    if (state.status === \"idle\") {\n      debouncedSwapStart();\n    }\n  }, [\n    state.inputs,\n    state.swapMode,\n    areExactInInputsValid,\n    areExactOutInputsValid,\n    state.status,\n  ]);\n\n  const refreshSimulation = async () => {\n    try {\n      const updated = await swapIntent.current?.refresh();\n      if (updated) {\n        swapIntent.current!.intent = updated;\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n\n  usePolling(\n    state.status === \"simulating\" && Boolean(swapIntent.current),\n    async () => {\n      await refreshSimulation();\n    },\n    15000\n  );\n\n  const continueSwap = useCallback(async () => {\n    if (state.status !== \"simulating\") return;\n\n    if (state.swapMode !== \"exactOut\" || !isExactOutSourceSelectionDirty) {\n      dispatch({ type: \"setStatus\", payload: \"swapping\" });\n      swapIntent.current?.allow();\n      return;\n    }\n\n    if (!nexusSDK || !areInputsValid) return;\n\n    setUpdatingExactOutSources(true);\n    try {\n      const previousIntent = swapIntent.current;\n      swapRunIdRef.current += 1;\n      const runId = swapRunIdRef.current;\n\n      previousIntent?.deny();\n\n      void runSwap(runId);\n      const start = Date.now();\n      while (Date.now() - start < 10000) {\n        if (swapRunIdRef.current !== runId) return;\n        const nextIntent = swapIntent.current;\n        const sourcesReady =\n          nextIntent &&\n          nextIntent !== previousIntent &&\n          (nextIntent.intent.sources?.length ?? 0) > 0;\n        if (sourcesReady) break;\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n\n      if (swapRunIdRef.current !== runId) return;\n      const nextIntent = swapIntent.current;\n      if (!nextIntent || nextIntent === previousIntent) return;\n      if ((nextIntent.intent.sources?.length ?? 0) === 0) return;\n      syncExactOutSelectionFromIntent(nextIntent.intent.sources, true);\n      // Updated sources are now reflected in the intent. Wait for explicit user\n      // confirmation before proceeding.\n      return;\n    } finally {\n      setUpdatingExactOutSources(false);\n    }\n  }, [\n    areInputsValid,\n    isExactOutSourceSelectionDirty,\n    nexusSDK,\n    runSwap,\n    syncExactOutSelectionFromIntent,\n    state.status,\n    state.swapMode,\n    swapIntent,\n  ]);\n\n  return {\n    status: state.status,\n    inputs: state.inputs,\n    swapMode: state.swapMode,\n    setSwapMode: (mode: SwapMode) =>\n      dispatch({ type: \"setSwapMode\", payload: mode }),\n    setStatus: (status: TransactionStatus) =>\n      dispatch({ type: \"setStatus\", payload: status }),\n    setInputs: (inputs: Partial<SwapInputs>) => {\n      if (state.status === \"error\") {\n        dispatch({ type: \"setError\", payload: null });\n        dispatch({ type: \"setStatus\", payload: \"idle\" });\n      }\n      dispatch({ type: \"setInputs\", payload: inputs });\n    },\n    txError: state.error,\n    setTxError: (error: string | null) =>\n      dispatch({ type: \"setError\", payload: error }),\n    availableBalance,\n    availableStables,\n    destinationBalance,\n    formatBalance,\n    steps,\n    explorerUrls: state.explorerUrls,\n    handleSwap: startSwap,\n    continueSwap,\n    exactOutSourceOptions,\n    exactOutSelectedKeys: effectiveExactOutSelectedKeys,\n    toggleExactOutSource,\n    isExactOutSourceSelectionDirty,\n    updatingExactOutSources,\n    reset,\n    areInputsValid,\n  };\n};\n\nexport default useSwaps;\n",
      "type": "registry:component",
      "target": "components/swaps/hooks/useSwaps.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/swap-widget.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { ArrowDownUp, Loader2, RefreshCcw } from \"lucide-react\";\nimport { useNexus } from \"../nexus/NexusProvider\";\nimport { Button } from \"../ui/button\";\nimport { Separator } from \"../ui/separator\";\nimport useHover from \"./hooks/useHover\";\nimport SourceContainer from \"./components/source-container\";\nimport DestinationContainer from \"./components/destination-container\";\nimport ViewTransaction from \"./components/view-transaction\";\nimport useSwaps, { type SwapInputs } from \"./hooks/useSwaps\";\n\nfunction SwapWidget({\n  onComplete,\n  onStart,\n  onError,\n}: Readonly<{\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: () => void;\n}>) {\n  const sourceContainer = useRef<HTMLDivElement | null>(null);\n  const destinationContainer = useRef<HTMLDivElement | null>(null);\n  const { nexusSDK, swapIntent, swapBalance, fetchSwapBalance, getFiatValue } =\n    useNexus();\n  const {\n    status,\n    inputs,\n    swapMode,\n    setSwapMode,\n    txError,\n    setInputs,\n    setTxError,\n    steps,\n    reset,\n    explorerUrls,\n    availableBalance,\n    availableStables,\n    formatBalance,\n    destinationBalance,\n    continueSwap,\n    exactOutSourceOptions,\n    exactOutSelectedKeys,\n    toggleExactOutSource,\n    isExactOutSourceSelectionDirty,\n    updatingExactOutSources,\n  } = useSwaps({\n    nexusSDK,\n    swapIntent,\n    swapBalance,\n    fetchBalance: fetchSwapBalance,\n    onComplete,\n    onStart,\n    onError,\n  });\n  const sourceHovered = useHover(sourceContainer);\n  const destinationHovered = useHover(destinationContainer);\n\n  const handleInputSwitch = useCallback(() => {\n    swapIntent.current?.deny();\n    swapIntent.current = null;\n\n    // Always reset to exactIn mode and clear amounts when switching\n    setSwapMode(\"exactIn\");\n\n    if (!inputs?.fromToken || !inputs?.toToken) {\n      const switched: SwapInputs = {\n        fromChainID: inputs.toChainID,\n        toChainID: inputs.fromChainID,\n        fromToken: undefined,\n        toToken: undefined,\n        fromAmount: undefined,\n        toAmount: undefined,\n      };\n      setInputs(switched);\n      return;\n    }\n    const isValidSource = swapBalance?.find(\n      (bal) => bal.symbol === inputs.toToken?.symbol\n    );\n    if (!isValidSource) {\n      const switched: SwapInputs = {\n        fromChainID: inputs.toChainID,\n        toToken: {\n          tokenAddress: inputs.fromToken?.contractAddress,\n          decimals: inputs.fromToken?.decimals,\n          symbol: inputs.fromToken?.symbol,\n          name: inputs.fromToken?.name,\n          logo: inputs.fromToken?.logo,\n        },\n        fromToken: undefined,\n        toChainID: inputs.fromChainID,\n        fromAmount: undefined,\n        toAmount: undefined,\n      };\n      setInputs(switched);\n      return;\n    }\n    const switched: SwapInputs = {\n      fromToken: {\n        contractAddress: inputs.toToken?.tokenAddress,\n        decimals: inputs.toToken?.decimals,\n        symbol: inputs.toToken?.symbol,\n        name: inputs.toToken?.name,\n        logo: inputs.toToken?.logo,\n      },\n      fromChainID: inputs.toChainID,\n      toToken: {\n        tokenAddress: inputs.fromToken?.contractAddress,\n        decimals: inputs.fromToken?.decimals,\n        symbol: inputs.fromToken?.symbol,\n        name: inputs.fromToken?.name,\n        logo: inputs.fromToken?.logo,\n      },\n      toChainID: inputs.fromChainID,\n      fromAmount: undefined,\n      toAmount: undefined,\n    };\n    setInputs(switched);\n  }, [inputs, swapIntent, swapBalance, setSwapMode, setInputs]);\n\n  const buttonIcons = useMemo(() => {\n    if (status === \"simulating\") {\n      return <Loader2 className=\"animate-spin size5\" />;\n    }\n    return swapMode === \"exactIn\" ? (\n      <ArrowDownUp className=\"size-5\" />\n    ) : (\n      <RefreshCcw className=\"size-5\" />\n    );\n  }, [status, swapMode]);\n\n  return (\n    <>\n      <div className=\"w-full max-w-md bg-background/40 rounded-2xl px-2.5 py-2 sm:p-6 border border-border\">\n        <div className=\"flex flex-col items-center w-full relative\">\n          <div\n            ref={sourceContainer}\n            className=\"flex flex-col gap-y-3 w-full rounded-2xl\"\n          >\n            <SourceContainer\n              status={status}\n              sourceHovered={sourceHovered}\n              inputs={inputs}\n              availableBalance={availableBalance}\n              swapBalance={swapBalance}\n              swapMode={swapMode}\n              swapIntent={swapIntent}\n              setInputs={setInputs}\n              setSwapMode={setSwapMode}\n              setTxError={setTxError}\n              getFiatValue={getFiatValue}\n              formatBalance={formatBalance}\n            />\n          </div>\n\n          {/* Swap arrow / mode toggle */}\n          <Button\n            variant={\"secondary\"}\n            size={\"icon-lg\"}\n            onClick={handleInputSwitch}\n            title=\"Toggle between exact in and exact out\"\n            className=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10\"\n            disabled={status === \"simulating\" || status === \"swapping\"}\n          >\n            {buttonIcons}\n          </Button>\n          <Separator />\n\n          {/* Buy section */}\n          <div\n            className=\"flex flex-col gap-y-3 w-full rounded-2xl\"\n            ref={destinationContainer}\n          >\n            <DestinationContainer\n              destinationHovered={destinationHovered}\n              inputs={inputs}\n              setInputs={setInputs}\n              swapIntent={swapIntent}\n              destinationBalance={destinationBalance}\n              swapBalance={swapBalance}\n              availableStables={availableStables}\n              swapMode={swapMode}\n              status={status}\n              setSwapMode={setSwapMode}\n              getFiatValue={getFiatValue}\n              formatBalance={formatBalance}\n            />\n          </div>\n        </div>\n        {status === \"error\" && (\n          <p className=\"text-destructive text-sm\">{txError}</p>\n        )}\n      </div>\n\n      {status !== \"idle\" && (\n        <ViewTransaction\n          txError={txError}\n          explorerUrls={explorerUrls}\n          steps={steps}\n          status={status}\n          swapMode={swapMode}\n          swapIntent={swapIntent}\n          getFiatValue={getFiatValue}\n          nexusSDK={nexusSDK}\n          continueSwap={continueSwap}\n          exactOutSourceOptions={exactOutSourceOptions}\n          exactOutSelectedKeys={exactOutSelectedKeys}\n          toggleExactOutSource={toggleExactOutSource}\n          isExactOutSourceSelectionDirty={isExactOutSourceSelectionDirty}\n          updatingExactOutSources={updatingExactOutSources}\n          reset={reset}\n        />\n      )}\n    </>\n  );\n}\n\nexport default SwapWidget;\n",
      "type": "registry:component",
      "target": "components/swaps/swap-widget.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/utils/source-matching.ts",
      "content": "import { type ExactOutSourceOption } from \"../hooks/useSwaps\";\n\ntype IntentSourceLike = {\n  amount?: string;\n  chain: { id: number };\n  token: { contractAddress: string; symbol: string };\n};\n\nfunction normalizeAddress(address?: string | null) {\n  return address ? address.toLowerCase() : null;\n}\n\nfunction buildSymbolKey(chainId: number, symbol?: string | null) {\n  return `${chainId}:${(symbol ?? \"\").toUpperCase()}`;\n}\n\nexport function buildSourceOptionKey(chainId: number, tokenAddress: string) {\n  return `${chainId}:${tokenAddress.toLowerCase()}`;\n}\n\nexport function getIntentSourcesSignature(intentSources: IntentSourceLike[]) {\n  return intentSources\n    .map((source) => {\n      const normalizedAddress =\n        normalizeAddress(source.token.contractAddress) ?? \"\";\n      return `${source.chain.id}:${normalizedAddress}:${source.token.symbol.toUpperCase()}:${source.amount ?? \"\"}`;\n    })\n    .join(\"|\");\n}\n\nexport function getIntentMatchedOptionKeys(\n  intentSources: IntentSourceLike[],\n  sourceOptions: ExactOutSourceOption[],\n) {\n  const optionByAddress = new Map<string, string>();\n  const optionBySymbol = new Map<string, string[]>();\n\n  for (const option of sourceOptions) {\n    const normalizedOptionAddress = normalizeAddress(option.tokenAddress);\n    if (normalizedOptionAddress) {\n      optionByAddress.set(`${option.chainId}:${normalizedOptionAddress}`, option.key);\n    }\n\n    const symbolKey = buildSymbolKey(option.chainId, option.tokenSymbol);\n    const existingForSymbol = optionBySymbol.get(symbolKey) ?? [];\n    existingForSymbol.push(option.key);\n    optionBySymbol.set(symbolKey, existingForSymbol);\n  }\n\n  const matched: string[] = [];\n  const matchedSet = new Set<string>();\n\n  for (const source of intentSources) {\n    const chainId = source.chain.id;\n    const normalizedSourceAddress = normalizeAddress(source.token.contractAddress);\n\n    if (normalizedSourceAddress) {\n      const directMatch = optionByAddress.get(\n        `${chainId}:${normalizedSourceAddress}`,\n      );\n      if (directMatch && !matchedSet.has(directMatch)) {\n        matched.push(directMatch);\n        matchedSet.add(directMatch);\n        continue;\n      }\n    }\n\n    const symbolKey = buildSymbolKey(chainId, source.token.symbol);\n    const symbolCandidates = optionBySymbol.get(symbolKey) ?? [];\n    const availableCandidates = symbolCandidates.filter(\n      (key) => !matchedSet.has(key),\n    );\n    // Avoid ambiguous symbol-only matches. If multiple sources share\n    // chain+symbol, only explicit address matches should be auto-resolved.\n    if (availableCandidates.length === 1) {\n      const fallbackMatch = availableCandidates[0];\n      matched.push(fallbackMatch);\n      matchedSet.add(fallbackMatch);\n    }\n  }\n\n  return matched;\n}\n",
      "type": "registry:component",
      "target": "components/swaps/utils/source-matching.ts"
    },
    {
      "path": "registry/nexus-elements/common/components/ErrorBoundary.tsx",
      "content": "\"use client\";\n\nimport { Component, type ErrorInfo, type ReactNode } from \"react\";\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n}\n\n/**\n * Error boundary component that catches JavaScript errors in child components.\n * Displays a fallback UI instead of crashing the entire widget.\n *\n * @example\n * <ErrorBoundary\n *   fallback={<div>Something went wrong</div>}\n *   onError={(error) => console.error(error)}\n * >\n *   <MyComponent />\n * </ErrorBoundary>\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\"ErrorBoundary caught an error:\", error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n          <div className=\"text-destructive font-medium mb-2\">\n            Something went wrong\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            An unexpected error occurred. Please try again.\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false, error: null })}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * A more specific error boundary for widget containers with reset capability.\n */\ninterface WidgetErrorBoundaryProps extends ErrorBoundaryProps {\n  widgetName?: string;\n  onReset?: () => void;\n}\n\nexport class WidgetErrorBoundary extends Component<\n  WidgetErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: WidgetErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\n      `WidgetErrorBoundary [${this.props.widgetName ?? \"Unknown\"}]:`,\n      error,\n      errorInfo\n    );\n    this.props.onError?.(error, errorInfo);\n  }\n\n  handleReset = (): void => {\n    this.props.onReset?.();\n    this.setState({ hasError: false, error: null });\n  };\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center bg-destructive/5 rounded-lg border border-destructive/20\">\n          <div className=\"text-destructive font-medium mb-2\">\n            {this.props.widgetName\n              ? `${this.props.widgetName} encountered an error`\n              : \"Widget error\"}\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            {this.state.error?.message || \"An unexpected error occurred.\"}\n          </p>\n          <button\n            onClick={this.handleReset}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Reset widget\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/components/ErrorBoundary.tsx"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedCallback.ts",
      "content": "import { useEffect, useMemo, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype AnyFn = (...args: any[]) => any;\n\nexport interface Debounced<T extends AnyFn> {\n  (...args: Parameters<T>): void;\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Returns a debounced function that delays invoking `fn` until after `delay`\n * milliseconds have elapsed since the last call.\n */\nexport function useDebouncedCallback<T extends AnyFn>(\n  fn: T,\n  delay: number\n): Debounced<T> {\n  const latest = useStableCallback(fn);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  const cancel = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const flush = () => {\n    if (timerRef.current && lastArgsRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n       \n      latest(...lastArgsRef.current);\n      lastArgsRef.current = null;\n    }\n  };\n\n  // cancel when delay changes/unmounts\n  useEffect(() => cancel, [delay]);\n\n  return useMemo(() => {\n    const debounced = ((...args: Parameters<T>) => {\n      lastArgsRef.current = args;\n      cancel();\n      timerRef.current = setTimeout(() => {\n         \n        latest(...lastArgsRef.current!);\n        lastArgsRef.current = null;\n        timerRef.current = null;\n      }, delay);\n    }) as Debounced<T>;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, latest]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedValue.ts",
      "content": "import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\n\n/**\n * Derives a debounced value from an input value and delay.\n */\nexport function useDebouncedValue<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState<T>(value);\n  const setter = useDebouncedCallback((v: T) => setDebounced(v), delay);\n\n  useEffect(() => {\n    setter(value);\n    return setter.cancel;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, delay]);\n\n  return debounced;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedValue.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useInterval.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ninterface UseIntervalOptions {\n  enabled?: boolean;\n  immediate?: boolean;\n}\n\n/**\n * Declarative setInterval with pause/resume and latest-callback semantics.\n * Pass delay=null to pause.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options: UseIntervalOptions = {}\n) {\n  const { enabled = true, immediate = false } = options;\n  const savedCallback = useStableCallback(callback);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (!enabled || delay == null) return;\n    if (immediate) {\n      savedCallback();\n    }\n    intervalRef.current = setInterval(savedCallback, delay);\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [delay, enabled, immediate, savedCallback]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useInterval.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useLatest.ts",
      "content": "import { useRef, useLayoutEffect } from \"react\";\n\n/**\n * Returns a ref that always contains the latest value.\n * Useful for accessing current values in callbacks without causing re-renders.\n *\n * @example\n * const countRef = useLatest(count);\n * const handleClick = useCallback(() => {\n *   console.log(countRef.current); // Always the latest count\n * }, []); // No dependency needed!\n */\nexport function useLatest<T>(value: T): React.MutableRefObject<T> {\n  const ref = useRef<T>(value);\n\n  // Use useLayoutEffect to update synchronously before any effects run\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n\n  return ref;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useLatest.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useNexusError.ts",
      "content": "import { NexusError } from \"@avail-project/nexus-core\";\n\nfunction handler(err: unknown) {\n  if (err instanceof NexusError) {\n    return {\n      code: err?.code,\n      message: err?.message,\n      context: err?.data?.context,\n      details: err?.data?.details,\n    };\n  } else {\n    console.error(\"Unexpected error:\", err);\n    return {\n      code: \"unexpected_error\",\n      message: \"Oops! Something went wrong. Please try again.\",\n      context: undefined,\n      details: undefined,\n    };\n  }\n}\nexport function useNexusError() {\n  return handler;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useNexusError.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/usePolling.ts",
      "content": "import { useRef } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { useStableCallback } from \"./useStableCallback\";\n\n/**\n * Declarative polling with in-flight protection (no overlap).\n * When enabled becomes true, an immediate run is executed,\n * followed by interval-based runs.\n */\nexport function usePolling(\n  enabled: boolean,\n  fn: () => Promise<void> | void,\n  intervalMs: number\n) {\n  const inFlightRef = useRef(false);\n  const wrapped = useStableCallback(async () => {\n    if (inFlightRef.current) return;\n    try {\n      inFlightRef.current = true;\n      await fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      inFlightRef.current = false;\n    }\n  });\n\n  useInterval(wrapped, enabled ? intervalMs : null, {\n    enabled,\n    immediate: enabled,\n  });\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/usePolling.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStableCallback.ts",
      "content": "import { useCallback, useRef } from \"react\";\n\n/**\n * Returns a stable function identity that always calls the latest implementation.\n * Useful when passing callbacks to memoized children without re-creating handlers.\n */\nexport function useStableCallback<Args extends readonly unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const fnRef = useRef<(...args: Args) => Return>(fn);\n  fnRef.current = fn;\n\n   \n  const stable = useCallback(\n    ((...args: Args) => {\n      return fnRef.current(...args);\n    }) as (...args: Args) => Return,\n    []\n  );\n\n  return stable;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStableCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStopwatch.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\ninterface UseStopwatchOptions {\n  running?: boolean;\n  intervalMs?: number;\n}\n\n/**\n * Simple stopwatch that increments elapsed seconds while running.\n * Designed to replace scattered timer effects.\n */\nexport function useStopwatch(options: UseStopwatchOptions = {}) {\n  const { running = false, intervalMs = 100 } = options;\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const reset = () => {\n    setElapsedSeconds(0);\n  };\n\n  const stop = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const start = () => {\n    if (timerRef.current) return;\n    timerRef.current = setInterval(() => {\n      // 1s == 1000ms; we add fractional seconds per tick\n      setElapsedSeconds((prev) => prev + intervalMs / 1000);\n    }, intervalMs);\n  };\n\n  useEffect(() => {\n    if (running) {\n      start();\n    } else {\n      stop();\n    }\n    return stop;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [running, intervalMs]);\n\n  return {\n    seconds: elapsedSeconds,\n    start,\n    stop,\n    reset,\n    running: Boolean(timerRef.current),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStopwatch.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useTransactionExecution.ts",
      "content": "import {\n  type BridgeStepType,\n  NEXUS_EVENTS,\n  type NexusSDK,\n  type OnAllowanceHookData,\n  type OnIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport {\n  type Dispatch,\n  type RefObject,\n  type SetStateAction,\n  useCallback,\n  useRef,\n} from \"react\";\nimport { type TransactionStatus } from \"../tx/types\";\nimport {\n  type SourceSelectionValidation,\n  type TransactionFlowEvent,\n  type TransactionFlowExecutor,\n  type TransactionFlowInputs,\n} from \"../types/transaction-flow\";\n\ninterface NexusErrorInfo {\n  code: string;\n  message: string;\n  context?: unknown;\n  details?: unknown;\n}\n\ntype NexusErrorHandler = (error: unknown) => NexusErrorInfo;\n\ninterface UseTransactionExecutionProps {\n  operationName: \"bridge\" | \"transfer\";\n  nexusSDK: NexusSDK | null;\n  intent: RefObject<OnIntentHookData | null>;\n  allowance: RefObject<OnAllowanceHookData | null>;\n  inputs: TransactionFlowInputs;\n  configuredMaxAmount?: string;\n  allAvailableSourceChainIds: number[];\n  sourceChainsForSdk?: number[];\n  sourceSelectionKey: string;\n  sourceSelection: SourceSelectionValidation;\n  loading: boolean;\n  txError: string | null;\n  areInputsValid: boolean;\n  executeTransaction: TransactionFlowExecutor;\n  getMaxForCurrentSelection: () => Promise<string | undefined>;\n  onStepsList: (steps: BridgeStepType[]) => void;\n  onStepComplete: (step: BridgeStepType) => void;\n  resetSteps: () => void;\n  setStatus: (status: TransactionStatus) => void;\n  resetInputs: () => void;\n  setRefreshing: Dispatch<SetStateAction<boolean>>;\n  setIsDialogOpen: Dispatch<SetStateAction<boolean>>;\n  setTxError: Dispatch<SetStateAction<string | null>>;\n  setLastExplorerUrl: Dispatch<SetStateAction<string>>;\n  setSelectedSourceChains: Dispatch<SetStateAction<number[] | null>>;\n  setAppliedSourceSelectionKey: Dispatch<SetStateAction<string>>;\n  stopwatch: {\n    start: () => void;\n    stop: () => void;\n    reset: () => void;\n  };\n  handleNexusError: NexusErrorHandler;\n  onStart?: () => void;\n  onComplete?: () => void;\n  onError?: (message: string) => void;\n  fetchBalance: () => Promise<void>;\n  notifyHistoryRefresh?: () => void;\n}\n\nexport function useTransactionExecution({\n  operationName,\n  nexusSDK,\n  intent,\n  allowance,\n  inputs,\n  configuredMaxAmount,\n  allAvailableSourceChainIds,\n  sourceChainsForSdk,\n  sourceSelectionKey,\n  sourceSelection,\n  loading,\n  txError,\n  areInputsValid,\n  executeTransaction,\n  getMaxForCurrentSelection,\n  onStepsList,\n  onStepComplete,\n  resetSteps,\n  setStatus,\n  resetInputs,\n  setRefreshing,\n  setIsDialogOpen,\n  setTxError,\n  setLastExplorerUrl,\n  setSelectedSourceChains,\n  setAppliedSourceSelectionKey,\n  stopwatch,\n  handleNexusError,\n  onStart,\n  onComplete,\n  onError,\n  fetchBalance,\n  notifyHistoryRefresh,\n}: UseTransactionExecutionProps) {\n  const commitLockRef = useRef(false);\n  const runIdRef = useRef(0);\n\n  const refreshIntent = async (options?: { reportError?: boolean }) => {\n    if (!intent.current) return false;\n    const activeRunId = runIdRef.current;\n    setRefreshing(true);\n    try {\n      const updated = await intent.current.refresh(sourceChainsForSdk);\n      if (activeRunId !== runIdRef.current) return false;\n      if (updated) {\n        intent.current.intent = updated;\n      }\n      setAppliedSourceSelectionKey(sourceSelectionKey);\n      return true;\n    } catch (error) {\n      if (activeRunId !== runIdRef.current) return false;\n      console.error(\"Transaction failed:\", error);\n      if (options?.reportError) {\n        const message = \"Unable to refresh source selection. Please try again.\";\n        setTxError(message);\n        onError?.(message);\n      }\n      return false;\n    } finally {\n      if (activeRunId !== runIdRef.current) return;\n      setRefreshing(false);\n    }\n  };\n\n  const onSuccess = async () => {\n    stopwatch.stop();\n    setStatus(\"success\");\n    onComplete?.();\n    intent.current = null;\n    allowance.current = null;\n    resetInputs();\n    setRefreshing(false);\n    setSelectedSourceChains(null);\n    setAppliedSourceSelectionKey(\"ALL\");\n    await fetchBalance();\n    notifyHistoryRefresh?.();\n  };\n\n  const handleTransaction = async () => {\n    if (commitLockRef.current) return;\n    commitLockRef.current = true;\n    const currentRunId = ++runIdRef.current;\n    let didEnterExecutingState = false;\n    const cleanupSupersededExecution = () => {\n      if (!didEnterExecutingState) return;\n      setRefreshing(false);\n      setIsDialogOpen(false);\n      setLastExplorerUrl(\"\");\n      stopwatch.stop();\n      stopwatch.reset();\n      resetSteps();\n      setStatus(\"idle\");\n    };\n\n    try {\n      if (\n        !inputs?.amount ||\n        !inputs?.recipient ||\n        !inputs?.chain ||\n        !inputs?.token\n      ) {\n        console.error(\"Missing required inputs\");\n        return;\n      }\n      if (!nexusSDK) {\n        const message = \"Nexus SDK not initialized\";\n        setTxError(message);\n        onError?.(message);\n        return;\n      }\n      if (allAvailableSourceChainIds.length === 0) {\n        const message =\n          \"No eligible source chains available for the selected token and destination.\";\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      const parsedAmount = Number(inputs.amount);\n      if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {\n        const message = \"Enter a valid amount greater than 0.\";\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        inputs.amount,\n        inputs.token,\n        inputs.chain,\n      );\n\n      if (configuredMaxAmount) {\n        const configuredMaxRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n          configuredMaxAmount,\n          inputs.token,\n          inputs.chain,\n        );\n        if (amountBigInt > configuredMaxRaw) {\n          const message = `Amount exceeds maximum limit of ${configuredMaxAmount} ${inputs.token}.`;\n          setTxError(message);\n          onError?.(message);\n          setStatus(\"error\");\n          return;\n        }\n      }\n\n      const maxForCurrentSelection = await getMaxForCurrentSelection();\n      if (currentRunId !== runIdRef.current) return;\n      if (!maxForCurrentSelection) {\n        const message = `Unable to determine max ${operationName} amount for selected sources. Please try again.`;\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n      const maxForSelectionRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n        maxForCurrentSelection,\n        inputs.token,\n        inputs.chain,\n      );\n      if (amountBigInt > maxForSelectionRaw) {\n        const message = `Selected sources can provide up to ${maxForCurrentSelection} ${inputs.token}. Reduce amount or enable more sources.`;\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      setStatus(\"executing\");\n      didEnterExecutingState = true;\n      setTxError(null);\n      onStart?.();\n      setLastExplorerUrl(\"\");\n      setAppliedSourceSelectionKey(sourceSelectionKey);\n\n      const onEvent = (event: TransactionFlowEvent) => {\n        if (currentRunId !== runIdRef.current) return;\n        if (event.name === NEXUS_EVENTS.STEPS_LIST) {\n          const list = Array.isArray(event.args) ? event.args : [];\n          onStepsList(list as BridgeStepType[]);\n        }\n        if (event.name === NEXUS_EVENTS.STEP_COMPLETE) {\n          if (\n            !Array.isArray(event.args) &&\n            \"type\" in event.args &&\n            event.args.type === \"INTENT_HASH_SIGNED\"\n          ) {\n            stopwatch.start();\n          }\n          if (!Array.isArray(event.args)) {\n            onStepComplete(event.args as BridgeStepType);\n          }\n        }\n      };\n\n      const transactionResult = await executeTransaction({\n        token: inputs.token,\n        amount: amountBigInt,\n        toChainId: inputs.chain,\n        recipient: inputs.recipient,\n        sourceChains: sourceChainsForSdk,\n        onEvent,\n      });\n\n      if (currentRunId !== runIdRef.current) {\n        cleanupSupersededExecution();\n        return;\n      }\n      if (!transactionResult) {\n        throw new Error(\"Transaction rejected by user\");\n      }\n      setLastExplorerUrl(transactionResult.explorerUrl);\n      await onSuccess();\n    } catch (error) {\n      if (currentRunId !== runIdRef.current) {\n        cleanupSupersededExecution();\n        return;\n      }\n      const { message, code, context, details } = handleNexusError(error);\n      console.error(`Fast ${operationName} transaction failed:`, {\n        code,\n        message,\n        context,\n        details,\n      });\n      intent.current?.deny();\n      intent.current = null;\n      allowance.current = null;\n      setTxError(message);\n      onError?.(message);\n      setIsDialogOpen(false);\n      setSelectedSourceChains(null);\n      setRefreshing(false);\n      stopwatch.stop();\n      stopwatch.reset();\n      resetSteps();\n      void fetchBalance();\n      setStatus(\"error\");\n    } finally {\n      commitLockRef.current = false;\n    }\n  };\n\n  const reset = () => {\n    runIdRef.current += 1;\n    intent.current?.deny();\n    intent.current = null;\n    allowance.current = null;\n    resetInputs();\n    setStatus(\"idle\");\n    setRefreshing(false);\n    setSelectedSourceChains(null);\n    setAppliedSourceSelectionKey(\"ALL\");\n    setLastExplorerUrl(\"\");\n    stopwatch.stop();\n    stopwatch.reset();\n    resetSteps();\n  };\n\n  const startTransaction = () => {\n    if (!intent.current) return;\n    if (allAvailableSourceChainIds.length === 0) {\n      const message =\n        \"No eligible source chains available for the selected token and destination.\";\n      setTxError(message);\n      onError?.(message);\n      return;\n    }\n    if (sourceSelection.isBelowRequired && inputs?.token) {\n      const message = `Selected sources are not enough. Add ${sourceSelection.missingToProceed} ${inputs.token} more to make this transaction.`;\n      setTxError(message);\n      onError?.(message);\n      return;\n    }\n    void (async () => {\n      const refreshed = await refreshIntent({ reportError: true });\n      if (!refreshed || !intent.current) return;\n      intent.current.allow();\n      setIsDialogOpen(true);\n      setTxError(null);\n    })();\n  };\n\n  const commitAmount = async () => {\n    if (intent.current || loading || txError || !areInputsValid) return;\n    await handleTransaction();\n  };\n\n  const invalidatePendingExecution = useCallback(() => {\n    runIdRef.current += 1;\n    if (intent.current) {\n      intent.current.deny();\n      intent.current = null;\n    }\n    setRefreshing(false);\n    setAppliedSourceSelectionKey(\"ALL\");\n  }, [intent, setAppliedSourceSelectionKey, setRefreshing]);\n\n  return {\n    refreshIntent,\n    handleTransaction,\n    startTransaction,\n    commitAmount,\n    reset,\n    invalidatePendingExecution,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useTransactionExecution.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useTransactionFlow.ts",
      "content": "import {\n  type BridgeStepType,\n  type NexusNetwork,\n  NexusSDK,\n  type OnAllowanceHookData,\n  type OnIntentHookData,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport {\n  useEffect,\n  useMemo,\n  useCallback,\n  useRef,\n  useState,\n  useReducer,\n  type RefObject,\n} from \"react\";\nimport { type Address, isAddress } from \"viem\";\nimport { useNexusError } from \"./useNexusError\";\nimport { useTransactionExecution } from \"./useTransactionExecution\";\nimport { usePolling } from \"./usePolling\";\nimport { useStopwatch } from \"./useStopwatch\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\nimport { type TransactionStatus } from \"../tx/types\";\nimport { useTransactionSteps } from \"../tx/useTransactionSteps\";\nimport {\n  type SourceCoverageState,\n  type TransactionFlowExecutor,\n  type TransactionFlowInputs,\n  type TransactionFlowPrefill,\n  type TransactionFlowType,\n} from \"../types/transaction-flow\";\nimport {\n  MAX_AMOUNT_DEBOUNCE_MS,\n  buildInitialInputs,\n  clampAmountToMax,\n  formatAmountForDisplay,\n  getCoverageDecimals,\n  normalizeMaxAmount,\n} from \"../utils/transaction-flow\";\n\ninterface BaseTransactionFlowProps {\n  type: TransactionFlowType;\n  network: NexusNetwork;\n  nexusSDK: NexusSDK | null;\n  intent: RefObject<OnIntentHookData | null>;\n  allowance: RefObject<OnAllowanceHookData | null>;\n  bridgableBalance: UserAsset[] | null;\n  prefill?: TransactionFlowPrefill;\n  onComplete?: () => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  fetchBalance: () => Promise<void>;\n  maxAmount?: string | number;\n  isSourceMenuOpen?: boolean;\n  notifyHistoryRefresh?: () => void;\n  executeTransaction: TransactionFlowExecutor;\n}\n\nexport interface UseTransactionFlowProps extends BaseTransactionFlowProps {\n  connectedAddress?: Address;\n}\n\ntype State = {\n  inputs: TransactionFlowInputs;\n  status: TransactionStatus;\n};\n\ntype Action =\n  | { type: \"setInputs\"; payload: Partial<TransactionFlowInputs> }\n  | { type: \"resetInputs\" }\n  | { type: \"setStatus\"; payload: TransactionStatus };\n\nexport function useTransactionFlow(props: UseTransactionFlowProps) {\n  const {\n    type,\n    network,\n    nexusSDK,\n    intent,\n    bridgableBalance,\n    prefill,\n    onComplete,\n    onStart,\n    onError,\n    fetchBalance,\n    allowance,\n    maxAmount,\n    isSourceMenuOpen = false,\n    notifyHistoryRefresh,\n    executeTransaction,\n  } = props;\n\n  const connectedAddress = props.connectedAddress;\n  const operationName = type === \"bridge\" ? \"bridge\" : \"transfer\";\n  const handleNexusError = useNexusError();\n  const initialState: State = {\n    inputs: buildInitialInputs({ type, network, connectedAddress, prefill }),\n    status: \"idle\",\n  };\n\n  function reducer(state: State, action: Action): State {\n    switch (action.type) {\n      case \"setInputs\":\n        return { ...state, inputs: { ...state.inputs, ...action.payload } };\n      case \"resetInputs\":\n        return {\n          ...state,\n          inputs: buildInitialInputs({\n            type,\n            network,\n            connectedAddress,\n            prefill,\n          }),\n        };\n      case \"setStatus\":\n        return { ...state, status: action.payload };\n      default:\n        return state;\n    }\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const inputs = state.inputs;\n  const setInputs = (\n    next: TransactionFlowInputs | Partial<TransactionFlowInputs>,\n  ) => {\n    dispatch({\n      type: \"setInputs\",\n      payload: next as Partial<TransactionFlowInputs>,\n    });\n  };\n\n  const loading = state.status === \"executing\";\n  const [refreshing, setRefreshing] = useState(false);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [txError, setTxError] = useState<string | null>(null);\n  const [lastExplorerUrl, setLastExplorerUrl] = useState<string>(\"\");\n  const previousConnectedAddressRef = useRef<Address | undefined>(\n    connectedAddress,\n  );\n  const maxAmountRequestIdRef = useRef(0);\n  const [selectedSourceChains, setSelectedSourceChains] = useState<\n    number[] | null\n  >(null);\n  const [selectedSourcesMaxAmount, setSelectedSourcesMaxAmount] = useState<\n    string | null\n  >(null);\n  const [appliedSourceSelectionKey, setAppliedSourceSelectionKey] =\n    useState(\"ALL\");\n  const {\n    steps,\n    onStepsList,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<BridgeStepType>();\n  const configuredMaxAmount = useMemo(\n    () => normalizeMaxAmount(maxAmount),\n    [maxAmount],\n  );\n\n  const areInputsValid = useMemo(() => {\n    const hasToken = inputs?.token !== undefined && inputs?.token !== null;\n    const hasChain = inputs?.chain !== undefined && inputs?.chain !== null;\n    const hasAmount = Boolean(inputs?.amount) && Number(inputs?.amount) > 0;\n    const hasValidRecipient =\n      Boolean(inputs?.recipient) && isAddress(inputs.recipient as string);\n    return hasToken && hasChain && hasAmount && hasValidRecipient;\n  }, [inputs]);\n\n  const filteredBridgableBalance = useMemo(() => {\n    return bridgableBalance?.find((bal) =>\n      inputs?.token === \"USDM\"\n        ? bal?.symbol === \"USDC\"\n        : bal?.symbol === inputs?.token,\n    );\n  }, [bridgableBalance, inputs?.token]);\n\n  const availableSources = useMemo(() => {\n    const breakdown = filteredBridgableBalance?.breakdown ?? [];\n    const destinationChainId = inputs?.chain;\n    const nonZero = breakdown.filter((source) => {\n      if (Number.parseFloat(source.balance ?? \"0\") <= 0) return false;\n      if (typeof destinationChainId === \"number\") {\n        return source.chain.id !== destinationChainId;\n      }\n      return true;\n    });\n    const decimals = filteredBridgableBalance?.decimals;\n    if (!nexusSDK || typeof decimals !== \"number\") {\n      return nonZero.sort(\n        (a, b) => Number.parseFloat(b.balance) - Number.parseFloat(a.balance),\n      );\n    }\n    return nonZero.sort((a, b) => {\n      try {\n        const aRaw = nexusSDK.utils.parseUnits(a.balance ?? \"0\", decimals);\n        const bRaw = nexusSDK.utils.parseUnits(b.balance ?? \"0\", decimals);\n        if (aRaw === bRaw) return 0;\n        return aRaw > bRaw ? -1 : 1;\n      } catch {\n        return Number.parseFloat(b.balance) - Number.parseFloat(a.balance);\n      }\n    });\n  }, [\n    inputs?.chain,\n    filteredBridgableBalance?.breakdown,\n    filteredBridgableBalance?.decimals,\n    nexusSDK,\n  ]);\n\n  const allAvailableSourceChainIds = useMemo(\n    () => availableSources.map((source) => source.chain.id),\n    [availableSources],\n  );\n\n  const effectiveSelectedSourceChains = useMemo(() => {\n    if (selectedSourceChains && selectedSourceChains.length > 0) {\n      const availableSet = new Set(allAvailableSourceChainIds);\n      const filteredSelection = selectedSourceChains.filter((id) =>\n        availableSet.has(id),\n      );\n      if (filteredSelection.length > 0) {\n        return filteredSelection;\n      }\n    }\n    return allAvailableSourceChainIds;\n  }, [selectedSourceChains, allAvailableSourceChainIds]);\n\n  const sourceChainsForSdk =\n    effectiveSelectedSourceChains.length > 0\n      ? effectiveSelectedSourceChains\n      : undefined;\n\n  const sourceSelectionKey = useMemo(() => {\n    if (allAvailableSourceChainIds.length === 0) return \"NONE\";\n    if (!selectedSourceChains || selectedSourceChains.length === 0) {\n      return \"ALL\";\n    }\n    return [...effectiveSelectedSourceChains].sort((a, b) => a - b).join(\"|\");\n  }, [\n    allAvailableSourceChainIds.length,\n    effectiveSelectedSourceChains,\n    selectedSourceChains,\n  ]);\n  const hasPendingSourceSelectionChanges =\n    sourceSelectionKey !== appliedSourceSelectionKey;\n  const intentSourceSpendAmount = intent.current?.intent?.sourcesTotal;\n\n  const getMaxForCurrentSelection = useCallback(async () => {\n    if (!nexusSDK || !inputs?.token || !inputs?.chain) return undefined;\n    const maxBalAvailable = await nexusSDK.calculateMaxForBridge({\n      token: inputs.token,\n      toChainId: inputs.chain,\n      recipient: inputs.recipient,\n      sourceChains: sourceChainsForSdk,\n    });\n    if (!maxBalAvailable?.amount) return \"0\";\n    return clampAmountToMax({\n      amount: maxBalAvailable.amount,\n      maxAmount: configuredMaxAmount,\n      nexusSDK,\n      token: inputs.token,\n      chainId: inputs.chain,\n    });\n  }, [\n    configuredMaxAmount,\n    inputs?.chain,\n    inputs?.recipient,\n    inputs?.token,\n    nexusSDK,\n    sourceChainsForSdk,\n  ]);\n\n  const toggleSourceChain = useCallback(\n    (chainId: number) => {\n      setSelectedSourceChains((prev) => {\n        if (allAvailableSourceChainIds.length === 0) return prev;\n        const current =\n          prev && prev.length > 0 ? prev : allAvailableSourceChainIds;\n        const next = current.includes(chainId)\n          ? current.filter((id) => id !== chainId)\n          : [...current, chainId];\n        if (next.length === 0) {\n          return current;\n        }\n        const isAllSelected =\n          next.length === allAvailableSourceChainIds.length &&\n          allAvailableSourceChainIds.every((id) => next.includes(id));\n        return isAllSelected ? null : next;\n      });\n    },\n    [allAvailableSourceChainIds],\n  );\n\n  const sourceSelection = useMemo(() => {\n    const amount = intentSourceSpendAmount?.trim() ?? inputs?.amount?.trim() ?? \"\";\n    const decimals = getCoverageDecimals({\n      type,\n      token: inputs?.token,\n      chainId: inputs?.chain,\n      fallback: filteredBridgableBalance?.decimals,\n    });\n    const selectedChainSet = new Set(effectiveSelectedSourceChains);\n    const selectedTotalRaw =\n      !nexusSDK || typeof decimals !== \"number\"\n        ? BigInt(0)\n        : availableSources.reduce((sum, source) => {\n            if (!selectedChainSet.has(source.chain.id)) return sum;\n            try {\n              return (\n                sum + nexusSDK.utils.parseUnits(source.balance ?? \"0\", decimals)\n              );\n            } catch {\n              return sum;\n            }\n          }, BigInt(0));\n    const selectedTotal =\n      !nexusSDK || typeof decimals !== \"number\"\n        ? \"0\"\n        : formatAmountForDisplay(selectedTotalRaw, decimals, nexusSDK);\n    const baseSelection = {\n      selectedTotal,\n      requiredTotal: amount || \"0\",\n      requiredSafetyTotal: amount || \"0\",\n      missingToProceed: \"0\",\n      missingToSafety: \"0\",\n      coverageState: \"healthy\" as SourceCoverageState,\n      coverageToSafetyPercent: 100,\n      isBelowRequired: false,\n      isBelowSafetyBuffer: false,\n    };\n\n    if (!nexusSDK || !inputs?.token || !inputs?.chain || !amount) {\n      return baseSelection;\n    }\n\n    try {\n      const requiredRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n        amount,\n        inputs.token,\n        inputs.chain,\n      );\n      if (requiredRaw <= BigInt(0)) {\n        return baseSelection;\n      }\n\n      const missingToProceedRaw =\n        selectedTotalRaw >= requiredRaw\n          ? BigInt(0)\n          : requiredRaw - selectedTotalRaw;\n      const missingToSafetyRaw = missingToProceedRaw;\n\n      const coverageState: SourceCoverageState =\n        selectedTotalRaw < requiredRaw\n          ? \"error\"\n          : \"healthy\";\n\n      const coverageBasisPoints =\n        requiredRaw === BigInt(0)\n          ? 10_000\n          : selectedTotalRaw >= requiredRaw\n            ? 10_000\n            : Number((selectedTotalRaw * BigInt(10_000)) / requiredRaw);\n\n      return {\n        selectedTotal,\n        requiredTotal: amount,\n        requiredSafetyTotal: amount,\n        missingToProceed: formatAmountForDisplay(\n          missingToProceedRaw,\n          decimals,\n          nexusSDK,\n        ),\n        missingToSafety: formatAmountForDisplay(\n          missingToSafetyRaw,\n          decimals,\n          nexusSDK,\n        ),\n        coverageState,\n        coverageToSafetyPercent: coverageBasisPoints / 100,\n        isBelowRequired: coverageState === \"error\",\n        isBelowSafetyBuffer: coverageState === \"error\",\n      };\n    } catch {\n      return baseSelection;\n    }\n  }, [\n    type,\n    filteredBridgableBalance?.decimals,\n    nexusSDK,\n    inputs?.chain,\n    inputs?.amount,\n    inputs?.token,\n    intentSourceSpendAmount,\n    availableSources,\n    effectiveSelectedSourceChains,\n  ]);\n\n  const stopwatch = useStopwatch({ intervalMs: 100 });\n  const setStatus = useCallback(\n    (status: TransactionStatus) =>\n      dispatch({ type: \"setStatus\", payload: status }),\n    [],\n  );\n\n  const resetInputs = useCallback(() => {\n    dispatch({ type: \"resetInputs\" });\n  }, []);\n\n  const {\n    refreshIntent,\n    handleTransaction,\n    startTransaction,\n    commitAmount,\n    reset,\n    invalidatePendingExecution,\n  } = useTransactionExecution({\n    operationName,\n    nexusSDK,\n    intent,\n    allowance,\n    inputs,\n    configuredMaxAmount,\n    allAvailableSourceChainIds,\n    sourceChainsForSdk,\n    sourceSelectionKey,\n    sourceSelection,\n    loading,\n    txError,\n    areInputsValid,\n    executeTransaction,\n    getMaxForCurrentSelection,\n    onStepsList,\n    onStepComplete,\n    resetSteps,\n    setStatus,\n    resetInputs,\n    setRefreshing,\n    setIsDialogOpen,\n    setTxError,\n    setLastExplorerUrl,\n    setSelectedSourceChains,\n    setAppliedSourceSelectionKey,\n    stopwatch,\n    handleNexusError,\n    onStart,\n    onComplete,\n    onError,\n    fetchBalance,\n    notifyHistoryRefresh,\n  });\n\n  usePolling(\n    Boolean(intent.current) &&\n      !isDialogOpen &&\n      !isSourceMenuOpen &&\n      !hasPendingSourceSelectionChanges,\n    async () => {\n      await refreshIntent();\n    },\n    15000,\n  );\n\n  const debouncedRefreshMaxForSelection = useDebouncedCallback(\n    async (requestId: number) => {\n      try {\n        const maxForCurrentSelection = await getMaxForCurrentSelection();\n        if (requestId !== maxAmountRequestIdRef.current) return;\n        setSelectedSourcesMaxAmount(maxForCurrentSelection ?? \"0\");\n      } catch (error) {\n        if (requestId !== maxAmountRequestIdRef.current) return;\n        console.error(\"Unable to calculate max for selected sources:\", error);\n        setSelectedSourcesMaxAmount(\"0\");\n      }\n    },\n    MAX_AMOUNT_DEBOUNCE_MS,\n  );\n\n  useEffect(() => {\n    debouncedRefreshMaxForSelection.cancel();\n    if (!nexusSDK || !inputs?.token || !inputs?.chain) {\n      maxAmountRequestIdRef.current += 1;\n      setSelectedSourcesMaxAmount(null);\n      return;\n    }\n    if (allAvailableSourceChainIds.length === 0) {\n      maxAmountRequestIdRef.current += 1;\n      setSelectedSourcesMaxAmount(\"0\");\n      return;\n    }\n    const requestId = ++maxAmountRequestIdRef.current;\n    debouncedRefreshMaxForSelection(requestId);\n  }, [\n    allAvailableSourceChainIds.length,\n    configuredMaxAmount,\n    debouncedRefreshMaxForSelection,\n    inputs?.recipient,\n    sourceSelectionKey,\n    inputs?.chain,\n    inputs?.token,\n    nexusSDK,\n  ]);\n\n  useEffect(() => {\n    if (type !== \"bridge\" || !connectedAddress) return;\n    const previousConnectedAddress = previousConnectedAddressRef.current;\n    if (!previousConnectedAddress) {\n      previousConnectedAddressRef.current = connectedAddress;\n      return;\n    }\n    if (connectedAddress === previousConnectedAddress) return;\n    previousConnectedAddressRef.current = connectedAddress;\n    if (prefill?.recipient) return;\n    if (!inputs?.recipient || inputs.recipient === previousConnectedAddress) {\n      dispatch({ type: \"setInputs\", payload: { recipient: connectedAddress } });\n    }\n  }, [type, connectedAddress, inputs?.recipient, prefill?.recipient]);\n\n  useEffect(() => {\n    invalidatePendingExecution();\n  }, [inputs, invalidatePendingExecution]);\n\n  useEffect(() => {\n    setSelectedSourceChains(null);\n  }, [inputs?.token]);\n\n  useEffect(() => {\n    if (!isDialogOpen) {\n      stopwatch.stop();\n      stopwatch.reset();\n    }\n  }, [isDialogOpen, stopwatch]);\n\n  useEffect(() => {\n    if (txError) {\n      setTxError(null);\n    }\n  }, [inputs, txError]);\n\n  return {\n    inputs,\n    setInputs,\n    timer: stopwatch.seconds,\n    setIsDialogOpen,\n    setTxError,\n    loading,\n    refreshing,\n    isDialogOpen,\n    txError,\n    handleTransaction,\n    reset,\n    filteredBridgableBalance,\n    startTransaction,\n    commitAmount,\n    lastExplorerUrl,\n    steps,\n    status: state.status,\n    availableSources,\n    selectedSourceChains: effectiveSelectedSourceChains,\n    toggleSourceChain,\n    isSourceSelectionInsufficient: sourceSelection.isBelowRequired,\n    isSourceSelectionBelowSafetyBuffer: sourceSelection.isBelowSafetyBuffer,\n    isSourceSelectionReadyForAccept:\n      sourceSelection.coverageState === \"healthy\",\n    sourceCoverageState: sourceSelection.coverageState,\n    sourceCoveragePercent: sourceSelection.coverageToSafetyPercent,\n    missingToProceed: sourceSelection.missingToProceed,\n    missingToSafety: sourceSelection.missingToSafety,\n    selectedTotal: sourceSelection.selectedTotal,\n    requiredTotal: sourceSelection.requiredTotal,\n    requiredSafetyTotal: sourceSelection.requiredSafetyTotal,\n    maxAvailableAmount: selectedSourcesMaxAmount ?? undefined,\n    isInputsValid: areInputsValid,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useTransactionFlow.ts"
    },
    {
      "path": "registry/nexus-elements/common/index.ts",
      "content": "export * from \"./hooks/useStopwatch\";\nexport * from \"./hooks/usePolling\";\nexport * from \"./hooks/useInterval\";\nexport * from \"./hooks/useStableCallback\";\nexport * from \"./hooks/useLatest\";\nexport * from \"./hooks/useDebouncedValue\";\nexport * from \"./hooks/useDebouncedCallback\";\nexport * from \"./hooks/useNexusError\";\nexport * from \"./hooks/useTransactionFlow\";\nexport * from \"./types/transaction-flow\";\nexport * from \"./tx/types\";\nexport * from \"./tx/steps\";\nexport * from \"./tx/useTransactionSteps\";\nexport * from \"./utils/constant\";\nexport * from \"./components/ErrorBoundary\";\n",
      "type": "registry:component",
      "target": "components/common/index.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/steps.ts",
      "content": "import type { SwapStepType } from \"@avail-project/nexus-core\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\n\n/**\n * Predefined expected steps for swaps to seed UI before events arrive.\n * Kept here to avoid duplication across exact-in and exact-out hooks.\n */\nexport const SWAP_EXPECTED_STEPS: SwapStepType[] = [\n  { type: \"SWAP_START\", typeID: \"SWAP_START\" } as SwapStepType,\n  { type: \"DETERMINING_SWAP\", typeID: \"DETERMINING_SWAP\" } as SwapStepType,\n  {\n    type: \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    typeID:\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_BATCH_TX\",\n    typeID: \"SOURCE_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_HASH\",\n    typeID: \"SOURCE_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"RFF_ID\", typeID: \"RFF_ID\" } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_BATCH_TX\",\n    typeID: \"DESTINATION_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_HASH\",\n    typeID: \"DESTINATION_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"SWAP_COMPLETE\", typeID: \"SWAP_COMPLETE\" } as SwapStepType,\n];\n\nexport function seedSteps<T>(expected: T[]): Array<GenericStep<T>> {\n  return expected.map((st, index) => ({\n    id: index,\n    completed: false,\n    step: st,\n  }));\n}\n\nexport function computeAllCompleted<T>(steps: Array<GenericStep<T>>): boolean {\n  return steps.length > 0 && steps.every((s) => s.completed);\n}\n\n/**\n * Replace the current list of steps with a new list, preserving completion\n * for any steps that were already marked completed (matched by key).\n */\nexport function mergeStepsList<T>(\n  prev: Array<GenericStep<T>>,\n  list: T[]\n): Array<GenericStep<T>> {\n  const completedKeys = new Set<string>();\n  for (const prevStep of prev) {\n    if (prevStep.completed) {\n      completedKeys.add(getStepKey(prevStep.step));\n    }\n  }\n  const next: Array<GenericStep<T>> = [];\n  for (let index = 0; index < list.length; index++) {\n    const step = list[index];\n    const key = getStepKey(step);\n    next.push({\n      id: index,\n      completed: completedKeys.has(key),\n      step,\n    });\n  }\n  return next;\n}\n\n/**\n * Mark a step complete in-place; if the step doesn't yet exist, append it.\n */\nexport function mergeStepComplete<T>(\n  prev: Array<GenericStep<T>>,\n  step: T\n): Array<GenericStep<T>> {\n  const key = getStepKey(step);\n  const updated: Array<GenericStep<T>> = [];\n  let found = false;\n  for (const s of prev) {\n    if (getStepKey(s.step) === key) {\n      updated.push({ ...s, completed: true, step: { ...s.step, ...step } });\n      found = true;\n    } else {\n      updated.push(s);\n    }\n  }\n  if (!found) {\n    updated.push({\n      id: updated.length,\n      completed: true,\n      step,\n    });\n  }\n  return updated;\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/steps.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/types.ts",
      "content": "export type TransactionStatus =\n  | \"idle\"\n  | \"preview\"\n  | \"awaiting-approval\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\nexport type GenericStep<TStep> = {\n  id: number;\n  completed: boolean;\n  step: TStep;\n};\n\n/**\n * Normalizes a step to a stable key. Prefers typeID, then type, otherwise JSON.\n */\nexport function getStepKey(step: any): string {\n  if (!step) return \"\";\n  if (typeof step.typeID === \"string\" && step.typeID.length > 0) {\n    return step.typeID;\n  }\n  if (typeof step.type === \"string\" && step.type.length > 0) {\n    return step.type;\n  }\n  try {\n    return JSON.stringify(step);\n  } catch {\n    return String(step);\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/types.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/useTransactionSteps.ts",
      "content": "import { useMemo, useRef, useState } from \"react\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\nimport {\n  computeAllCompleted,\n  mergeStepComplete,\n  mergeStepsList,\n  seedSteps,\n} from \"./steps\";\n\ninterface UseTransactionStepsOptions<T> {\n  expected?: T[];\n}\n\n/**\n * Manages transaction steps with utilities to seed from expected steps,\n * replace the list on \"steps list\" events, and mark individual steps complete.\n */\nexport function useTransactionSteps<\n  T extends { typeID?: string; type?: string }\n>(options: UseTransactionStepsOptions<T> = {}) {\n  const { expected } = options;\n  const [steps, setSteps] = useState<Array<GenericStep<T>>>(() =>\n    expected ? seedSteps(expected) : []\n  );\n  const lastSignatureRef = useRef<string>(\"\");\n\n  const onStepsList = (list: T[]) => {\n    const signature = list.map((step) => getStepKey(step)).join(\"|\");\n    if (lastSignatureRef.current === signature) {\n      setSteps((prev) => mergeStepsList(prev, list));\n      return;\n    }\n    lastSignatureRef.current = signature;\n    setSteps((prev) => mergeStepsList(prev, list));\n  };\n\n  const onStepComplete = (step: T) => {\n    setSteps((prev) => mergeStepComplete(prev, step));\n  };\n\n  const seed = (expectedSteps: T[]) => {\n    setSteps(seedSteps(expectedSteps));\n  };\n\n  const reset = () => {\n    setSteps(expected ? seedSteps(expected) : []);\n    lastSignatureRef.current = \"\";\n  };\n\n  const allCompleted = useMemo(() => computeAllCompleted(steps), [steps]);\n\n  return {\n    steps,\n    allCompleted,\n    onStepsList,\n    onStepComplete,\n    seed,\n    reset,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/useTransactionSteps.ts"
    },
    {
      "path": "registry/nexus-elements/common/types/transaction-flow.ts",
      "content": "import {\n  type NexusSDK,\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\n\nexport type TransactionFlowType = \"bridge\" | \"transfer\";\n\nexport interface TransactionFlowInputs {\n  chain: SUPPORTED_CHAINS_IDS;\n  token: SUPPORTED_TOKENS;\n  amount?: string;\n  recipient?: `0x${string}`;\n}\n\nexport interface TransactionFlowPrefill {\n  token: string;\n  chainId: number;\n  amount?: string;\n  recipient?: Address;\n}\n\ntype BridgeOptions = NonNullable<Parameters<NexusSDK[\"bridge\"]>[1]>;\n\nexport type TransactionFlowEvent =\n  NonNullable<BridgeOptions[\"onEvent\"]> extends (event: infer E) => void\n    ? E\n    : never;\n\nexport type TransactionFlowOnEvent = NonNullable<BridgeOptions[\"onEvent\"]>;\n\nexport interface TransactionFlowExecuteParams {\n  token: SUPPORTED_TOKENS;\n  amount: bigint;\n  toChainId: SUPPORTED_CHAINS_IDS;\n  recipient: `0x${string}`;\n  sourceChains?: number[];\n  onEvent: TransactionFlowOnEvent;\n}\n\nexport type TransactionFlowExecutor = (\n  params: TransactionFlowExecuteParams,\n) => Promise<{ explorerUrl: string } | null>;\n\nexport type SourceCoverageState = \"healthy\" | \"warning\" | \"error\";\n\nexport interface SourceSelectionValidation {\n  coverageState: SourceCoverageState;\n  isBelowRequired: boolean;\n  missingToProceed: string;\n  missingToSafety: string;\n}\n",
      "type": "registry:component",
      "target": "components/common/types/transaction-flow.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/constant.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\nimport { formatUnits, parseUnits } from \"viem\";\n\nexport const SHORT_CHAIN_NAME: Record<number, string> = {\n  [SUPPORTED_CHAINS.ETHEREUM]: \"Ethereum\",\n  [SUPPORTED_CHAINS.BASE]: \"Base\",\n  [SUPPORTED_CHAINS.ARBITRUM]: \"Arbitrum\",\n  [SUPPORTED_CHAINS.OPTIMISM]: \"Optimism\",\n  [SUPPORTED_CHAINS.POLYGON]: \"Polygon\",\n  [SUPPORTED_CHAINS.AVALANCHE]: \"Avalanche\",\n  [SUPPORTED_CHAINS.SCROLL]: \"Scroll\",\n  [SUPPORTED_CHAINS.MEGAETH]: \"MegaETH\",\n  [SUPPORTED_CHAINS.KAIA]: \"Kaia\",\n  [SUPPORTED_CHAINS.BNB]: \"BNB\",\n  [SUPPORTED_CHAINS.MONAD]: \"Monad\",\n  [SUPPORTED_CHAINS.HYPEREVM]: \"HyperEVM\",\n  [SUPPORTED_CHAINS.CITREA]: \"Citrea\",\n  // [SUPPORTED_CHAINS.TRON]: \"Tron\",\n  [SUPPORTED_CHAINS.SEPOLIA]: \"Sepolia\",\n  [SUPPORTED_CHAINS.BASE_SEPOLIA]: \"Base Sepolia\",\n  [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: \"Arbitrum Sepolia\",\n  [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: \"Optimism Sepolia\",\n  [SUPPORTED_CHAINS.POLYGON_AMOY]: \"Polygon Amoy\",\n  [SUPPORTED_CHAINS.MONAD_TESTNET]: \"Monad Testnet\",\n  // [SUPPORTED_CHAINS.TRON_SHASTA]: \"Tron Shasta\",\n} as const;\n\nconst DEFAULT_SAFETY_MARGIN = 0.01; // 1%\n\n/**\n * Compute an amount string for fraction buttons (25%, 50%, 75%, 100%).\n *\n * @param balanceStr - user's balance as a human decimal string (e.g. \"12.345\") OR as base-unit integer string if `balanceIsBaseUnits` true\n * @param fraction - fraction e.g. 0.25, 0.5, 0.75, 1\n * @param decimals - token decimals (6 for USDC/USDT, 18 for ETH)\n * @param safetyMargin - 0.01 for 1% default\n * @param balanceIsBaseUnits - if true, balanceStr is already base units integer string (wei / smallest unit)\n * @returns decimal string clipped to token decimals (rounded down)\n */\nexport function computeAmountFromFraction(\n  balanceStr: string,\n  fraction: number,\n  decimals: number,\n  safetyMargin = DEFAULT_SAFETY_MARGIN,\n  balanceIsBaseUnits = false,\n): string {\n  if (!balanceStr) return \"0\";\n\n  // parse balance into base units (BigInt)\n  const balanceUnits: bigint = balanceIsBaseUnits\n    ? BigInt(balanceStr)\n    : parseUnits(balanceStr, decimals);\n\n  if (balanceUnits === BigInt(0)) return \"0\";\n\n  // Use an integer precision multiplier to avoid FP issues\n  const PREC = 1_000_000; // 1e6 precision for fraction & safety margin\n  const safetyMul = BigInt(Math.max(0, Math.floor((1 - safetyMargin) * PREC))); // (1 - safetyMargin) * PREC\n  const fractionMul = BigInt(Math.max(0, Math.floor(fraction * PREC))); // fraction * PREC\n\n  // Apply safety margin: floor(balance * (1 - safetyMargin))\n  const maxAfterSafety = (balanceUnits * safetyMul) / BigInt(PREC);\n\n  // Apply fraction and floor: floor(maxAfterSafety * fraction)\n  let desiredUnits = (maxAfterSafety * fractionMul) / BigInt(PREC);\n\n  // Extra clamp just in case\n  if (desiredUnits > balanceUnits) desiredUnits = balanceUnits;\n  if (desiredUnits < BigInt(0)) desiredUnits = BigInt(0);\n\n  // format back to human readable decimal string with token decimals (formatUnits truncates/keeps decimals)\n  // formatUnits will produce exactly decimals digits if fractional part exists; we'll strip trailing zeros.\n  const raw = formatUnits(desiredUnits, decimals);\n  // strip trailing zeros and possible trailing dot\n  return raw\n    .replace(/(\\.\\d*?[1-9])0+$/u, \"$1\")\n    .replace(/\\.0+$/u, \"\")\n    .replace(/^\\.$/u, \"0\");\n}\n\nexport const usdFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n",
      "type": "registry:component",
      "target": "components/common/utils/constant.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/transaction-flow.ts",
      "content": "import {\n  type NexusNetwork,\n  NexusSDK,\n  SUPPORTED_CHAINS,\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\n\nconst MAX_AMOUNT_REGEX = /^\\d*\\.?\\d+$/;\n\nexport const MAX_AMOUNT_DEBOUNCE_MS = 300;\n\nexport const normalizeMaxAmount = (\n  maxAmount?: string | number,\n): string | undefined => {\n  if (maxAmount === undefined || maxAmount === null) return undefined;\n  const value = String(maxAmount).trim();\n  if (!value || value === \".\" || !MAX_AMOUNT_REGEX.test(value)) {\n    return undefined;\n  }\n  const parsed = Number.parseFloat(value);\n  if (!Number.isFinite(parsed) || parsed <= 0) return undefined;\n  return value;\n};\n\nexport const clampAmountToMax = ({\n  amount,\n  maxAmount,\n  nexusSDK,\n  token,\n  chainId,\n}: {\n  amount: string;\n  maxAmount?: string;\n  nexusSDK: NexusSDK;\n  token: SUPPORTED_TOKENS;\n  chainId: SUPPORTED_CHAINS_IDS;\n}): string => {\n  if (!maxAmount) return amount;\n  try {\n    const amountRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n      amount,\n      token,\n      chainId,\n    );\n    const maxRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n      maxAmount,\n      token,\n      chainId,\n    );\n    return amountRaw > maxRaw ? maxAmount : amount;\n  } catch {\n    return amount;\n  }\n};\n\nexport const formatAmountForDisplay = (\n  amount: bigint,\n  decimals: number | undefined,\n  nexusSDK: NexusSDK,\n): string => {\n  if (typeof decimals !== \"number\") return amount.toString();\n  const formatted = nexusSDK.utils.formatUnits(amount, decimals);\n  if (!formatted.includes(\".\")) return formatted;\n  const [whole, fraction] = formatted.split(\".\");\n  const trimmedFraction = fraction.slice(0, 6).replace(/0+$/, \"\");\n  if (!trimmedFraction && whole === \"0\" && amount > BigInt(0)) {\n    return \"0.000001\";\n  }\n  return trimmedFraction ? `${whole}.${trimmedFraction}` : whole;\n};\n\nexport const buildInitialInputs = ({\n  type,\n  network,\n  connectedAddress,\n  prefill,\n}: {\n  type: \"bridge\" | \"transfer\";\n  network: NexusNetwork;\n  connectedAddress?: Address;\n  prefill?: {\n    token: string;\n    chainId: number;\n    amount?: string;\n    recipient?: Address;\n  };\n}) => {\n  return {\n    chain:\n      (prefill?.chainId as SUPPORTED_CHAINS_IDS) ??\n      (network === \"testnet\"\n        ? SUPPORTED_CHAINS.SEPOLIA\n        : SUPPORTED_CHAINS.ETHEREUM),\n    token: (prefill?.token as SUPPORTED_TOKENS) ?? \"USDC\",\n    amount: prefill?.amount ?? undefined,\n    recipient:\n      (prefill?.recipient as `0x${string}`) ??\n      (type === \"bridge\" ? connectedAddress : undefined),\n  };\n};\n\nexport const getCoverageDecimals = ({\n  type,\n  token,\n  chainId,\n  fallback,\n}: {\n  type: \"bridge\" | \"transfer\";\n  token?: SUPPORTED_TOKENS;\n  chainId?: SUPPORTED_CHAINS_IDS;\n  fallback: number | undefined;\n}) => {\n  if (token === \"USDM\") return 18;\n  if (type === \"bridge\" && token === \"USDC\" && chainId === SUPPORTED_CHAINS.BNB) {\n    return 18;\n  }\n  return fallback;\n};\n",
      "type": "registry:component",
      "target": "components/common/utils/transaction-flow.ts"
    }
  ]
}