{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swaps",
  "type": "registry:component",
  "title": "Swaps",
  "description": "Swap tokens across chains (Exact In)",
  "dependencies": [
    "@avail-project/nexus-core@1.0.0-beta.56",
    "@radix-ui/react-dialog",
    "@radix-ui/react-label",
    "@radix-ui/react-select",
    "@radix-ui/react-slot",
    "@radix-ui/react-tabs",
    "@radix-ui/react-popover",
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://elements.nexus.availproject.org/r/button.json",
    "https://elements.nexus.availproject.org/r/separator.json",
    "https://elements.nexus.availproject.org/r/card.json",
    "https://elements.nexus.availproject.org/r/dialog.json",
    "https://elements.nexus.availproject.org/r/input.json",
    "https://elements.nexus.availproject.org/r/label.json",
    "https://elements.nexus.availproject.org/r/select.json",
    "https://elements.nexus.availproject.org/r/tabs.json",
    "https://elements.nexus.availproject.org/r/nexus-provider.json",
    "https://elements.nexus.availproject.org/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/nexus-elements/swaps/swap-widget.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useRef } from \"react\";\nimport { ArrowDownUp, Loader2 } from \"lucide-react\";\nimport { useNexus } from \"../nexus/NexusProvider\";\nimport useExactIn, { SwapInputs } from \"./hooks/useExactIn\";\nimport { Button } from \"../ui/button\";\nimport { Separator } from \"../ui/separator\";\nimport useHover from \"./hooks/useHover\";\nimport SourceContainer from \"./components/source-container\";\nimport DestinationContainer from \"./components/destination-container\";\nimport ViewTransaction from \"./components/view-transaction\";\n\nfunction SwapWidget() {\n  const sourceContainer = useRef<HTMLDivElement | null>(null);\n  const destinationContainer = useRef<HTMLDivElement | null>(null);\n  const { nexusSDK, swapIntent, swapBalance, fetchSwapBalance, getFiatValue } =\n    useNexus();\n  const {\n    status,\n    inputs,\n    txError,\n    setInputs,\n    setStatus,\n    setTxError,\n    steps,\n    reset,\n    explorerUrls,\n    availableBalance,\n    availableStables,\n    formatBalance,\n    destinationBalance,\n  } = useExactIn({\n    nexusSDK,\n    swapIntent,\n    swapBalance,\n    fetchBalance: fetchSwapBalance,\n    // onComplete,\n    // onStart,\n    // onError,\n    // prefill,\n  });\n  const sourceHovered = useHover(sourceContainer);\n  const destinationHovered = useHover(destinationContainer);\n\n  const handleInputSwitch = useCallback(() => {\n    swapIntent.current?.deny();\n    swapIntent.current = null;\n    if (!inputs?.fromToken || !inputs?.toToken) {\n      const switched: SwapInputs = {\n        fromChainID: inputs.toChainID,\n        toChainID: inputs.fromChainID,\n        fromToken: undefined,\n        toToken: undefined,\n      };\n      setInputs({ ...inputs, ...switched });\n      return;\n    }\n    const isValidSource = swapBalance?.find(\n      (bal) => bal.symbol === inputs.toToken?.symbol,\n    );\n    if (!isValidSource) {\n      const switched: SwapInputs = {\n        fromChainID: inputs.toChainID,\n        toToken: {\n          tokenAddress: inputs.fromToken?.contractAddress,\n          decimals: inputs.fromToken?.decimals,\n          symbol: inputs.fromToken?.symbol,\n          name: inputs.fromToken?.name,\n          logo: inputs.fromToken?.logo,\n        },\n        fromToken: undefined,\n        toChainID: inputs.fromChainID,\n      };\n      setInputs({ ...inputs, ...switched });\n      return;\n    }\n    const switched: SwapInputs = {\n      fromToken: {\n        contractAddress: inputs.toToken?.tokenAddress,\n        decimals: inputs.toToken?.decimals,\n        symbol: inputs.toToken?.symbol,\n        name: inputs.toToken?.name,\n        logo: inputs.toToken?.logo,\n      },\n      fromChainID: inputs.toChainID,\n      toToken: {\n        tokenAddress: inputs.fromToken?.contractAddress,\n        decimals: inputs.fromToken?.decimals,\n        symbol: inputs.fromToken?.symbol,\n        name: inputs.fromToken?.name,\n        logo: inputs.fromToken?.logo,\n      },\n      toChainID: inputs.fromChainID,\n    };\n    setInputs({ ...inputs, ...switched });\n  }, [inputs, swapIntent, swapBalance]);\n\n  return (\n    <>\n      <div className=\"w-full max-w-md bg-background/40 rounded-2xl px-2.5 py-2 sm:p-6 border border-border\">\n        <div className=\"flex flex-col items-center w-full relative\">\n          <div\n            ref={sourceContainer}\n            className=\"flex flex-col gap-y-3 w-full rounded-2xl\"\n          >\n            <SourceContainer\n              status={status}\n              sourceHovered={sourceHovered}\n              inputs={inputs}\n              availableBalance={availableBalance}\n              swapBalance={swapBalance}\n              setInputs={setInputs}\n              setTxError={setTxError}\n              getFiatValue={getFiatValue}\n              formatBalance={formatBalance}\n            />\n          </div>\n\n          {/* Swap arrow / mode toggle */}\n          <Button\n            variant={\"secondary\"}\n            size={\"icon-lg\"}\n            onClick={handleInputSwitch}\n            title=\"Toggle between exact in and exact out\"\n            className=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10\"\n            disabled={status === \"simulating\" || status === \"swapping\"}\n          >\n            {status === \"simulating\" ? (\n              <Loader2 className=\"animate-spin size5\" />\n            ) : (\n              <ArrowDownUp className=\"size-5\" />\n            )}\n          </Button>\n          <Separator />\n\n          {/* Buy section */}\n          <div\n            className=\"flex flex-col gap-y-3 w-full rounded-2xl\"\n            ref={destinationContainer}\n          >\n            <DestinationContainer\n              destinationHovered={destinationHovered}\n              inputs={inputs}\n              setInputs={setInputs}\n              swapIntent={swapIntent}\n              destinationBalance={destinationBalance}\n              swapBalance={swapBalance}\n              availableStables={availableStables}\n              getFiatValue={getFiatValue}\n              formatBalance={formatBalance}\n            />\n          </div>\n        </div>\n        {status === \"error\" && (\n          <p className=\"text-destructive text-sm\">{txError}</p>\n        )}\n      </div>\n\n      {status !== \"idle\" && (\n        <ViewTransaction\n          txError={txError}\n          explorerUrls={explorerUrls}\n          steps={steps}\n          status={status}\n          swapIntent={swapIntent}\n          getFiatValue={getFiatValue}\n          nexusSDK={nexusSDK}\n          setStatus={setStatus}\n          reset={reset}\n        />\n      )}\n    </>\n  );\n}\n\nexport default SwapWidget;\n",
      "type": "registry:component",
      "target": "components/swaps/swap-widget.tsx"
    },
    {
      "path": "registry/nexus-elements/common/index.ts",
      "content": "export * from \"./hooks/useStopwatch\";\nexport * from \"./hooks/usePolling\";\nexport * from \"./hooks/useInterval\";\nexport * from \"./hooks/useStableCallback\";\nexport * from \"./hooks/useDebouncedValue\";\nexport * from \"./hooks/useDebouncedCallback\";\nexport * from \"./hooks/useNexusError\";\nexport * from \"./tx/types\";\nexport * from \"./tx/steps\";\nexport * from \"./tx/useTransactionSteps\";\nexport * from \"./utils/constant\";\n",
      "type": "registry:component",
      "target": "components/common/index.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/constant.ts",
      "content": "import { formatUnits, parseUnits } from \"viem\";\n\nexport const SHORT_CHAIN_NAME: Record<number, string> = {\n  1: \"Ethereum\",\n  8453: \"Base\",\n  42161: \"Arbitrum\",\n  10: \"Optimism\",\n  137: \"Polygon\",\n  43114: \"Avalanche\",\n  534352: \"Scroll\",\n  50104: \"Sophon\",\n  8217: \"Kaia\",\n  56: \"BNB\",\n  143: \"Monad\",\n  999: \"HyperEVM\",\n  728126428: \"Tron\",\n  11155111: \"Sepolia\",\n  84532: \"Base Sepolia\",\n  421614: \"Arbitrum Sepolia\",\n  11155420: \"Optimism Sepolia\",\n  80002: \"Polygon Amoy\",\n  10143: \"Monad Testnet\",\n  2494104990: \"Tron Shasta\",\n  567: \"Validium Testnet\",\n} as const;\n\nconst DEFAULT_SAFETY_MARGIN = 0.01; // 1%\n\n/**\n * Compute an amount string for fraction buttons (25%, 50%, 75%, 100%).\n *\n * @param balanceStr - user's balance as a human decimal string (e.g. \"12.345\") OR as base-unit integer string if `balanceIsBaseUnits` true\n * @param fraction - fraction e.g. 0.25, 0.5, 0.75, 1\n * @param decimals - token decimals (6 for USDC/USDT, 18 for ETH)\n * @param safetyMargin - 0.01 for 1% default\n * @param balanceIsBaseUnits - if true, balanceStr is already base units integer string (wei / smallest unit)\n * @returns decimal string clipped to token decimals (rounded down)\n */\nexport function computeAmountFromFraction(\n  balanceStr: string,\n  fraction: number,\n  decimals: number,\n  safetyMargin = DEFAULT_SAFETY_MARGIN,\n  balanceIsBaseUnits = false,\n): string {\n  if (!balanceStr) return \"0\";\n\n  // parse balance into base units (BigInt)\n  const balanceUnits: bigint = balanceIsBaseUnits\n    ? BigInt(balanceStr)\n    : parseUnits(balanceStr, decimals);\n\n  if (balanceUnits === BigInt(0)) return \"0\";\n\n  // Use an integer precision multiplier to avoid FP issues\n  const PREC = 1_000_000; // 1e6 precision for fraction & safety margin\n  const safetyMul = BigInt(Math.max(0, Math.floor((1 - safetyMargin) * PREC))); // (1 - safetyMargin) * PREC\n  const fractionMul = BigInt(Math.max(0, Math.floor(fraction * PREC))); // fraction * PREC\n\n  // Apply safety margin: floor(balance * (1 - safetyMargin))\n  const maxAfterSafety = (balanceUnits * safetyMul) / BigInt(PREC);\n\n  // Apply fraction and floor: floor(maxAfterSafety * fraction)\n  let desiredUnits = (maxAfterSafety * fractionMul) / BigInt(PREC);\n\n  // Extra clamp just in case\n  if (desiredUnits > balanceUnits) desiredUnits = balanceUnits;\n  if (desiredUnits < BigInt(0)) desiredUnits = BigInt(0);\n\n  // format back to human readable decimal string with token decimals (formatUnits truncates/keeps decimals)\n  // formatUnits will produce exactly decimals digits if fractional part exists; we'll strip trailing zeros.\n  const raw = formatUnits(desiredUnits, decimals);\n  // strip trailing zeros and possible trailing dot\n  return raw\n    .replace(/(\\.\\d*?[1-9])0+$/u, \"$1\")\n    .replace(/\\.0+$/u, \"\")\n    .replace(/^\\.$/u, \"0\");\n}\n\nexport const usdFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n",
      "type": "registry:component",
      "target": "components/common/utils/constant.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStableCallback.ts",
      "content": "import { useCallback, useRef } from \"react\";\n\n/**\n * Returns a stable function identity that always calls the latest implementation.\n * Useful when passing callbacks to memoized children without re-creating handlers.\n */\nexport function useStableCallback<Args extends readonly unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const fnRef = useRef<(...args: Args) => Return>(fn);\n  fnRef.current = fn;\n\n   \n  const stable = useCallback(\n    ((...args: Args) => {\n      return fnRef.current(...args);\n    }) as (...args: Args) => Return,\n    []\n  );\n\n  return stable;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStableCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useNexusError.ts",
      "content": "import { NexusError } from \"@avail-project/nexus-core\";\n\nfunction handler(err: unknown) {\n  if (err instanceof NexusError) {\n    return {\n      code: err?.code,\n      message: err?.message,\n      context: err?.data?.context,\n      details: err?.data?.details,\n    };\n  } else {\n    console.error(\"Unexpected error:\", err);\n    return {\n      code: \"unexpected_error\",\n      message: \"Oops! Something went wrong. Please try again.\",\n      context: undefined,\n      details: undefined,\n    };\n  }\n}\nexport function useNexusError() {\n  return handler;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useNexusError.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useInterval.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ninterface UseIntervalOptions {\n  enabled?: boolean;\n  immediate?: boolean;\n}\n\n/**\n * Declarative setInterval with pause/resume and latest-callback semantics.\n * Pass delay=null to pause.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options: UseIntervalOptions = {}\n) {\n  const { enabled = true, immediate = false } = options;\n  const savedCallback = useStableCallback(callback);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (!enabled || delay == null) return;\n    if (immediate) {\n      savedCallback();\n    }\n    intervalRef.current = setInterval(savedCallback, delay);\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [delay, enabled, immediate, savedCallback]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useInterval.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStopwatch.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\ninterface UseStopwatchOptions {\n  running?: boolean;\n  intervalMs?: number;\n}\n\n/**\n * Simple stopwatch that increments elapsed seconds while running.\n * Designed to replace scattered timer effects.\n */\nexport function useStopwatch(options: UseStopwatchOptions = {}) {\n  const { running = false, intervalMs = 100 } = options;\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const reset = () => {\n    setElapsedSeconds(0);\n  };\n\n  const stop = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const start = () => {\n    if (timerRef.current) return;\n    timerRef.current = setInterval(() => {\n      // 1s == 1000ms; we add fractional seconds per tick\n      setElapsedSeconds((prev) => prev + intervalMs / 1000);\n    }, intervalMs);\n  };\n\n  useEffect(() => {\n    if (running) {\n      start();\n    } else {\n      stop();\n    }\n    return stop;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [running, intervalMs]);\n\n  return {\n    seconds: elapsedSeconds,\n    start,\n    stop,\n    reset,\n    running: Boolean(timerRef.current),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStopwatch.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/usePolling.ts",
      "content": "import { useRef } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { useStableCallback } from \"./useStableCallback\";\n\n/**\n * Declarative polling with in-flight protection (no overlap).\n * When enabled becomes true, an immediate run is executed,\n * followed by interval-based runs.\n */\nexport function usePolling(\n  enabled: boolean,\n  fn: () => Promise<void> | void,\n  intervalMs: number\n) {\n  const inFlightRef = useRef(false);\n  const wrapped = useStableCallback(async () => {\n    if (inFlightRef.current) return;\n    try {\n      inFlightRef.current = true;\n      await fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      inFlightRef.current = false;\n    }\n  });\n\n  useInterval(wrapped, enabled ? intervalMs : null, {\n    enabled,\n    immediate: enabled,\n  });\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/usePolling.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedCallback.ts",
      "content": "import { useEffect, useMemo, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype AnyFn = (...args: any[]) => any;\n\nexport interface Debounced<T extends AnyFn> {\n  (...args: Parameters<T>): void;\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Returns a debounced function that delays invoking `fn` until after `delay`\n * milliseconds have elapsed since the last call.\n */\nexport function useDebouncedCallback<T extends AnyFn>(\n  fn: T,\n  delay: number\n): Debounced<T> {\n  const latest = useStableCallback(fn);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  const cancel = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const flush = () => {\n    if (timerRef.current && lastArgsRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n       \n      latest(...lastArgsRef.current);\n      lastArgsRef.current = null;\n    }\n  };\n\n  // cancel when delay changes/unmounts\n  useEffect(() => cancel, [delay]);\n\n  return useMemo(() => {\n    const debounced = ((...args: Parameters<T>) => {\n      lastArgsRef.current = args;\n      cancel();\n      timerRef.current = setTimeout(() => {\n         \n        latest(...lastArgsRef.current!);\n        lastArgsRef.current = null;\n        timerRef.current = null;\n      }, delay);\n    }) as Debounced<T>;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, latest]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedValue.ts",
      "content": "import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\n\n/**\n * Derives a debounced value from an input value and delay.\n */\nexport function useDebouncedValue<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState<T>(value);\n  const setter = useDebouncedCallback((v: T) => setDebounced(v), delay);\n\n  useEffect(() => {\n    setter(value);\n    return setter.cancel;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, delay]);\n\n  return debounced;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedValue.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/types.ts",
      "content": "export type TransactionStatus =\n  | \"idle\"\n  | \"preview\"\n  | \"awaiting-approval\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\nexport type GenericStep<TStep> = {\n  id: number;\n  completed: boolean;\n  step: TStep;\n};\n\n/**\n * Normalizes a step to a stable key. Prefers typeID, then type, otherwise JSON.\n */\nexport function getStepKey(step: any): string {\n  if (!step) return \"\";\n  if (typeof step.typeID === \"string\" && step.typeID.length > 0) {\n    return step.typeID;\n  }\n  if (typeof step.type === \"string\" && step.type.length > 0) {\n    return step.type;\n  }\n  try {\n    return JSON.stringify(step);\n  } catch {\n    return String(step);\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/types.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/steps.ts",
      "content": "import type { SwapStepType } from \"@avail-project/nexus-core\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\n\n/**\n * Predefined expected steps for swaps to seed UI before events arrive.\n * Kept here to avoid duplication across exact-in and exact-out hooks.\n */\nexport const SWAP_EXPECTED_STEPS: SwapStepType[] = [\n  { type: \"SWAP_START\", typeID: \"SWAP_START\" } as SwapStepType,\n  { type: \"DETERMINING_SWAP\", typeID: \"DETERMINING_SWAP\" } as SwapStepType,\n  {\n    type: \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    typeID:\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_BATCH_TX\",\n    typeID: \"SOURCE_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_HASH\",\n    typeID: \"SOURCE_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"RFF_ID\", typeID: \"RFF_ID\" } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_BATCH_TX\",\n    typeID: \"DESTINATION_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_HASH\",\n    typeID: \"DESTINATION_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"SWAP_COMPLETE\", typeID: \"SWAP_COMPLETE\" } as SwapStepType,\n];\n\nexport function seedSteps<T>(expected: T[]): Array<GenericStep<T>> {\n  return expected.map((st, index) => ({\n    id: index,\n    completed: false,\n    step: st,\n  }));\n}\n\nexport function computeAllCompleted<T>(steps: Array<GenericStep<T>>): boolean {\n  return steps.length > 0 && steps.every((s) => s.completed);\n}\n\n/**\n * Replace the current list of steps with a new list, preserving completion\n * for any steps that were already marked completed (matched by key).\n */\nexport function mergeStepsList<T>(\n  prev: Array<GenericStep<T>>,\n  list: T[]\n): Array<GenericStep<T>> {\n  const completedKeys = new Set<string>();\n  for (const prevStep of prev) {\n    if (prevStep.completed) {\n      completedKeys.add(getStepKey(prevStep.step));\n    }\n  }\n  const next: Array<GenericStep<T>> = [];\n  for (let index = 0; index < list.length; index++) {\n    const step = list[index];\n    const key = getStepKey(step);\n    next.push({\n      id: index,\n      completed: completedKeys.has(key),\n      step,\n    });\n  }\n  return next;\n}\n\n/**\n * Mark a step complete in-place; if the step doesn't yet exist, append it.\n */\nexport function mergeStepComplete<T>(\n  prev: Array<GenericStep<T>>,\n  step: T\n): Array<GenericStep<T>> {\n  const key = getStepKey(step);\n  const updated: Array<GenericStep<T>> = [];\n  let found = false;\n  for (const s of prev) {\n    if (getStepKey(s.step) === key) {\n      updated.push({ ...s, completed: true, step: { ...s.step, ...step } });\n      found = true;\n    } else {\n      updated.push(s);\n    }\n  }\n  if (!found) {\n    updated.push({\n      id: updated.length,\n      completed: true,\n      step,\n    });\n  }\n  return updated;\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/steps.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/useTransactionSteps.ts",
      "content": "import { useMemo, useRef, useState } from \"react\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\nimport {\n  computeAllCompleted,\n  mergeStepComplete,\n  mergeStepsList,\n  seedSteps,\n} from \"./steps\";\n\ninterface UseTransactionStepsOptions<T> {\n  expected?: T[];\n}\n\n/**\n * Manages transaction steps with utilities to seed from expected steps,\n * replace the list on \"steps list\" events, and mark individual steps complete.\n */\nexport function useTransactionSteps<\n  T extends { typeID?: string; type?: string }\n>(options: UseTransactionStepsOptions<T> = {}) {\n  const { expected } = options;\n  const [steps, setSteps] = useState<Array<GenericStep<T>>>(() =>\n    expected ? seedSteps(expected) : []\n  );\n  const lastSignatureRef = useRef<string>(\"\");\n\n  const onStepsList = (list: T[]) => {\n    const signature = list.map((step) => getStepKey(step)).join(\"|\");\n    if (lastSignatureRef.current === signature) {\n      setSteps((prev) => mergeStepsList(prev, list));\n      return;\n    }\n    lastSignatureRef.current = signature;\n    setSteps((prev) => mergeStepsList(prev, list));\n  };\n\n  const onStepComplete = (step: T) => {\n    setSteps((prev) => mergeStepComplete(prev, step));\n  };\n\n  const seed = (expectedSteps: T[]) => {\n    setSteps(seedSteps(expectedSteps));\n  };\n\n  const reset = () => {\n    setSteps(expected ? seedSteps(expected) : []);\n    lastSignatureRef.current = \"\";\n  };\n\n  const allCompleted = useMemo(() => computeAllCompleted(steps), [steps]);\n\n  return {\n    steps,\n    allCompleted,\n    onStepsList,\n    onStepComplete,\n    seed,\n    reset,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/useTransactionSteps.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-out/exact-out.tsx",
      "content": "// import { type FC } from \"react\";\n// import { Card, CardContent } from \"../../ui/card\";\n// import AmountInput from \"../components/amount-input\";\n// import DestinationAssetSelect from \"../components/destination-asset-select\";\n// import { Button } from \"../../ui/button\";\n// import { LoaderPinwheel } from \"lucide-react\";\n// import { Label } from \"../../ui/label\";\n// import { Input } from \"../../ui/input\";\n// import {\n//   Dialog,\n//   DialogContent,\n//   DialogHeader,\n//   DialogTitle,\n// } from \"../../ui/dialog\";\n// import TransactionProgress from \"../components/transaction-progress\";\n// import { useNexus } from \"../../nexus/NexusProvider\";\n// import useExactOut from \"./hooks/useExactOut\";\n\n// interface SwapExactOutProps {\n//   onComplete?: (amount?: string) => void;\n//   onStart?: () => void;\n//   onError?: (message: string) => void;\n//   prefill?: {\n//     toChainID?: number;\n//     toToken?: string;\n//     toAmount?: string;\n//   };\n// }\n\n// const SwapExactOut: FC<SwapExactOutProps> = ({\n//   onComplete,\n//   onStart,\n//   onError,\n//   prefill,\n// }) => {\n//   const { nexusSDK, swapIntent, swapBalance, fetchSwapBalance } = useNexus();\n//   const {\n//     inputs,\n//     setInputs,\n//     loading,\n//     isDialogOpen,\n//     setIsDialogOpen,\n//     txError,\n//     timer,\n//     steps,\n//     sourceExplorerUrl,\n//     destinationExplorerUrl,\n//     handleSwap,\n//     reset,\n//   } = useExactOut({\n//     nexusSDK,\n//     swapIntent,\n//     swapBalance,\n//     fetchBalance: fetchSwapBalance,\n//     onComplete,\n//     onStart,\n//     onError,\n//     prefill,\n//   });\n//   return (\n//     <Card className=\"w-full max-w-xl\">\n//       <CardContent className=\"flex flex-col gap-y-4 w-full\">\n//         <div className=\"flex items-center justify-between\">\n//           <p className=\"text-base font-semibold\">Swap</p>\n//           <span className=\"text-xs text-muted-foreground\">Exact Out</span>\n//         </div>\n//         <div className=\"flex flex-col gap-y-2\">\n//           <label className=\"text-sm font-medium\" htmlFor=\"swap-amount\">\n//             Amount\n//           </label>\n//           <AmountInput\n//             amount={inputs.toAmount}\n//             onChange={(val) => setInputs({ ...inputs, toAmount: val })}\n//             symbol={inputs.toToken?.symbol}\n//             disabled={Boolean(prefill?.toAmount)}\n//             hideBalance={true}\n//           />\n//         </div>\n\n//         <DestinationAssetSelect\n//           selectedChain={inputs.toChainID}\n//           selectedToken={inputs.toToken}\n//           onSelect={(toChainID, toToken) =>\n//             setInputs({ ...inputs, toChainID, toToken })\n//           }\n//           disabled={Boolean(prefill?.toChainID && prefill?.toToken)}\n//         />\n\n//         {!swapIntent.current && (\n//           <Button onClick={handleSwap} disabled={loading}>\n//             {loading ? (\n//               <LoaderPinwheel className=\"animate-spin size-5\" />\n//             ) : (\n//               \"Swap\"\n//             )}\n//           </Button>\n//         )}\n\n//         {swapIntent.current && (\n//           <>\n//             <div className=\"flex flex-col gap-y-2\">\n//               <Label className=\"text-sm font-medium\" htmlFor=\"swap-receive\">\n//                 You receive (estimated)\n//               </Label>\n//               <Input\n//                 id=\"swap-receive\"\n//                 disabled\n//                 className=\"w-full border rounded px-3 py-2 text-sm bg-muted cursor-not-allowed\"\n//                 value={`${\n//                   swapIntent.current?.intent?.destination?.amount ?? \"\"\n//                 }`}\n//                 placeholder=\"â€”\"\n//                 readOnly\n//               />\n//             </div>\n//             {!isDialogOpen && (\n//               <div className=\"w-full flex items-center gap-x-2 justify-between\">\n//                 <Button\n//                   variant={\"destructive\"}\n//                   onClick={() => {\n//                     swapIntent.current?.deny();\n//                     swapIntent.current = null;\n//                     reset();\n//                   }}\n//                   className=\"w-1/2\"\n//                 >\n//                   Deny\n//                 </Button>\n//                 <Button\n//                   onClick={() => {\n//                     swapIntent.current?.allow();\n//                     setIsDialogOpen(true);\n//                   }}\n//                   className=\"w-1/2\"\n//                 >\n//                   Accept\n//                 </Button>\n//               </div>\n//             )}\n//           </>\n//         )}\n\n//         <Dialog\n//           open={isDialogOpen}\n//           onOpenChange={(o) => {\n//             if (loading) return;\n//             if (!o) reset();\n//             setIsDialogOpen(o);\n//           }}\n//         >\n//           <DialogContent>\n//             <DialogHeader className=\"sr-only\">\n//               <DialogTitle>Swap Progress</DialogTitle>\n//             </DialogHeader>\n//             <TransactionProgress\n//               timer={timer}\n//               steps={steps}\n//               sourceExplorerUrl={sourceExplorerUrl}\n//               destinationExplorerUrl={destinationExplorerUrl}\n//             />\n//           </DialogContent>\n//         </Dialog>\n\n//         {txError && (\n//           <div className=\"rounded-md border border-destructive bg-destructive/80 px-3 py-2 text-sm text-destructive-foreground flex items-start justify-between gap-x-3 mt-3 w-full max-w-lg\">\n//             <span className=\"flex-1 max-w-md truncate\">{txError}</span>\n//             <Button\n//               type=\"button\"\n//               size={\"icon\"}\n//               variant={\"ghost\"}\n//               onClick={() => {\n//                 reset();\n//               }}\n//               className=\"text-destructive-foreground/80 hover:text-destructive-foreground focus:outline-none\"\n//               aria-label=\"Dismiss error\"\n//             >\n//               X\n//             </Button>\n//           </div>\n//         )}\n//       </CardContent>\n//     </Card>\n//   );\n// };\n\n// export default SwapExactOut;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-out/exact-out.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/source-asset-select.tsx",
      "content": "\"use client\";\nimport { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport {\n  type UserAsset,\n  type SUPPORTED_CHAINS_IDS,\n  CHAIN_METADATA,\n} from \"@avail-project/nexus-core\";\nimport { TOKEN_IMAGES } from \"../config/destination\";\nimport { Link2, Loader2, Search } from \"lucide-react\";\nimport { DialogClose } from \"../../ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n} from \"../../ui/select\";\nimport { TokenIcon } from \"./token-icon\";\nimport { SHORT_CHAIN_NAME, usdFormatter } from \"../../common\";\nimport { type SourceTokenInfo } from \"../hooks/useExactIn\";\n\ninterface SourceAssetSelectProps {\n  onSelect: (chainId: SUPPORTED_CHAINS_IDS, token: SourceTokenInfo) => void;\n  disabled?: boolean;\n  swapBalance: UserAsset[] | null;\n}\n\nconst SourceAssetSelect: FC<SourceAssetSelectProps> = ({\n  onSelect,\n  swapBalance,\n}) => {\n  const { swapSupportedChainsAndTokens, nexusSDK } = useNexus();\n  const [tempChain, setTempChain] = useState<{\n    id: number;\n    logo: string;\n    name: string;\n  } | null>(null);\n\n  // Get all tokens from swapBalance with their chain info\n  const allTokens: SourceTokenInfo[] = useMemo(() => {\n    if (!swapBalance) return [];\n    const tokens: SourceTokenInfo[] = [];\n\n    for (const asset of swapBalance) {\n      if (!asset?.breakdown?.length) continue;\n      for (const breakdown of asset.breakdown) {\n        if (Number.parseFloat(breakdown.balance) <= 0) continue;\n\n        tokens.push({\n          contractAddress: breakdown.contractAddress,\n          decimals: breakdown.decimals ?? asset.decimals,\n          logo: TOKEN_IMAGES[asset.symbol] ?? \"\",\n          name: asset.symbol,\n          symbol: asset.symbol,\n          balance: nexusSDK?.utils?.formatTokenBalance(breakdown?.balance, {\n            symbol: asset.symbol,\n            decimals: asset.decimals,\n          }),\n          balanceInFiat: `$${breakdown.balanceInFiat}`,\n          chainId: breakdown.chain?.id,\n        });\n      }\n    }\n\n    // Dedupe by contractAddress + chainId\n    const unique = new Map<string, SourceTokenInfo>();\n    for (const t of tokens) {\n      const key = `${t.contractAddress.toLowerCase()}-${t.chainId}`;\n      unique.set(key, t);\n    }\n    return Array.from(unique.values());\n  }, [swapBalance, nexusSDK]);\n\n  // Only show chains that have tokens with balance\n  const chainsWithTokens = useMemo(() => {\n    if (!swapSupportedChainsAndTokens || !allTokens.length) return [];\n    const chainIdsWithTokens = new Set(allTokens.map((t) => t.chainId));\n    return swapSupportedChainsAndTokens.filter((c) =>\n      chainIdsWithTokens.has(c.id),\n    );\n  }, [swapSupportedChainsAndTokens, allTokens]);\n\n  // Filter tokens by selected chain, or show all if no chain selected\n  const displayedTokens: SourceTokenInfo[] = useMemo(() => {\n    if (!tempChain) return allTokens;\n    return allTokens.filter((t) => t.chainId === tempChain.id);\n  }, [tempChain, allTokens]);\n\n  const handlePick = (tok: SourceTokenInfo) => {\n    const chainId = tempChain?.id ?? tok.chainId;\n    if (!chainId) return;\n    onSelect(chainId as SUPPORTED_CHAINS_IDS, tok);\n  };\n\n  if (!swapBalance)\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-y-3\">\n        <p className=\"text-sm text-muted-foreground\">\n          Fetching swappable assets\n        </p>\n        <Loader2 className=\"animate-spin size-5\" />\n      </div>\n    );\n\n  return (\n    <div className=\"w-full flex flex-col gap-y-3\">\n      <Select\n        value={tempChain?.name}\n        onValueChange={(value) => {\n          const matchedChain = chainsWithTokens.find(\n            (chain) => chain.name === value,\n          );\n          if (matchedChain) {\n            setTempChain(matchedChain);\n          }\n        }}\n      >\n        <div className=\"flex bg-input/30 w-full px-2 py-1.5\">\n          <div className=\"flex items-center gap-x-2 w-full justify-between\">\n            <Search className=\"size-5 opacity-65\" />\n            <input\n              placeholder=\"Search\"\n              className=\"bg-transparent w-full text-foreground text-base font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-80\"\n            />\n          </div>\n          <SelectTrigger className=\"rounded-full border-none cursor-pointer bg-transparent!\">\n            {tempChain ? (\n              <img\n                src={tempChain?.logo}\n                alt={tempChain?.name}\n                width={24}\n                height={24}\n                className=\"rounded-full size-6\"\n              />\n            ) : (\n              <div className=\"size-8 rounded-full flex items-center justify-center border border-border\">\n                <Link2 className=\"size-4\" />\n              </div>\n            )}\n          </SelectTrigger>\n        </div>\n        <SelectContent>\n          <SelectGroup>\n            {chainsWithTokens.map((c) => (\n              <SelectItem key={c.id} value={c.name}>\n                <div className=\"flex items-center justify-between gap-x-2\">\n                  <img\n                    src={c.logo}\n                    alt={c.name}\n                    width={20}\n                    height={20}\n                    className=\"rounded-full size-5\"\n                  />\n                  <span className=\"text-sm\">{c.name}</span>\n                </div>\n              </SelectItem>\n            ))}\n          </SelectGroup>\n        </SelectContent>\n      </Select>\n      <p className=\"text-sm\">\n        {tempChain?.id\n          ? `Tokens on ${SHORT_CHAIN_NAME[tempChain.id]}`\n          : \"All Tokens\"}\n      </p>\n      <div className=\"rounded-md max-h-80 overflow-y-auto no-scrollbar\">\n        <div className=\"flex flex-col items-center sm:items-start gap-y-4 w-full no-scrollbar\">\n          {displayedTokens.length > 0 ? (\n            displayedTokens.map((t) => (\n              <DialogClose asChild key={`${t.contractAddress}-${t.chainId}`}>\n                <Button\n                  variant={\"ghost\"}\n                  onClick={() => handlePick(t)}\n                  className=\"flex items-center justify-between gap-x-2 p-2 rounded w-full h-max\"\n                >\n                  <div className=\"flex  items-center gap-x-4\">\n                    {t.symbol ? (\n                      <div className=\"relative\">\n                        <TokenIcon\n                          symbol={t.symbol}\n                          tokenLogo={t.logo}\n                          chainLogo={CHAIN_METADATA[t.chainId ?? 1]?.logo}\n                          className=\"border border-border rounded-full\"\n                        />\n                      </div>\n                    ) : null}\n                  </div>\n                  <div className=\"flex flex-col items-end\">\n                    <p className=\"text-base text-foreground\">{t.balance}</p>\n                    <p className=\"text-sm text-muted-foreground\">\n                      {t.balanceInFiat}\n                    </p>\n                  </div>\n                </Button>\n              </DialogClose>\n            ))\n          ) : (\n            <p className=\"text-xs text-muted-foreground\">No Tokens Found</p>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SourceAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/source-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/destination-asset-select.tsx",
      "content": "\"use client\";\nimport { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport {\n  type SUPPORTED_CHAINS_IDS,\n  CHAIN_METADATA,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { DESTINATION_SWAP_TOKENS } from \"../config/destination\";\nimport { DialogClose } from \"../../ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n} from \"../../ui/select\";\nimport { Link2, Search } from \"lucide-react\";\nimport { SHORT_CHAIN_NAME, usdFormatter } from \"../../common\";\nimport { TokenIcon } from \"./token-icon\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { type DestinationTokenInfo } from \"../hooks/useExactIn\";\n\ninterface DestinationAssetSelectProps {\n  swapBalance: UserAsset[] | null;\n  onSelect: (\n    chainId: SUPPORTED_CHAINS_IDS,\n    token: DestinationTokenInfo,\n  ) => void;\n}\n\nconst DestinationAssetSelect: FC<DestinationAssetSelectProps> = ({\n  swapBalance,\n  onSelect,\n}) => {\n  const { nexusSDK } = useNexus();\n  const [tempChain, setTempChain] = useState<number | null>(null);\n\n  // Get all tokens from all chains with their chain info\n  const allTokens: DestinationTokenInfo[] = useMemo(() => {\n    const tokens: DestinationTokenInfo[] = [];\n    for (const [chainId, chainTokens] of DESTINATION_SWAP_TOKENS.entries()) {\n      for (const token of chainTokens) {\n        tokens.push({\n          ...token,\n          chainId,\n        });\n      }\n    }\n    return tokens.map((token) => {\n      const balance = swapBalance\n        ?.find((t) => t.symbol === token.symbol)\n        ?.breakdown?.find((chain) => chain.chain?.id === token.chainId);\n      return {\n        ...token,\n        balance: nexusSDK?.utils?.formatTokenBalance(balance?.balance ?? \"0\", {\n          symbol: token.symbol,\n          decimals: balance?.decimals ?? 0,\n        }),\n        balanceInFiat: usdFormatter.format(balance?.balanceInFiat ?? 0),\n      };\n    });\n  }, [swapBalance]);\n\n  // Only show chains that have tokens\n  const chainsWithTokens = useMemo(() => {\n    return Array.from(DESTINATION_SWAP_TOKENS.keys());\n  }, []);\n\n  // Filter tokens by selected chain, or show all if no chain selected\n  const displayedTokens: DestinationTokenInfo[] = useMemo(() => {\n    if (!tempChain) return allTokens;\n    return allTokens.filter((t) => t.chainId === tempChain);\n  }, [tempChain, allTokens]);\n\n  const handlePick = (tok: DestinationTokenInfo) => {\n    const chainId = tempChain ?? tok.chainId;\n    if (!chainId) return;\n    onSelect(chainId as SUPPORTED_CHAINS_IDS, tok);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"w-full flex flex-col gap-y-3\">\n        <Select\n          value={tempChain ? CHAIN_METADATA[tempChain].name : \"\"}\n          onValueChange={(value) => {\n            const matchedChain = chainsWithTokens.find(\n              (chain) => String(chain) === value,\n            );\n            if (matchedChain) {\n              setTempChain(matchedChain);\n            }\n          }}\n        >\n          <div className=\"flex bg-input/30 w-full px-2\">\n            <div className=\"flex items-center gap-x-2 w-full justify-between\">\n              <Search className=\"size-5 opacity-65\" />\n              <input\n                placeholder=\"Search\"\n                className=\"bg-transparent w-full text-foreground text-base font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-80\"\n              />\n            </div>\n            <SelectTrigger className=\"rounded-full border-none cursor-pointer bg-transparent!\">\n              {tempChain ? (\n                <img\n                  src={CHAIN_METADATA[tempChain].logo}\n                  alt={CHAIN_METADATA[tempChain].name}\n                  width={24}\n                  height={24}\n                  className=\"rounded-full size-6\"\n                />\n              ) : (\n                <div className=\"size-8 rounded-full flex items-center justify-center border border-border\">\n                  <Link2 className=\"size-4\" />\n                </div>\n              )}\n            </SelectTrigger>\n          </div>\n          <SelectContent>\n            <SelectGroup>\n              {chainsWithTokens.map((c) => (\n                <SelectItem key={c} value={String(c)}>\n                  <div className=\"flex items-center justify-between gap-x-2\">\n                    <img\n                      src={CHAIN_METADATA[c].logo}\n                      alt={CHAIN_METADATA[c].name}\n                      width={20}\n                      height={20}\n                      className=\"rounded-full size-5\"\n                    />\n                    <span className=\"text-sm\">{CHAIN_METADATA[c].name}</span>\n                  </div>\n                </SelectItem>\n              ))}\n            </SelectGroup>\n          </SelectContent>\n        </Select>\n        <p className=\"text-sm\">\n          {tempChain\n            ? `Tokens on ${SHORT_CHAIN_NAME[tempChain]}`\n            : \"All Tokens\"}\n        </p>\n        <div className=\"rounded-md px-2 max-h-80 overflow-y-auto no-scrollbar\">\n          <div className=\"flex flex-col items-center sm:items-start gap-y-4 w-full no-scrollbar\">\n            {displayedTokens.length > 0 ? (\n              displayedTokens.map((t) => (\n                <DialogClose asChild key={`${t.tokenAddress}-${t.chainId}`}>\n                  <Button\n                    variant={\"ghost\"}\n                    onClick={() => handlePick(t)}\n                    className=\"flex items-center justify-between gap-x-2 p-2 rounded w-full h-max\"\n                  >\n                    <div className=\"flex items-center gap-x-2\">\n                      {t.symbol ? (\n                        <div className=\"relative\">\n                          <TokenIcon\n                            symbol={t.symbol}\n                            tokenLogo={t.logo}\n                            chainLogo={CHAIN_METADATA[t.chainId ?? 1]?.logo}\n                            className=\"border border-border rounded-full\"\n                          />\n                        </div>\n                      ) : null}\n                    </div>\n                    <div className=\"flex flex-col items-end\">\n                      <p className=\"text-base text-foreground\">{t.balance}</p>\n                      <p className=\"text-sm text-muted-foreground\">\n                        {t.balanceInFiat}\n                      </p>\n                    </div>\n                  </Button>\n                </DialogClose>\n              ))\n            ) : (\n              <p className=\"text-xs text-muted-foreground\">No Tokens Found</p>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default DestinationAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/destination-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/source-container.tsx",
      "content": "import React from \"react\";\nimport { Label } from \"../../ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"../../ui/button\";\nimport { TransactionStatus, type SwapInputs } from \"../hooks/useExactIn\";\nimport { computeAmountFromFraction, usdFormatter } from \"../../common\";\nimport { CHAIN_METADATA, type UserAsset } from \"@avail-project/nexus-core\";\nimport AmountInput from \"./amount-input\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { TokenIcon } from \"./token-icon\";\nimport { ChevronDown } from \"lucide-react\";\nimport SourceAssetSelect from \"./source-asset-select\";\n\nconst RANGE_OPTIONS = [\n  {\n    label: \"25%\",\n    value: 0.25,\n  },\n  {\n    label: \"50%\",\n    value: 0.5,\n  },\n  {\n    label: \"75%\",\n    value: 0.75,\n  },\n  {\n    label: \"MAX\",\n    value: 1,\n  },\n];\n\nconst SAFETY_MARGIN = 0.05;\n\ninterface SourceContainerProps {\n  status: TransactionStatus;\n  sourceHovered: boolean;\n  inputs: SwapInputs;\n  availableBalance?: UserAsset[\"breakdown\"][0];\n  swapBalance: UserAsset[] | null;\n  setInputs: (inputs: Partial<SwapInputs>) => void;\n  setTxError: (error: string | null) => void;\n  getFiatValue: (amount: number, token: string) => number;\n  formatBalance: (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number,\n  ) => string | undefined;\n}\n\nconst SourceContainer: React.FC<SourceContainerProps> = ({\n  status,\n  sourceHovered,\n  inputs,\n  availableBalance,\n  swapBalance,\n  setInputs,\n  setTxError,\n  getFiatValue,\n  formatBalance,\n}) => {\n  return (\n    <div className=\"bg-background rounded-xl flex flex-col items-center w-full gap-y-4\">\n      <div className=\"w-full flex items-center justify-between\">\n        <Label className=\"text-lg font-medium text-foreground\">Sell</Label>\n        <div\n          className={cn(\n            \"flex transition-all duration-150 ease-out w-full justify-end gap-x-2\",\n            sourceHovered\n              ? \"opacity-100 translate-y-0\"\n              : \"opacity-0 -translate-y-1\",\n          )}\n        >\n          {RANGE_OPTIONS.map((option) => (\n            <Button\n              key={option.label}\n              size={\"icon-sm\"}\n              variant={\"secondary\"}\n              disabled={!inputs.fromChainID || !inputs.fromToken}\n              onClick={() => {\n                if (!inputs.fromToken) return 0;\n                const amount = computeAmountFromFraction(\n                  availableBalance?.balance ?? \"0\",\n                  option.value,\n                  inputs?.fromToken?.decimals,\n                  SAFETY_MARGIN,\n                );\n                setInputs({ ...inputs, fromAmount: amount });\n              }}\n              className=\"px-5 py-1.5 rounded-full hover:-translate-y-1 hover:object-scale-down\"\n            >\n              <p className=\"text-xs font-medium\">{option.label}</p>\n            </Button>\n          ))}\n        </div>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        <AmountInput\n          amount={inputs?.fromAmount ?? \"\"}\n          onChange={(val) => {\n            if (availableBalance?.balance) {\n              const parsedAvailableBalance = Number.parseFloat(\n                availableBalance?.balance,\n              );\n              const parsedVal = Number.parseFloat(val);\n              if (parsedVal > parsedAvailableBalance) {\n                setTxError(\"Insufficient Balance\");\n                return;\n              }\n            }\n            setInputs({ ...inputs, fromAmount: val });\n          }}\n          disabled={status === \"simulating\"}\n        />\n\n        <Dialog>\n          <DialogTrigger asChild>\n            <div className=\"flex items-center gap-x-3 bg-card/50 hover:bg-card-foreground/10 border border-border min-w-max rounded-full p-1 cursor-pointer  transition-colors\">\n              <TokenIcon\n                symbol={inputs?.fromToken?.symbol}\n                tokenLogo={inputs?.fromToken?.logo}\n                chainLogo={\n                  inputs?.fromChainID\n                    ? CHAIN_METADATA[inputs?.fromChainID]?.logo\n                    : undefined\n                }\n                size=\"lg\"\n              />\n              <span className=\"font-medium\">{inputs?.fromToken?.symbol}</span>\n              <ChevronDown size={16} className=\"mr-1\" />\n            </div>\n          </DialogTrigger>\n          <DialogContent className=\"max-w-md!\">\n            <DialogHeader>\n              <DialogTitle>Select a Token</DialogTitle>\n            </DialogHeader>\n            <SourceAssetSelect\n              onSelect={(fromChainID, fromToken) =>\n                setInputs({ ...inputs, fromChainID, fromToken })\n              }\n              swapBalance={swapBalance}\n            />\n          </DialogContent>\n        </Dialog>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        {inputs.fromAmount && inputs?.fromToken ? (\n          <span className=\"text-sm text-accent-foreground\">\n            {usdFormatter.format(\n              getFiatValue(\n                Number.parseFloat(inputs.fromAmount),\n                inputs.fromToken?.logo,\n              ),\n            )}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n\n        <span className=\"text-sm text-muted-foreground\">\n          {formatBalance(\n            availableBalance?.balance ?? \"0\",\n            inputs?.fromToken?.symbol,\n            availableBalance?.decimals,\n          )}\n        </span>\n      </div>\n    </div>\n  );\n};\n\nexport default SourceContainer;\n",
      "type": "registry:component",
      "target": "components/swaps/components/source-container.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/destination-container.tsx",
      "content": "import React, { type RefObject } from \"react\";\nimport { Label } from \"../../ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  CHAIN_METADATA,\n  type OnSwapIntentHookData,\n  type SUPPORTED_CHAINS_IDS,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { type SwapInputs } from \"../hooks/useExactIn\";\nimport { Button } from \"../../ui/button\";\nimport { TokenIcon } from \"./token-icon\";\nimport AmountInput from \"./amount-input\";\nimport { usdFormatter } from \"../../common\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { ChevronDown } from \"lucide-react\";\nimport DestinationAssetSelect from \"./destination-asset-select\";\n\ninterface DestinationContainerProps {\n  destinationHovered: boolean;\n  inputs: SwapInputs;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  destinationBalance?: UserAsset[\"breakdown\"][0];\n  swapBalance: UserAsset[] | null;\n  availableStables: UserAsset[];\n  setInputs: (inputs: Partial<SwapInputs>) => void;\n  getFiatValue: (amount: number, token: string) => number;\n  formatBalance: (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number,\n  ) => string | undefined;\n}\n\nconst DestinationContainer: React.FC<DestinationContainerProps> = ({\n  destinationHovered,\n  inputs,\n  swapIntent,\n  destinationBalance,\n  swapBalance,\n  availableStables,\n  setInputs,\n  getFiatValue,\n  formatBalance,\n}) => {\n  return (\n    <div className=\"bg-background rounded-xl flex flex-col items-center w-full gap-y-4\">\n      <div className=\"w-full flex items-center justify-between\">\n        <Label className=\"text-lg font-medium text-foreground\">Buy</Label>\n        {(!inputs?.toToken || !inputs?.toChainID) && (\n          <div\n            className={cn(\n              \"flex transition-all duration-150 ease-out w-full justify-end gap-x-2\",\n              destinationHovered\n                ? \"opacity-100 translate-y-0\"\n                : \"opacity-0 -translate-y-1\",\n            )}\n          >\n            {availableStables.map((token) => (\n              <Button\n                key={token?.symbol}\n                size={\"icon-sm\"}\n                variant={\"secondary\"}\n                onClick={() => {\n                  if (!token) return;\n                  setInputs({\n                    ...inputs,\n                    toToken: {\n                      tokenAddress: token.breakdown[0].contractAddress,\n                      decimals: token.decimals,\n                      logo: token.icon ?? \"\",\n                      name: token.symbol,\n                      symbol: token.symbol,\n                    },\n                    toChainID: token.breakdown[0].chain\n                      .id as SUPPORTED_CHAINS_IDS,\n                  });\n                }}\n                className=\"bg-transparent rounded-full hover:-translate-y-1 hover:object-scale-down\"\n              >\n                <TokenIcon\n                  symbol={token?.symbol}\n                  tokenLogo={token?.icon}\n                  chainLogo={token.breakdown[0].chain.logo}\n                  size=\"sm\"\n                />\n              </Button>\n            ))}\n          </div>\n        )}\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        <AmountInput\n          amount={\n            formatBalance(\n              swapIntent?.current?.intent.destination.amount,\n              swapIntent.current?.intent.destination.token.symbol,\n              swapIntent.current?.intent.destination.token.decimals,\n            ) ?? \"0\"\n          }\n          disabled={true}\n        />\n        <Dialog>\n          <DialogTrigger asChild>\n            <div className=\"flex items-center gap-x-3 bg-card/50 hover:bg-card-foreground/10 border border-border min-w-max rounded-full p-1 cursor-pointer transition-colors\">\n              <TokenIcon\n                symbol={inputs?.toToken?.symbol}\n                tokenLogo={inputs?.toToken?.logo}\n                chainLogo={\n                  inputs?.toChainID\n                    ? CHAIN_METADATA[inputs?.toChainID]?.logo\n                    : undefined\n                }\n                size=\"lg\"\n              />\n              <span className=\"font-medium\">{inputs?.toToken?.symbol}</span>\n              <ChevronDown size={16} className=\"mr- ref={isSourceHovered}1\" />\n            </div>\n          </DialogTrigger>\n          <DialogContent className=\"max-w-md!\">\n            <DialogHeader>\n              <DialogTitle>Select Destination</DialogTitle>\n            </DialogHeader>\n            <DestinationAssetSelect\n              swapBalance={swapBalance}\n              onSelect={(toChainID, toToken) =>\n                setInputs({ ...inputs, toChainID, toToken })\n              }\n            />\n          </DialogContent>\n        </Dialog>\n      </div>\n      <div className=\"flex items-center justify-between gap-x-4 w-full\">\n        {swapIntent?.current?.intent?.destination?.amount && inputs?.toToken ? (\n          <span className=\"text-sm text-accent-foreground\">\n            {usdFormatter.format(\n              getFiatValue(\n                Number.parseFloat(\n                  swapIntent?.current?.intent?.destination?.amount,\n                ),\n                inputs.toToken?.logo,\n              ),\n            )}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n        {inputs?.toToken ? (\n          <span className=\"text-sm text-muted-foreground\">\n            {formatBalance(\n              destinationBalance?.balance,\n              inputs?.toToken?.symbol,\n              destinationBalance?.decimals,\n            ) ?? \"\"}\n          </span>\n        ) : (\n          <span className=\"h-5\" />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default DestinationContainer;\n",
      "type": "registry:component",
      "target": "components/swaps/components/destination-container.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/amount-input.tsx",
      "content": "import { type FC, useEffect, useRef } from \"react\";\n\ninterface AmountInputProps {\n  amount?: string;\n  onChange?: (value: string) => void;\n  disabled?: boolean;\n}\n\nconst AmountInput: FC<AmountInputProps> = ({\n  amount,\n  onChange,\n  disabled,\n}) => {\n  const commitTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const mirrorRef = useRef<HTMLDivElement>(null);\n\n  return (\n    <div className=\"relative flex items-start gap-2 text-4xl font-medium transition-all duration-150 ease-out w-full\">\n      <div\n        ref={mirrorRef}\n        className=\"absolute invisible pointer-events-none text-4xl font-medium whitespace-pre\"\n        style={{\n          fontVariantNumeric: \"proportional-nums\",\n        }}\n      >\n        {amount || \"0\"}\n      </div>\n\n      <input\n        ref={inputRef}\n        type=\"text\"\n        inputMode=\"decimal\"\n        placeholder=\"0\"\n        value={amount}\n        onChange={(e) => {\n          onChange?.(e.target.value);\n        }}\n        maxLength={18}\n        autoFocus\n        className=\"bg-transparent w-full text-foreground text-4xl font-medium outline-none transition-all duration-150 placeholder-muted-foreground proportional-nums disabled:opacity-50\"\n        disabled={disabled}\n      />\n      <div className=\"absolute -inset-1 -z-10 blur-sm pointer-events-none opacity-0\" />\n    </div>\n  );\n};\n\nexport default AmountInput;\n",
      "type": "registry:component",
      "target": "components/swaps/components/amount-input.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/step-flow.tsx",
      "content": "import { FC, Fragment, memo } from \"react\";\nimport { TokenIcon } from \"./token-icon\";\nimport { cn } from \"@/lib/utils\";\nimport { Atom, CircleCheck, SquareArrowOutUpRight } from \"lucide-react\";\nimport { DisplayStep } from \"./transaction-progress\";\n\ninterface StepFlowProps {\n  steps: DisplayStep[];\n  currentIndex: number;\n  totalSteps: number;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  sourceSymbol: string;\n  destinationSymbol: string;\n  sourceLogos: {\n    token: string;\n    chain: string;\n  };\n  destinationLogos: {\n    token: string;\n    chain: string;\n  };\n  allCompleted: boolean;\n}\n\nexport const StepFlow: FC<StepFlowProps> = memo(\n  ({\n    steps,\n    currentIndex,\n    totalSteps,\n    sourceSymbol,\n    destinationSymbol,\n    sourceLogos,\n    destinationLogos,\n    explorerUrls,\n    allCompleted,\n  }) => {\n    return (\n      <>\n        {steps.map((step, index) => {\n          const isCompleted = !!step.completed;\n          const isCurrent =\n            currentIndex === -1 ? false : index === currentIndex;\n          const isLast = index === steps.length - 1;\n          const url = isLast\n            ? explorerUrls.destinationExplorerUrl\n            : index === steps.length - 2\n              ? explorerUrls.sourceExplorerUrl\n              : null;\n\n          return (\n            <Fragment key={step.id}>\n              <StepItem\n                step={step}\n                isCompleted={isCompleted}\n                isCurrent={isCurrent}\n                index={index}\n                symbol={isLast ? destinationSymbol : sourceSymbol}\n                logos={isLast ? destinationLogos : sourceLogos}\n                totalSteps={totalSteps}\n                explorerUrl={url}\n                allCompleted={allCompleted}\n              />\n\n              {!isLast && (\n                <div className=\"flex w-max ml-[11px]\">\n                  <div\n                    className={cn(\n                      \"w-0.5 h-5 transition-all duration-500 border border-dashed border-border\",\n                      isCurrent && \"border-chart-1\",\n                    )}\n                  />\n                </div>\n              )}\n            </Fragment>\n          );\n        })}\n      </>\n    );\n  },\n);\n\nStepFlow.displayName = \"StepFlow\";\n\ninterface StepItemProps {\n  step: DisplayStep;\n  symbol: string;\n  logos: {\n    token: string;\n    chain: string;\n  };\n  explorerUrl: string | null;\n  isCompleted: boolean;\n  isCurrent: boolean;\n  totalSteps: number;\n  index: number;\n  allCompleted: boolean;\n}\n\nconst StepItem: FC<StepItemProps> = memo(\n  ({\n    step,\n    isCompleted,\n    isCurrent,\n    logos,\n    symbol,\n    totalSteps,\n    index,\n    explorerUrl,\n    allCompleted,\n  }) => {\n    const isSecondLast = index === totalSteps - 2;\n    return (\n      <div\n        className={cn(\n          \"flex gap-x-4 items-center rounded-lg transition-all duration-150 ease-out w-full\",\n          isCurrent && \"opacity-80\",\n          isCompleted && \"bg-transparent opacity-50\",\n          allCompleted ? \"opacity-100\" : \"opacity-50\",\n        )}\n      >\n        {/* Left Token Image */}\n        {isCurrent ? (\n          <div className=\" rounded-full relative\">\n            <div\n              className={cn(\n                \"rounded-full size-6 flex items-center justify-center transition-all duration-500\",\n                isCurrent\n                  ? \"ring-2 ring-ring ring-offset-4 ring-offset-black\"\n                  : \"\",\n              )}\n            >\n              {isSecondLast ? (\n                <Atom className={cn(\"size-4  animate-pulse \")} />\n              ) : (\n                <TokenIcon\n                  size=\"sm\"\n                  symbol={symbol}\n                  chainLogo={logos.chain}\n                  tokenLogo={logos.token}\n                  className={cn(\n                    \"w-full h-full object-cover\",\n                    isCurrent && \"animate-pulse\",\n                  )}\n                />\n              )}\n            </div>\n          </div>\n        ) : (\n          <div className=\"size-6 flex items-center justify-center rounded-full\">\n            <span className={cn(\"size-2 rounded-full bg-ring/80\")} />\n          </div>\n        )}\n\n        {/* Content */}\n        <div className=\"flex w-full items-center justify-between\">\n          <div className=\"flex flex-col items-start gap-y-1\">\n            <h3\n              className={cn(\n                \"font-semibold transition-colors duration-500\",\n                isCompleted || isCurrent\n                  ? \"text-foreground\"\n                  : \"text-muted-foreground\",\n              )}\n            >\n              {step.label}\n            </h3>\n            {explorerUrl &&\n              isCompleted &&\n              (isSecondLast || index === totalSteps - 1) && (\n                <a\n                  href={explorerUrl}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                  className=\"text-xs text-muted-foreground inline-flex items-center gap-x-1\"\n                >\n                  <SquareArrowOutUpRight className=\"size-3\" /> View Transaction\n                </a>\n              )}\n          </div>\n\n          {/* Right Actions */}\n          {isCurrent && (\n            <div className=\"flex items-center justify-center gap-2\">\n              <p className=\"text-xs text-muted-foreground\">\n                Step {index + 1} of {totalSteps}\n              </p>\n            </div>\n          )}\n          {isCompleted && (\n            <div className=\"flex items-center justify-center gap-2\">\n              <CircleCheck className=\"size-5 text-chart-1\" />\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  },\n);\n\nStepItem.displayName = \"StepItem\";\n",
      "type": "registry:component",
      "target": "components/swaps/components/step-flow.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/view-transaction.tsx",
      "content": "import React, { FC, type RefObject, useState } from \"react\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n} from \"../../ui/dialog\";\nimport {\n  NexusSDK,\n  type SwapStepType,\n  type OnSwapIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport { MoveDown, XIcon } from \"lucide-react\";\nimport { TokenIcon } from \"./token-icon\";\nimport { type GenericStep, usdFormatter } from \"../../common\";\nimport { TOKEN_IMAGES } from \"../config/destination\";\nimport { Button } from \"../../ui/button\";\nimport { type TransactionStatus } from \"../hooks/useExactIn\";\nimport TransactionProgress from \"./transaction-progress\";\nimport { Separator } from \"../../ui/separator\";\n\ninterface ViewTransactionProps {\n  steps: GenericStep<SwapStepType>[];\n  status: TransactionStatus;\n  nexusSDK: NexusSDK | null;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  getFiatValue: (amount: number, token: string) => number;\n  setStatus: (status: TransactionStatus) => void;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  reset: () => void;\n  txError: string | null;\n}\n\ninterface TokenBreakdownProps\n  extends Omit<\n    ViewTransactionProps,\n    | \"swapIntent\"\n    | \"setStatus\"\n    | \"status\"\n    | \"explorerUrls\"\n    | \"steps\"\n    | \"reset\"\n    | \"txError\"\n  > {\n  tokenLogo: string;\n  chainLogo: string;\n  symbol: string;\n  amount: number;\n  decimals: number;\n}\n\nconst TokenBreakdown = ({\n  nexusSDK,\n  getFiatValue,\n  tokenLogo,\n  chainLogo,\n  symbol,\n  amount,\n  decimals,\n}: TokenBreakdownProps) => {\n  return (\n    <div className=\"flex items-center w-full justify-between\">\n      <div className=\"flex flex-col items-start gap-y-1\">\n        <p className=\"text-xl font-medium \">\n          {nexusSDK?.utils.formatTokenBalance(amount, {\n            symbol: symbol,\n            decimals: decimals,\n          })}\n        </p>\n        <p className=\"text-base text-muted-foreground font-medium \">\n          {usdFormatter.format(getFiatValue(amount, symbol))}\n        </p>\n      </div>\n      <TokenIcon\n        symbol={symbol}\n        chainLogo={chainLogo}\n        tokenLogo={tokenLogo}\n        size=\"lg\"\n      />\n    </div>\n  );\n};\n\nconst ViewTransaction: FC<ViewTransactionProps> = ({\n  steps,\n  status,\n  nexusSDK,\n  swapIntent,\n  getFiatValue,\n  setStatus,\n  explorerUrls,\n  reset,\n  txError,\n}) => {\n  if (!swapIntent.current?.intent) return null;\n\n  const transactionIntent = swapIntent.current.intent;\n  console.log(\"tra  \", transactionIntent);\n  return (\n    <Dialog\n      defaultOpen={true}\n      onOpenChange={(open) => {\n        if (!open) {\n          console.log(\"RESET\", open);\n          reset();\n        }\n      }}\n    >\n      <DialogContent className=\"max-w-md!\" showCloseButton={false}>\n        <DialogHeader className=\"flex-row items-center justify-between w-full\">\n          <p className=\"text-sm font-medium text-muted-foreground\">\n            You're Swapping\n          </p>\n          <DialogClose>\n            <XIcon className=\"size-5 text-muted-foreground\" />\n          </DialogClose>\n        </DialogHeader>\n        <div className=\"flex flex-col items-start w-full gap-y-4\">\n          <TokenBreakdown\n            nexusSDK={nexusSDK}\n            getFiatValue={getFiatValue}\n            tokenLogo={TOKEN_IMAGES[transactionIntent.sources[0].token.symbol]}\n            chainLogo={transactionIntent.sources[0].chain.logo}\n            symbol={transactionIntent.sources[0].token.symbol}\n            amount={Number.parseFloat(transactionIntent.sources[0].amount)}\n            decimals={transactionIntent.sources[0].token.decimals}\n          />\n          <MoveDown className=\"size-5 -ml-1.5 text-muted-foreground\" />\n          <TokenBreakdown\n            nexusSDK={nexusSDK}\n            getFiatValue={getFiatValue}\n            tokenLogo={TOKEN_IMAGES[transactionIntent.destination.token.symbol]}\n            chainLogo={transactionIntent.destination.chain.logo}\n            symbol={transactionIntent.destination.token.symbol}\n            amount={Number.parseFloat(transactionIntent.destination.amount)}\n            decimals={transactionIntent.destination.token.decimals}\n          />\n        </div>\n        {status === \"error\" && (\n          <p className=\"text-destructive text-sm\">{txError}</p>\n        )}\n        {status === \"simulating\" && (\n          <Button\n            onClick={() => {\n              setStatus(\"swapping\");\n              swapIntent.current?.allow();\n            }}\n          >\n            Continue\n          </Button>\n        )}\n\n        {(status === \"swapping\" || status === \"success\") && (\n          <>\n            <Separator className=\"transition-opacity\" />\n            <TransactionProgress\n              steps={steps}\n              explorerUrls={explorerUrls}\n              sourceSymbol={transactionIntent.sources[0].token.symbol}\n              destinationSymbol={transactionIntent.destination.token.symbol}\n              sourceLogos={{\n                token: TOKEN_IMAGES[transactionIntent.sources[0].token.symbol],\n                chain: transactionIntent.sources[0].chain.logo,\n              }}\n              destinationLogos={{\n                token: TOKEN_IMAGES[transactionIntent.destination.token.symbol],\n                chain: transactionIntent.destination.chain.logo,\n              }}\n            />\n          </>\n        )}\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default ViewTransaction;\n",
      "type": "registry:component",
      "target": "components/swaps/components/view-transaction.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/hooks/useExactIn.ts",
      "content": "import {\n  type RefObject,\n  useEffect,\n  useMemo,\n  useReducer,\n  useState,\n} from \"react\";\nimport {\n  NexusSDK,\n  type SUPPORTED_CHAINS_IDS,\n  type ExactInSwapInput,\n  NEXUS_EVENTS,\n  type SwapStepType,\n  type OnSwapIntentHookData,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport {\n  resolveDestinationFromPrefill,\n  resolveSourceFromPrefill,\n} from \"../utils/prefill\";\nimport {\n  useTransactionSteps,\n  SWAP_EXPECTED_STEPS,\n  useNexusError,\n  useDebouncedCallback,\n  usePolling,\n} from \"../../common\";\n\nexport type SourceTokenInfo = {\n  contractAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n  balance?: string;\n  balanceInFiat?: string;\n  chainId?: number;\n};\n\nexport type DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n  chainId?: number;\n  balance?: string;\n  balanceInFiat?: string;\n};\n\nexport type TransactionStatus =\n  | \"idle\"\n  | \"simulating\"\n  | \"swapping\"\n  | \"success\"\n  | \"error\";\n\nexport interface SwapInputs {\n  fromChainID?: SUPPORTED_CHAINS_IDS;\n  fromToken?: SourceTokenInfo;\n  fromAmount?: string;\n  toChainID?: SUPPORTED_CHAINS_IDS;\n  toToken?: DestinationTokenInfo;\n}\n\nexport type SwapState = {\n  inputs: SwapInputs;\n  status: TransactionStatus;\n  error: string | null;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n};\n\ntype Action =\n  | { type: \"setInputs\"; payload: Partial<SwapInputs> }\n  | { type: \"setStatus\"; payload: TransactionStatus }\n  | { type: \"setError\"; payload: string | null }\n  | {\n      type: \"setExplorerUrls\";\n      payload: Partial<SwapState[\"explorerUrls\"]>;\n    }\n  | { type: \"reset\" };\n\nconst initialState: SwapState = {\n  inputs: {\n    fromToken: undefined,\n    toToken: undefined,\n    fromAmount: undefined,\n    fromChainID: undefined,\n    toChainID: undefined,\n  },\n  status: \"idle\",\n  error: null,\n  explorerUrls: {\n    sourceExplorerUrl: null,\n    destinationExplorerUrl: null,\n  },\n};\n\nfunction reducer(state: SwapState, action: Action): SwapState {\n  switch (action.type) {\n    case \"setInputs\": {\n      return {\n        ...state,\n        inputs: {\n          ...state.inputs,\n          ...action.payload,\n        },\n      };\n    }\n    case \"setStatus\":\n      return { ...state, status: action.payload };\n    case \"setError\":\n      return { ...state, error: action.payload };\n    case \"setExplorerUrls\":\n      return {\n        ...state,\n        explorerUrls: { ...state.explorerUrls, ...action.payload },\n      };\n    case \"reset\":\n      return { ...initialState };\n    default:\n      return state;\n  }\n}\n\ninterface UseExactInProps {\n  nexusSDK: NexusSDK | null;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  swapBalance: UserAsset[] | null;\n  fetchBalance: () => Promise<void>;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    fromChainID?: number;\n    fromToken?: string;\n    fromAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst useExactIn = ({\n  nexusSDK,\n  swapIntent,\n  swapBalance,\n  fetchBalance,\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}: UseExactInProps) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const {\n    steps,\n    seed,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<SwapStepType>();\n\n  const areInputsValid = useMemo(() => {\n    return (\n      state?.inputs?.fromChainID !== undefined &&\n      state?.inputs?.toChainID !== undefined &&\n      state?.inputs?.fromToken &&\n      state?.inputs?.toToken &&\n      state?.inputs?.fromAmount &&\n      Number(state.inputs.fromAmount) > 0\n    );\n  }, [state.inputs]);\n  const handleNexusError = useNexusError();\n\n  const handleSwap = async () => {\n    if (\n      !nexusSDK ||\n      !areInputsValid ||\n      !state?.inputs?.fromToken ||\n      !state?.inputs?.toToken ||\n      !state?.inputs?.fromAmount ||\n      !state?.inputs?.toChainID ||\n      !state?.inputs?.fromChainID\n    )\n      return;\n    try {\n      onStart?.();\n      dispatch({ type: \"setStatus\", payload: \"simulating\" });\n      seed(SWAP_EXPECTED_STEPS);\n      const amountBigInt = nexusSDK.utils.parseUnits(\n        state.inputs?.fromAmount,\n        state.inputs.fromToken.decimals,\n      );\n      const swapInput: ExactInSwapInput = {\n        from: [\n          {\n            chainId: state.inputs?.fromChainID,\n            amount: amountBigInt,\n            tokenAddress: state.inputs.fromToken.contractAddress,\n          },\n        ],\n        toChainId: state.inputs?.toChainID,\n        toTokenAddress: state.inputs.toToken.tokenAddress,\n      };\n\n      const result = await nexusSDK.swapWithExactIn(swapInput, {\n        onEvent: (event) => {\n          if (event.name === NEXUS_EVENTS.SWAP_STEP_COMPLETE) {\n            const step = event.args;\n            console.log(\"STEP COMPLETED\", step);\n            if (step?.type === \"SOURCE_SWAP_HASH\" && step.explorerURL) {\n              dispatch({\n                type: \"setExplorerUrls\",\n                payload: { sourceExplorerUrl: step.explorerURL },\n              });\n            }\n            if (step?.type === \"DESTINATION_SWAP_HASH\" && step.explorerURL) {\n              dispatch({\n                type: \"setExplorerUrls\",\n                payload: { destinationExplorerUrl: step.explorerURL },\n              });\n            }\n            onStepComplete(step);\n          }\n        },\n      });\n      if (!result?.success) {\n        throw new Error(result?.error || \"Swap failed\");\n      }\n      dispatch({ type: \"setStatus\", payload: \"success\" });\n      onComplete?.(swapIntent.current?.intent?.destination?.amount);\n      await fetchBalance();\n      // dispatch({ type: \"setInputs\", payload: initialState.inputs });\n    } catch (error) {\n      const { message } = handleNexusError(error);\n      dispatch({ type: \"setStatus\", payload: \"error\" });\n      dispatch({ type: \"setError\", payload: message });\n      onError?.(message);\n      swapIntent.current = null;\n    }\n  };\n\n  const debouncedSwapStart = useDebouncedCallback(handleSwap, 1200);\n\n  const reset = () => {\n    dispatch({ type: \"reset\" });\n    resetSteps();\n    swapIntent.current = null;\n  };\n\n  const availableBalance = useMemo(() => {\n    if (\n      !nexusSDK ||\n      !swapBalance ||\n      !state.inputs?.fromToken ||\n      !state.inputs?.fromChainID\n    )\n      return undefined;\n    return (\n      swapBalance\n        ?.find((token) => token.symbol === state.inputs?.fromToken?.symbol)\n        ?.breakdown?.find(\n          (chain) => chain.chain?.id === state.inputs?.fromChainID,\n        ) ?? undefined\n    );\n  }, [\n    state.inputs?.fromToken,\n    state.inputs?.fromChainID,\n    swapBalance,\n    nexusSDK,\n  ]);\n\n  const destinationBalance = useMemo(() => {\n    if (\n      !nexusSDK ||\n      !swapBalance ||\n      !state.inputs?.toToken ||\n      !state.inputs?.toChainID\n    )\n      return undefined;\n    return (\n      swapBalance\n        ?.find((token) => token.symbol === state?.inputs?.toToken?.symbol)\n        ?.breakdown?.find(\n          (chain) => chain.chain?.id === state?.inputs?.toChainID,\n        ) ?? undefined\n    );\n  }, [state?.inputs?.toToken, state?.inputs?.toChainID, swapBalance, nexusSDK]);\n\n  const availableStables = useMemo(() => {\n    if (!nexusSDK || !swapBalance) return [];\n    const filteredToken = swapBalance?.filter((token) => {\n      if ([\"USDT\", \"USDC\", \"ETH\", \"DAI\", \"WBTC\"].includes(token.symbol)) {\n        return token;\n      }\n    });\n    return filteredToken ?? [];\n  }, [swapBalance, nexusSDK]);\n\n  const formatBalance = (\n    balance?: string | number,\n    symbol?: string,\n    decimals?: number,\n  ) => {\n    if (!balance || !symbol || !decimals) return undefined;\n    return nexusSDK?.utils?.formatTokenBalance(balance, {\n      symbol: symbol,\n      decimals: decimals,\n    });\n  };\n\n  useEffect(() => {\n    if (!swapBalance) {\n      fetchBalance();\n    }\n  }, [swapBalance]);\n\n  useEffect(() => {\n    if (\n      !areInputsValid ||\n      !state?.inputs?.fromAmount ||\n      !state?.inputs?.fromChainID ||\n      !state?.inputs?.fromToken ||\n      !state?.inputs?.toChainID ||\n      !state?.inputs?.toToken\n    ) {\n      swapIntent.current?.deny();\n      swapIntent.current = null;\n      return;\n    }\n    if (state.status === \"idle\") {\n      debouncedSwapStart();\n    }\n  }, [state.inputs, areInputsValid, state.status]);\n\n  useEffect(() => {\n    if (\n      prefill?.fromToken &&\n      prefill?.fromChainID &&\n      !state.inputs?.fromToken\n    ) {\n      const src = resolveSourceFromPrefill(\n        swapBalance,\n        state.inputs?.fromChainID,\n        prefill.fromToken,\n      );\n      if (src) {\n        dispatch({ type: \"setInputs\", payload: { fromToken: src } });\n      }\n    }\n    if (\n      prefill?.toToken &&\n      state.inputs?.toChainID !== undefined &&\n      !state.inputs?.toToken\n    ) {\n      const dst = resolveDestinationFromPrefill(\n        state.inputs?.toChainID,\n        prefill.toToken,\n      );\n      if (dst) {\n        dispatch({ type: \"setInputs\", payload: { toToken: dst } });\n      }\n    }\n  }, [\n    prefill,\n    swapBalance,\n    state.inputs?.fromChainID,\n    state.inputs?.toChainID,\n    state.inputs?.fromToken,\n    state.inputs?.toToken,\n  ]);\n\n  const refreshSimulation = async () => {\n    try {\n      const updated = await swapIntent.current?.refresh();\n      if (updated) {\n        swapIntent.current!.intent = updated;\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n\n  usePolling(\n    state.status === \"simulating\" && Boolean(swapIntent.current),\n    async () => {\n      await refreshSimulation();\n    },\n    15000,\n  );\n\n  return {\n    status: state.status,\n    inputs: state.inputs,\n    setStatus: (status: TransactionStatus) =>\n      dispatch({ type: \"setStatus\", payload: status }),\n    setInputs: (inputs: Partial<SwapInputs>) => {\n      if (state.status === \"error\") {\n        dispatch({ type: \"setError\", payload: null });\n        dispatch({ type: \"setStatus\", payload: \"idle\" });\n      }\n      dispatch({ type: \"setInputs\", payload: inputs });\n    },\n    txError: state.error,\n    setTxError: (error: string | null) =>\n      dispatch({ type: \"setError\", payload: error }),\n    availableBalance,\n    availableStables,\n    destinationBalance,\n    formatBalance,\n    steps,\n    explorerUrls: state.explorerUrls,\n    handleSwap,\n    reset,\n    areInputsValid,\n  };\n};\n\nexport default useExactIn;\n",
      "type": "registry:component",
      "target": "components/swaps/hooks/useExactIn.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/hooks/useHover.ts",
      "content": "import { useEffect, useRef } from \"react\";\n\nexport function useEventListener(\n  eventType: string,\n  callback: (event: Event) => void,\n  element: HTMLElement | Window | null,\n) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (element == null) return;\n    const handler = (e: Event) => callbackRef.current(e);\n    element.addEventListener(eventType, handler);\n\n    return () => element.removeEventListener(eventType, handler);\n  }, [eventType, element]);\n}\n\nimport { useState } from \"react\";\n\nexport default function useHover(ref: React.RefObject<HTMLElement | null>) {\n  const [hovered, setHovered] = useState(false);\n  useEventListener(\"mouseover\", () => setHovered(true), ref?.current);\n  useEventListener(\"mouseout\", () => setHovered(false), ref?.current);\n  return hovered;\n}\n",
      "type": "registry:component",
      "target": "components/swaps/hooks/useHover.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-out/hooks/useExactOut.ts",
      "content": "import { type RefObject, useEffect, useMemo, useState } from \"react\";\nimport {\n  NexusSDK,\n  SUPPORTED_CHAINS,\n  type SUPPORTED_CHAINS_IDS,\n  type ExactOutSwapInput,\n  NEXUS_EVENTS,\n  type SwapStepType,\n  type UserAsset,\n  type OnSwapIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\nimport { resolveDestinationFromPrefill } from \"../../utils/prefill\";\nimport {\n  useStopwatch,\n  useTransactionSteps,\n  SWAP_EXPECTED_STEPS,\n  useNexusError,\n} from \"../../../common\";\n\ntype DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n};\n\ninterface SwapInputs {\n  toAmount?: string;\n  toChainID: SUPPORTED_CHAINS_IDS;\n  toToken?: DestinationTokenInfo;\n}\n\ninterface UseExactOutProps {\n  nexusSDK: NexusSDK | null;\n  address?: Address;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  swapBalance: UserAsset[] | null;\n  fetchBalance: () => Promise<void>;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    toAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst useExactOut = ({\n  nexusSDK,\n  swapIntent,\n  swapBalance,\n  fetchBalance,\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}: UseExactOutProps) => {\n  const handleNexusError = useNexusError();\n\n  const [inputs, setInputs] = useState<SwapInputs>({\n    toChainID:\n      (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ?? SUPPORTED_CHAINS.OPTIMISM,\n    toAmount: prefill?.toAmount ?? undefined,\n  });\n  const [loading, setLoading] = useState(false);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [txError, setTxError] = useState<string | null>(null);\n  const [sourceExplorerUrl, setSourceExplorerUrl] = useState<string>(\"\");\n  const [destinationExplorerUrl, setDestinationExplorerUrl] =\n    useState<string>(\"\");\n  const {\n    steps,\n    seed,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<SwapStepType>();\n  const swapCompleted = useMemo(\n    () => steps.some((s) => s.step?.type === \"SWAP_COMPLETE\" && s.completed),\n    [steps]\n  );\n  const stopwatch = useStopwatch({\n    running: isDialogOpen && !swapCompleted,\n    intervalMs: 100,\n  });\n\n  const areInputsValid = useMemo(() => {\n    return (\n      inputs.toChainID !== undefined &&\n      inputs.toToken &&\n      inputs.toAmount &&\n      Number(inputs.toAmount) > 0\n    );\n  }, [inputs]);\n\n  const handleSwap = async () => {\n    if (!nexusSDK || !areInputsValid || !inputs.toToken || !inputs.toAmount)\n      return;\n    try {\n      onStart?.();\n      setLoading(true);\n      setTxError(null);\n      seed(SWAP_EXPECTED_STEPS);\n\n      const amountBigInt = nexusSDK.utils.parseUnits(\n        inputs.toAmount,\n        inputs.toToken.decimals\n      );\n      const swapInput: ExactOutSwapInput = {\n        toAmount: amountBigInt,\n        toChainId: inputs.toChainID,\n        toTokenAddress: inputs.toToken.tokenAddress,\n      };\n      const result = await nexusSDK.swapWithExactOut(swapInput, {\n        onEvent: (event) => {\n          if (event.name === NEXUS_EVENTS.SWAP_STEP_COMPLETE) {\n            const step = event.args as SwapStepType & {\n              explorerURL?: string;\n              completed?: boolean;\n            };\n            if (step?.type === \"SOURCE_SWAP_HASH\" && step.explorerURL) {\n              setSourceExplorerUrl(step.explorerURL);\n            }\n            if (step?.type === \"DESTINATION_SWAP_HASH\" && step.explorerURL) {\n              setDestinationExplorerUrl(step.explorerURL);\n            }\n            onStepComplete(step);\n          }\n        },\n      });\n      if (!result?.success) {\n        throw new Error(result?.error || \"Swap failed\");\n      }\n      onComplete?.(swapIntent.current?.intent?.destination?.amount);\n      swapIntent.current = null;\n\n      await fetchBalance();\n    } catch (error) {\n      const { message } = handleNexusError(error);\n      setTxError(message);\n      onError?.(message);\n      swapIntent.current = null;\n      setIsDialogOpen(false);\n    } finally {\n      setLoading(false);\n      stopwatch.stop();\n    }\n  };\n\n  const resetLocal = () => {\n    setInputs({\n      toChainID:\n        (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ??\n        SUPPORTED_CHAINS.OPTIMISM,\n      toAmount: prefill?.toAmount ?? undefined,\n      toToken: undefined,\n    });\n    setIsDialogOpen(false);\n    setTxError(null);\n    resetSteps();\n    swapIntent.current = null;\n    setSourceExplorerUrl(\"\");\n    setDestinationExplorerUrl(\"\");\n    setLoading(false);\n    stopwatch.stop();\n    stopwatch.reset();\n  };\n\n  useEffect(() => {\n    if (prefill?.toToken && inputs.toChainID !== undefined && !inputs.toToken) {\n      const tok = resolveDestinationFromPrefill(\n        inputs.toChainID,\n        prefill.toToken\n      );\n      if (tok) {\n        setInputs((prev) => ({\n          ...prev,\n          toToken: tok,\n        }));\n      }\n    }\n  }, [prefill, swapBalance, inputs.toChainID, inputs.toToken]);\n\n  useEffect(() => {\n    if (!swapIntent || isDialogOpen) return;\n    const id = setInterval(async () => {\n      try {\n        const updated = await swapIntent.current?.refresh();\n        if (updated) {\n          swapIntent.current!.intent = updated;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 15000);\n    return () => clearInterval(id);\n  }, [swapIntent.current, isDialogOpen]);\n\n  return {\n    inputs,\n    setInputs,\n    loading,\n    isDialogOpen,\n    setIsDialogOpen,\n    txError,\n    setTxError,\n    timer: stopwatch.seconds,\n    steps,\n    sourceExplorerUrl,\n    destinationExplorerUrl,\n    handleSwap,\n    reset: resetLocal,\n  };\n};\n\nexport default useExactOut;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-out/hooks/useExactOut.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/config/destination.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\n\nexport const DESTINATION_SWAP_TOKENS = new Map<\n  number,\n  {\n    decimals: number;\n    logo: string;\n    name: string;\n    symbol: string;\n    tokenAddress: `0x${string}`;\n  }[]\n>([\n  [\n    SUPPORTED_CHAINS.OPTIMISM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0x94b008aa00579c1307b0ef2c499ad98a8ce58e58\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n        name: \"Optimism\",\n        symbol: \"OP\",\n        tokenAddress: \"0x4200000000000000000000000000000000000042\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n        name: \"Aave Token\",\n        symbol: \"AAVE\",\n        tokenAddress: \"0x76fb31fb4af56892a25e32cfc43de717950c9278\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n        name: \"Uniswap\",\n        symbol: \"UNI\",\n        tokenAddress: \"0x6fd9d7ad17242c41f7131d257212c54a0e816691\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.ARBITRUM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n        name: \"Pepe\",\n        symbol: \"PEPE\",\n        tokenAddress: \"0x25d887ce7a35172c62febfd67a1856f20faebb00\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n        name: \"Lido DAO Token\",\n        symbol: \"LDO\",\n        tokenAddress: \"0x13ad51ed4f1b7e9dc168d8a00cb3f4ddd85efa60\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.SCROLL,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xf55bec9cafdbe8730f096aa55dad6d22d44099df\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BASE,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n        name: \"Dai Stablecoin\",\n        symbol: \"DAI\",\n        tokenAddress: \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n        name: \"LayerZero\",\n        symbol: \"ZRO\",\n        tokenAddress: \"0x6985884c4392d348587b19cb9eaaf157f13271cd\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n        name: \"MANTRA\",\n        symbol: \"OM\",\n        tokenAddress: \"0x3992b27da26848c2b19cea6fd25ad5568b68ab98\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n        name: \"KAITO\",\n        symbol: \"KAITO\",\n        tokenAddress: \"0x98d0baa52b2d063e780de12f615f963fe8537553\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BNB,\n    [\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n        name: \"BNB\",\n        symbol: \"BNB\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n    ],\n  ],\n]);\n\nexport const TOKEN_IMAGES: Record<string, string> = {\n  USDC: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png\",\n  USDT: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n  \"USDâ‚®0\":\n    \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n  WETH: \"https://assets.coingecko.com/coins/images/279/large/ethereum.png?1595348880\",\n  USDS: \"https://assets.coingecko.com/coins/images/39926/standard/usds.webp?1726666683\",\n  SOPH: \"https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png\",\n  KAIA: \"https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png\",\n  BNB: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n  // Add ETH as fallback for any ETH-related tokens\n  ETH: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n  // Add common token fallbacks\n  POL: \"https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png\",\n  AVAX: \"https://assets.coingecko.com/coins/images/12559/standard/Avalanche_Circle_RedWhite_Trans.png\",\n  FUEL: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png\",\n  HYPE: \"https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png\",\n  // Popular swap tokens\n  DAI: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n  UNI: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n  AAVE: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n  LDO: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n  PEPE: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n  OP: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n  ZRO: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n  OM: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n  KAITO:\n    \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n};\n",
      "type": "registry:component",
      "target": "components/swaps/config/destination.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/components/transaction-progress.tsx",
      "content": "import { type FC, useMemo } from \"react\";\nimport {\n  type BridgeStepType,\n  type SwapStepType,\n} from \"@avail-project/nexus-core\";\nimport { StepFlow } from \"./step-flow\";\n\nexport type DisplayStep = { id: string; label: string; completed: boolean };\ntype ProgressStep = BridgeStepType | SwapStepType;\n\ninterface TransactionProgressProps {\n  steps: Array<{ id: number; completed: boolean; step: ProgressStep }>;\n  explorerUrls: {\n    sourceExplorerUrl: string | null;\n    destinationExplorerUrl: string | null;\n  };\n  sourceSymbol: string;\n  destinationSymbol: string;\n  sourceLogos: {\n    token: string;\n    chain: string;\n  };\n  destinationLogos: {\n    token: string;\n    chain: string;\n  };\n}\n\nconst STEP_TYPES = {\n  INTENT_VERIFICATION: [\"CREATE_PERMIT_FOR_SOURCE_SWAP\"],\n  SOURCE_STEP_TYPES: [\n    \"CREATE_PERMIT_EOA_TO_EPHEMERAL\",\n    \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    \"SOURCE_SWAP_BATCH_TX\",\n    \"SOURCE_SWAP_HASH\",\n  ],\n  SOURCE_TRANSACTION: [\"SOURCE_SWAP_HASH\", \"SOURCE_SWAP_BATCH_TX\"],\n  DESTINATION_STEP_TYPES: [\n    \"DESTINATION_SWAP_BATCH_TX\",\n    \"DESTINATION_SWAP_HASH\",\n    \"SWAP_COMPLETE\",\n  ],\n  TRANSACTION_COMPLETE: [\"SWAP_COMPLETE\"],\n};\n\nconst TransactionProgress: FC<TransactionProgressProps> = ({\n  steps,\n  explorerUrls,\n  sourceSymbol,\n  destinationSymbol,\n  sourceLogos,\n  destinationLogos,\n}) => {\n  const { effectiveSteps, currentIndex, allCompleted } = useMemo(() => {\n    const completedTypes = new Set<string | undefined>(\n      steps?.filter((s) => s?.completed).map((s) => s?.step?.type),\n    );\n    // Consider only steps that were actually emitted by the SDK (ignore pre-seeded placeholders)\n    const eventfulTypes = new Set<string | undefined>(\n      steps\n        ?.filter((s) => {\n          const st = s?.step ?? {};\n          return (\n            \"explorerURL\" in st || \"chain\" in st || \"completed\" in st // present when event args were merged into step\n          );\n        })\n        .map((s) => s?.step?.type),\n    );\n    const hasAny = (types: string[]) =>\n      types.some((t) => completedTypes.has(t));\n    const sawAny = (types: string[]) => types.some((t) => eventfulTypes.has(t));\n\n    const intentVerified = hasAny([\"DETERMINING_SWAP\", \"SWAP_START\"]);\n\n    // If the flow does not include SOURCE_* steps, consider it implicitly collected\n\n    const collectedOnSources =\n      (sawAny(STEP_TYPES.SOURCE_STEP_TYPES) &&\n        hasAny(STEP_TYPES.SOURCE_TRANSACTION)) ||\n      (!sawAny(STEP_TYPES.SOURCE_STEP_TYPES) &&\n        hasAny(STEP_TYPES.DESTINATION_STEP_TYPES));\n\n    const filledOnDestination = hasAny(STEP_TYPES.DESTINATION_STEP_TYPES);\n\n    const displaySteps: DisplayStep[] = [\n      { id: \"intent\", label: \"Intent verified\", completed: intentVerified },\n      {\n        id: \"collected\",\n        label: \"Collected on sources\",\n        completed: collectedOnSources,\n      },\n      {\n        id: \"filled\",\n        label: \"Filled on destination\",\n        completed: filledOnDestination,\n      },\n    ];\n\n    // Mark overall completion ONLY when the SDK reports SWAP_COMPLETE\n    const done = hasAny(STEP_TYPES.TRANSACTION_COMPLETE);\n    const current = displaySteps.findIndex((st) => !st.completed);\n    return {\n      effectiveSteps: displaySteps,\n      currentIndex: current,\n      allCompleted: done,\n    };\n  }, [steps]);\n\n  return (\n    <div className=\"w-full flex flex-col items-start\">\n      <StepFlow\n        steps={effectiveSteps}\n        currentIndex={currentIndex}\n        totalSteps={effectiveSteps.length}\n        sourceLogos={sourceLogos}\n        sourceSymbol={sourceSymbol}\n        destinationLogos={destinationLogos}\n        destinationSymbol={destinationSymbol}\n        explorerUrls={explorerUrls}\n        allCompleted={allCompleted}\n      />\n    </div>\n  );\n};\n\nexport default TransactionProgress;\n",
      "type": "registry:component",
      "target": "components/swaps/components/transaction-progress.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/utils/prefill.ts",
      "content": "import type {\n  SUPPORTED_CHAINS_IDS,\n  UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { DESTINATION_SWAP_TOKENS, TOKEN_IMAGES } from \"../config/destination\";\n\nexport function resolveSourceFromPrefill(\n  unifiedBalance: UserAsset[] | null | undefined,\n  fromChainID: SUPPORTED_CHAINS_IDS | undefined,\n  prefillTokenAddress: string | undefined\n):\n  | {\n      contractAddress: `0x${string}`;\n      decimals: number;\n      logo: string;\n      name: string;\n      symbol: string;\n    }\n  | undefined {\n  if (!unifiedBalance || !fromChainID || !prefillTokenAddress) return undefined;\n  const targetAddr = prefillTokenAddress.toLowerCase();\n  for (const a of unifiedBalance) {\n    const candidate = a.breakdown?.find(\n      (b) =>\n        b.contractAddress?.toLowerCase() === targetAddr &&\n        (b.chain?.id as number | undefined) === fromChainID\n    ) as\n      | {\n          chain?: { id?: number };\n          contractAddress: `0x${string}`;\n          decimals?: number;\n        }\n      | undefined;\n    if (candidate) {\n      return {\n        contractAddress: candidate.contractAddress,\n        decimals: candidate.decimals ?? a.decimals,\n        logo: TOKEN_IMAGES[a.symbol] ?? \"\",\n        name: a.symbol,\n        symbol: a.symbol,\n      };\n    }\n  }\n  return undefined;\n}\n\nexport function resolveDestinationFromPrefill(\n  toChainID: SUPPORTED_CHAINS_IDS | undefined,\n  prefillTokenAddress: string | undefined\n):\n  | {\n      tokenAddress: `0x${string}`;\n      decimals: number;\n      logo: string;\n      name: string;\n      symbol: string;\n    }\n  | undefined {\n  if (!toChainID || !prefillTokenAddress) return undefined;\n  const list = DESTINATION_SWAP_TOKENS.get(toChainID);\n  const targetAddr = prefillTokenAddress.toLowerCase();\n  return list?.find((t) => t.tokenAddress?.toLowerCase() === targetAddr);\n}\n",
      "type": "registry:component",
      "target": "components/swaps/utils/prefill.ts"
    }
  ]
}