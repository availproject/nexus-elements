{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swaps",
  "type": "registry:component",
  "title": "Swaps",
  "description": "Swap tokens across chains (Exact In)",
  "dependencies": [
    "@avail-project/nexus-core@1.0.0-rc.3",
    "@radix-ui/react-dialog",
    "@radix-ui/react-label",
    "@radix-ui/react-select",
    "@radix-ui/react-slot",
    "@radix-ui/react-popover",
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://elements.nexus.availproject.org/r/button.json",
    "https://elements.nexus.availproject.org/r/card.json",
    "https://elements.nexus.availproject.org/r/dialog.json",
    "https://elements.nexus.availproject.org/r/input.json",
    "https://elements.nexus.availproject.org/r/label.json",
    "https://elements.nexus.availproject.org/r/select.json",
    "https://elements.nexus.availproject.org/r/nexus-provider.json",
    "https://elements.nexus.availproject.org/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/nexus-elements/swaps/swaps.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport SwapExactIn from \"./exact-in/exact-in\";\nimport SwapExactOut from \"./exact-out/exact-out\";\n\ninterface SwapsProps {\n  exactIn?: boolean;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  exactInprefill?: {\n    fromChainID?: number;\n    fromToken?: string;\n    fromAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n  exactOutprefill?: {\n    toAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst Swaps = ({\n  exactIn = true,\n  onComplete,\n  onStart,\n  onError,\n  exactInprefill,\n  exactOutprefill,\n}: SwapsProps) => {\n  if (exactIn)\n    return (\n      <SwapExactIn\n        onComplete={onComplete}\n        onStart={onStart}\n        onError={onError}\n        prefill={exactInprefill}\n      />\n    );\n  return (\n    <SwapExactOut\n      onComplete={onComplete}\n      onStart={onStart}\n      onError={onError}\n      prefill={exactOutprefill}\n    />\n  );\n};\n\nexport default Swaps;\n",
      "type": "registry:component",
      "target": "components/swaps/swaps.tsx"
    },
    {
      "path": "registry/nexus-elements/common/index.ts",
      "content": "export * from \"./hooks/useStopwatch\";\nexport * from \"./hooks/usePolling\";\nexport * from \"./hooks/useInterval\";\nexport * from \"./hooks/useStableCallback\";\nexport * from \"./hooks/useDebouncedValue\";\nexport * from \"./hooks/useDebouncedCallback\";\nexport * from \"./hooks/useNexusError\";\nexport * from \"./tx/types\";\nexport * from \"./tx/steps\";\nexport * from \"./tx/useTransactionSteps\";\nexport * from \"./utils/constant\";\n",
      "type": "registry:component",
      "target": "components/common/index.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/constant.ts",
      "content": "import { formatUnits, parseUnits } from \"viem\";\n\nexport const SHORT_CHAIN_NAME: Record<number, string> = {\n  1: \"Ethereum\",\n  8453: \"Base\",\n  42161: \"Arbitrum\",\n  10: \"Optimism\",\n  137: \"Polygon\",\n  43114: \"Avalanche\",\n  534352: \"Scroll\",\n  50104: \"Sophon\",\n  8217: \"Kaia\",\n  56: \"BNB\",\n  999: \"HyperEVM\",\n  728126428: \"Tron\",\n  11155111: \"Sepolia\",\n  84532: \"Base Sepolia\",\n  421614: \"Arbitrum Sepolia\",\n  11155420: \"Optimism Sepolia\",\n  80002: \"Polygon Amoy\",\n  10143: \"Monad Testnet\",\n  2494104990: \"Tron Shasta\",\n  567: \"Validium Testnet\",\n} as const;\n\nconst DEFAULT_SAFETY_MARGIN = 0.01; // 1%\n\n/**\n * Compute an amount string for fraction buttons (25%, 50%, 75%, 100%).\n *\n * @param balanceStr - user's balance as a human decimal string (e.g. \"12.345\") OR as base-unit integer string if `balanceIsBaseUnits` true\n * @param fraction - fraction e.g. 0.25, 0.5, 0.75, 1\n * @param decimals - token decimals (6 for USDC/USDT, 18 for ETH)\n * @param safetyMargin - 0.01 for 1% default\n * @param balanceIsBaseUnits - if true, balanceStr is already base units integer string (wei / smallest unit)\n * @returns decimal string clipped to token decimals (rounded down)\n */\nexport function computeAmountFromFraction(\n  balanceStr: string,\n  fraction: number,\n  decimals: number,\n  safetyMargin = DEFAULT_SAFETY_MARGIN,\n  balanceIsBaseUnits = false\n): string {\n  if (!balanceStr) return \"0\";\n\n  // parse balance into base units (BigInt)\n  const balanceUnits: bigint = balanceIsBaseUnits\n    ? BigInt(balanceStr)\n    : parseUnits(balanceStr, decimals);\n\n  if (balanceUnits === BigInt(0)) return \"0\";\n\n  // Use an integer precision multiplier to avoid FP issues\n  const PREC = 1_000_000; // 1e6 precision for fraction & safety margin\n  const safetyMul = BigInt(Math.max(0, Math.floor((1 - safetyMargin) * PREC))); // (1 - safetyMargin) * PREC\n  const fractionMul = BigInt(Math.max(0, Math.floor(fraction * PREC))); // fraction * PREC\n\n  // Apply safety margin: floor(balance * (1 - safetyMargin))\n  const maxAfterSafety = (balanceUnits * safetyMul) / BigInt(PREC);\n\n  // Apply fraction and floor: floor(maxAfterSafety * fraction)\n  let desiredUnits = (maxAfterSafety * fractionMul) / BigInt(PREC);\n\n  // Extra clamp just in case\n  if (desiredUnits > balanceUnits) desiredUnits = balanceUnits;\n  if (desiredUnits < BigInt(0)) desiredUnits = BigInt(0);\n\n  // format back to human readable decimal string with token decimals (formatUnits truncates/keeps decimals)\n  // formatUnits will produce exactly decimals digits if fractional part exists; we'll strip trailing zeros.\n  const raw = formatUnits(desiredUnits, decimals);\n  // strip trailing zeros and possible trailing dot\n  return raw\n    .replace(/(\\.\\d*?[1-9])0+$/u, \"$1\")\n    .replace(/\\.0+$/u, \"\")\n    .replace(/^\\.$/u, \"0\");\n}\n",
      "type": "registry:component",
      "target": "components/common/utils/constant.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStableCallback.ts",
      "content": "import { useCallback, useRef } from \"react\";\n\n/**\n * Returns a stable function identity that always calls the latest implementation.\n * Useful when passing callbacks to memoized children without re-creating handlers.\n */\nexport function useStableCallback<Args extends readonly unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const fnRef = useRef<(...args: Args) => Return>(fn);\n  fnRef.current = fn;\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const stable = useCallback(\n    ((...args: Args) => {\n      return fnRef.current(...args);\n    }) as (...args: Args) => Return,\n    []\n  );\n\n  return stable;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStableCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useNexusError.ts",
      "content": "import { NexusError } from \"@avail-project/nexus-core\";\n\nfunction handler(err: unknown) {\n  if (err instanceof NexusError) {\n    return {\n      code: err?.code,\n      message: err?.message,\n      context: err?.data?.context,\n      details: err?.data?.details,\n    };\n  } else {\n    console.error(\"Unexpected error:\", err);\n    return {\n      code: \"unexpected_error\",\n      message: \"Oops! Something went wrong. Please try again.\",\n      context: undefined,\n      details: undefined,\n    };\n  }\n}\nexport function useNexusError() {\n  return handler;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useNexusError.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useInterval.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ninterface UseIntervalOptions {\n  enabled?: boolean;\n  immediate?: boolean;\n}\n\n/**\n * Declarative setInterval with pause/resume and latest-callback semantics.\n * Pass delay=null to pause.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options: UseIntervalOptions = {}\n) {\n  const { enabled = true, immediate = false } = options;\n  const savedCallback = useStableCallback(callback);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (!enabled || delay == null) return;\n    if (immediate) {\n      savedCallback();\n    }\n    intervalRef.current = setInterval(savedCallback, delay);\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [delay, enabled, immediate, savedCallback]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useInterval.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStopwatch.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\ninterface UseStopwatchOptions {\n  running?: boolean;\n  intervalMs?: number;\n}\n\n/**\n * Simple stopwatch that increments elapsed seconds while running.\n * Designed to replace scattered timer effects.\n */\nexport function useStopwatch(options: UseStopwatchOptions = {}) {\n  const { running = false, intervalMs = 100 } = options;\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const reset = () => {\n    setElapsedSeconds(0);\n  };\n\n  const stop = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const start = () => {\n    if (timerRef.current) return;\n    timerRef.current = setInterval(() => {\n      // 1s == 1000ms; we add fractional seconds per tick\n      setElapsedSeconds((prev) => prev + intervalMs / 1000);\n    }, intervalMs);\n  };\n\n  useEffect(() => {\n    if (running) {\n      start();\n    } else {\n      stop();\n    }\n    return stop;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [running, intervalMs]);\n\n  return {\n    seconds: elapsedSeconds,\n    start,\n    stop,\n    reset,\n    running: Boolean(timerRef.current),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStopwatch.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/usePolling.ts",
      "content": "import { useRef } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { useStableCallback } from \"./useStableCallback\";\n\n/**\n * Declarative polling with in-flight protection (no overlap).\n * When enabled becomes true, an immediate run is executed,\n * followed by interval-based runs.\n */\nexport function usePolling(\n  enabled: boolean,\n  fn: () => Promise<void> | void,\n  intervalMs: number\n) {\n  const inFlightRef = useRef(false);\n  const wrapped = useStableCallback(async () => {\n    if (inFlightRef.current) return;\n    try {\n      inFlightRef.current = true;\n      await fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      inFlightRef.current = false;\n    }\n  });\n\n  useInterval(wrapped, enabled ? intervalMs : null, {\n    enabled,\n    immediate: enabled,\n  });\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/usePolling.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedCallback.ts",
      "content": "import { useEffect, useMemo, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype AnyFn = (...args: any[]) => any;\n\nexport interface Debounced<T extends AnyFn> {\n  (...args: Parameters<T>): void;\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Returns a debounced function that delays invoking `fn` until after `delay`\n * milliseconds have elapsed since the last call.\n */\nexport function useDebouncedCallback<T extends AnyFn>(\n  fn: T,\n  delay: number\n): Debounced<T> {\n  const latest = useStableCallback(fn);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  const cancel = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const flush = () => {\n    if (timerRef.current && lastArgsRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      latest(...lastArgsRef.current);\n      lastArgsRef.current = null;\n    }\n  };\n\n  // cancel when delay changes/unmounts\n  useEffect(() => cancel, [delay]);\n\n  return useMemo(() => {\n    const debounced = ((...args: Parameters<T>) => {\n      lastArgsRef.current = args;\n      cancel();\n      timerRef.current = setTimeout(() => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        latest(...lastArgsRef.current!);\n        lastArgsRef.current = null;\n        timerRef.current = null;\n      }, delay);\n    }) as Debounced<T>;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, latest]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedValue.ts",
      "content": "import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\n\n/**\n * Derives a debounced value from an input value and delay.\n */\nexport function useDebouncedValue<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState<T>(value);\n  const setter = useDebouncedCallback((v: T) => setDebounced(v), delay);\n\n  useEffect(() => {\n    setter(value);\n    return setter.cancel;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, delay]);\n\n  return debounced;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedValue.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/types.ts",
      "content": "export type TransactionStatus =\n  | \"idle\"\n  | \"preview\"\n  | \"awaiting-approval\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\nexport type GenericStep<TStep> = {\n  id: number;\n  completed: boolean;\n  step: TStep;\n};\n\n/**\n * Normalizes a step to a stable key. Prefers typeID, then type, otherwise JSON.\n */\nexport function getStepKey(step: any): string {\n  if (!step) return \"\";\n  if (typeof step.typeID === \"string\" && step.typeID.length > 0) {\n    return step.typeID;\n  }\n  if (typeof step.type === \"string\" && step.type.length > 0) {\n    return step.type;\n  }\n  try {\n    return JSON.stringify(step);\n  } catch {\n    return String(step);\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/types.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/steps.ts",
      "content": "import type { SwapStepType } from \"@avail-project/nexus-core\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\n\n/**\n * Predefined expected steps for swaps to seed UI before events arrive.\n * Kept here to avoid duplication across exact-in and exact-out hooks.\n */\nexport const SWAP_EXPECTED_STEPS: SwapStepType[] = [\n  { type: \"SWAP_START\", typeID: \"SWAP_START\" } as SwapStepType,\n  { type: \"DETERMINING_SWAP\", typeID: \"DETERMINING_SWAP\" } as SwapStepType,\n  {\n    type: \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    typeID:\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_BATCH_TX\",\n    typeID: \"SOURCE_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_HASH\",\n    typeID: \"SOURCE_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"RFF_ID\", typeID: \"RFF_ID\" } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_BATCH_TX\",\n    typeID: \"DESTINATION_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_HASH\",\n    typeID: \"DESTINATION_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"SWAP_COMPLETE\", typeID: \"SWAP_COMPLETE\" } as SwapStepType,\n];\n\nexport function seedSteps<T>(expected: T[]): Array<GenericStep<T>> {\n  return expected.map((st, index) => ({\n    id: index,\n    completed: false,\n    step: st,\n  }));\n}\n\nexport function computeAllCompleted<T>(steps: Array<GenericStep<T>>): boolean {\n  return steps.length > 0 && steps.every((s) => s.completed);\n}\n\n/**\n * Replace the current list of steps with a new list, preserving completion\n * for any steps that were already marked completed (matched by key).\n */\nexport function mergeStepsList<T>(\n  prev: Array<GenericStep<T>>,\n  list: T[]\n): Array<GenericStep<T>> {\n  const completedKeys = new Set<string>();\n  for (const prevStep of prev) {\n    if (prevStep.completed) {\n      completedKeys.add(getStepKey(prevStep.step));\n    }\n  }\n  const next: Array<GenericStep<T>> = [];\n  for (let index = 0; index < list.length; index++) {\n    const step = list[index];\n    const key = getStepKey(step);\n    next.push({\n      id: index,\n      completed: completedKeys.has(key),\n      step,\n    });\n  }\n  return next;\n}\n\n/**\n * Mark a step complete in-place; if the step doesn't yet exist, append it.\n */\nexport function mergeStepComplete<T>(\n  prev: Array<GenericStep<T>>,\n  step: T\n): Array<GenericStep<T>> {\n  const key = getStepKey(step);\n  const updated: Array<GenericStep<T>> = [];\n  let found = false;\n  for (const s of prev) {\n    if (getStepKey(s.step) === key) {\n      updated.push({ ...s, completed: true, step: { ...s.step, ...step } });\n      found = true;\n    } else {\n      updated.push(s);\n    }\n  }\n  if (!found) {\n    updated.push({\n      id: updated.length,\n      completed: true,\n      step,\n    });\n  }\n  return updated;\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/steps.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/useTransactionSteps.ts",
      "content": "import { useMemo, useRef, useState } from \"react\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\nimport {\n  computeAllCompleted,\n  mergeStepComplete,\n  mergeStepsList,\n  seedSteps,\n} from \"./steps\";\n\ninterface UseTransactionStepsOptions<T> {\n  expected?: T[];\n}\n\n/**\n * Manages transaction steps with utilities to seed from expected steps,\n * replace the list on \"steps list\" events, and mark individual steps complete.\n */\nexport function useTransactionSteps<\n  T extends { typeID?: string; type?: string }\n>(options: UseTransactionStepsOptions<T> = {}) {\n  const { expected } = options;\n  const [steps, setSteps] = useState<Array<GenericStep<T>>>(() =>\n    expected ? seedSteps(expected) : []\n  );\n  const lastSignatureRef = useRef<string>(\"\");\n\n  const onStepsList = (list: T[]) => {\n    const signature = list.map((step) => getStepKey(step)).join(\"|\");\n    if (lastSignatureRef.current === signature) {\n      setSteps((prev) => mergeStepsList(prev, list));\n      return;\n    }\n    lastSignatureRef.current = signature;\n    setSteps((prev) => mergeStepsList(prev, list));\n  };\n\n  const onStepComplete = (step: T) => {\n    setSteps((prev) => mergeStepComplete(prev, step));\n  };\n\n  const seed = (expectedSteps: T[]) => {\n    setSteps(seedSteps(expectedSteps));\n  };\n\n  const reset = () => {\n    setSteps(expected ? seedSteps(expected) : []);\n    lastSignatureRef.current = \"\";\n  };\n\n  const allCompleted = useMemo(() => computeAllCompleted(steps), [steps]);\n\n  return {\n    steps,\n    allCompleted,\n    onStepsList,\n    onStepComplete,\n    seed,\n    reset,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/useTransactionSteps.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-in/exact-in.tsx",
      "content": "\"use client\";\nimport React, { useEffect, useMemo, type FC } from \"react\";\nimport { Card, CardContent } from \"../../ui/card\";\nimport { Button } from \"../../ui/button\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport useExactIn from \"./hooks/useExactIn\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"../../ui/dialog\";\nimport { Input } from \"../../ui/input\";\nimport { Label } from \"../../ui/label\";\nimport { LoaderPinwheel } from \"lucide-react\";\nimport SourceAssetSelect from \"../components/source-asset-select\";\nimport AmountInput from \"../components/amount-input\";\nimport DestinationAssetSelect from \"../components/destination-asset-select\";\nimport SwapSourceBreakdown from \"../components/swap-source-breakdown\";\nimport TransactionProgress from \"../components/transaction-progress\";\n\ninterface SwapExactInProps {\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    fromChainID?: number;\n    fromToken?: string;\n    fromAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst SwapExactIn: FC<SwapExactInProps> = ({\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}) => {\n  const { nexusSDK, swapIntent, swapBalance, fetchSwapBalance } = useNexus();\n  const {\n    inputs,\n    setInputs,\n    loading,\n    isDialogOpen,\n    setIsDialogOpen,\n    txError,\n    timer,\n    steps,\n    sourceExplorerUrl,\n    destinationExplorerUrl,\n    handleSwap,\n    reset,\n    areInputsValid,\n  } = useExactIn({\n    nexusSDK,\n    swapIntent,\n    swapBalance,\n    fetchBalance: fetchSwapBalance,\n    onComplete,\n    onStart,\n    onError,\n    prefill,\n  });\n\n  const availableBalance = useMemo(() => {\n    if (!nexusSDK || !swapBalance || !inputs?.fromToken || !inputs?.fromChainID)\n      return undefined;\n    const filteredToken = swapBalance\n      ?.find((token) => token.symbol === inputs?.fromToken?.symbol)\n      ?.breakdown?.find((chain) => chain.chain?.id === inputs?.fromChainID);\n\n    if (!filteredToken) return undefined;\n\n    return nexusSDK?.utils?.formatTokenBalance(filteredToken?.balance, {\n      symbol: inputs?.fromToken?.symbol,\n      decimals: filteredToken?.decimals,\n    });\n  }, [inputs?.fromToken, inputs?.fromChainID, swapBalance, nexusSDK]);\n\n  useEffect(() => {\n    if (!swapBalance) {\n      fetchSwapBalance();\n    }\n  }, [swapBalance]);\n\n  return (\n    <Card className=\"w-full max-w-xl\">\n      <CardContent className=\"flex flex-col gap-y-4 w-full\">\n        <div className=\"flex items-center justify-between\">\n          <p className=\"text-base font-semibold\">Swap</p>\n          <span className=\"text-xs text-muted-foreground\">Exact In</span>\n        </div>\n\n        <SourceAssetSelect\n          selectedChain={inputs.fromChainID}\n          selectedToken={inputs.fromToken}\n          onSelect={(fromChainID, fromToken) =>\n            setInputs({ ...inputs, fromChainID, fromToken })\n          }\n          disabled={Boolean(prefill?.fromChainID && prefill?.fromToken)}\n          swapBalance={swapBalance}\n        />\n        <div className=\"flex flex-col gap-y-2\">\n          <label className=\"text-sm font-medium\" htmlFor=\"swap-amount\">\n            Amount\n          </label>\n          <AmountInput\n            amount={inputs.fromAmount}\n            onChange={(val) => setInputs({ ...inputs, fromAmount: val })}\n            symbol={inputs.fromToken?.symbol}\n            disabled={Boolean(prefill?.fromAmount)}\n            balance={availableBalance}\n          />\n        </div>\n\n        <DestinationAssetSelect\n          selectedChain={inputs.toChainID}\n          selectedToken={inputs.toToken}\n          onSelect={(toChainID, toToken) =>\n            setInputs({ ...inputs, toChainID, toToken })\n          }\n          disabled={Boolean(prefill?.toChainID && prefill?.toToken)}\n        />\n\n        {!swapIntent.current && (\n          <Button onClick={handleSwap} disabled={loading || !areInputsValid}>\n            {loading ? (\n              <LoaderPinwheel className=\"animate-spin size-5\" />\n            ) : (\n              \"Swap\"\n            )}\n          </Button>\n        )}\n\n        {swapIntent.current && (\n          <>\n            <div className=\"flex flex-col gap-y-2\">\n              <Label className=\"text-sm font-medium\" htmlFor=\"swap-receive\">\n                You receive (estimated)\n              </Label>\n              <Input\n                id=\"swap-receive\"\n                disabled\n                className=\"w-full border rounded px-3 py-2 text-sm bg-muted cursor-not-allowed\"\n                value={`${swapIntent.current?.intent?.destination?.amount}`}\n                placeholder=\"—\"\n                readOnly\n              />\n            </div>\n            <div className=\"w-full flex items-center gap-x-2 justify-between\">\n              <Button\n                variant={\"destructive\"}\n                onClick={() => {\n                  swapIntent.current?.deny();\n                  swapIntent.current = null;\n                  reset();\n                }}\n                className=\"w-1/2\"\n              >\n                Deny\n              </Button>\n              <Button\n                onClick={() => {\n                  swapIntent.current?.allow();\n                  setIsDialogOpen(true);\n                }}\n                className=\"w-1/2\"\n              >\n                Accept\n              </Button>\n            </div>\n            {swapIntent.current?.intent && (\n              <SwapSourceBreakdown intent={swapIntent.current?.intent} />\n            )}\n          </>\n        )}\n\n        <Dialog\n          open={isDialogOpen}\n          onOpenChange={(o) => {\n            if (loading) return;\n            if (!o) reset();\n            setIsDialogOpen(o);\n          }}\n        >\n          <DialogContent>\n            <DialogHeader className=\"sr-only\">\n              <DialogTitle>Swap Progress</DialogTitle>\n            </DialogHeader>\n            <TransactionProgress\n              timer={timer}\n              steps={steps}\n              sourceExplorerUrl={sourceExplorerUrl}\n              destinationExplorerUrl={destinationExplorerUrl}\n            />\n          </DialogContent>\n        </Dialog>\n\n        {txError && (\n          <div className=\"rounded-md border border-destructive bg-destructive/80 px-3 py-2 text-sm text-destructive-foreground flex items-start justify-between gap-x-3 mt-3 w-full max-w-lg\">\n            <span className=\"flex-1 max-w-md truncate\">{txError}</span>\n            <Button\n              type=\"button\"\n              size={\"icon\"}\n              variant={\"ghost\"}\n              onClick={() => {\n                reset();\n              }}\n              className=\"text-destructive-foreground/80 hover:text-destructive-foreground focus:outline-none\"\n              aria-label=\"Dismiss error\"\n            >\n              ×\n            </Button>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default SwapExactIn;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-in/exact-in.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-out/exact-out.tsx",
      "content": "import React, { type FC } from \"react\";\nimport { Card, CardContent } from \"../../ui/card\";\nimport AmountInput from \"../components/amount-input\";\nimport DestinationAssetSelect from \"../components/destination-asset-select\";\nimport { Button } from \"../../ui/button\";\nimport { LoaderPinwheel } from \"lucide-react\";\nimport { Label } from \"../../ui/label\";\nimport { Input } from \"../../ui/input\";\nimport SwapSourceBreakdown from \"../components/swap-source-breakdown\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"../../ui/dialog\";\nimport TransactionProgress from \"../components/transaction-progress\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport useExactOut from \"./hooks/useExactOut\";\n\ninterface SwapExactOutProps {\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    toChainID?: number;\n    toToken?: string;\n    toAmount?: string;\n  };\n}\n\nconst SwapExactOut: FC<SwapExactOutProps> = ({\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}) => {\n  const { nexusSDK, swapIntent, swapBalance, fetchSwapBalance } = useNexus();\n  const {\n    inputs,\n    setInputs,\n    loading,\n    isDialogOpen,\n    setIsDialogOpen,\n    txError,\n    timer,\n    steps,\n    sourceExplorerUrl,\n    destinationExplorerUrl,\n    handleSwap,\n    reset,\n  } = useExactOut({\n    nexusSDK,\n    swapIntent,\n    swapBalance,\n    fetchBalance: fetchSwapBalance,\n    onComplete,\n    onStart,\n    onError,\n    prefill,\n  });\n  return (\n    <Card className=\"w-full max-w-xl\">\n      <CardContent className=\"flex flex-col gap-y-4 w-full\">\n        <div className=\"flex items-center justify-between\">\n          <p className=\"text-base font-semibold\">Swap</p>\n          <span className=\"text-xs text-muted-foreground\">Exact Out</span>\n        </div>\n        <div className=\"flex flex-col gap-y-2\">\n          <label className=\"text-sm font-medium\" htmlFor=\"swap-amount\">\n            Amount\n          </label>\n          <AmountInput\n            amount={inputs.toAmount}\n            onChange={(val) => setInputs({ ...inputs, toAmount: val })}\n            symbol={inputs.toToken?.symbol}\n            disabled={Boolean(prefill?.toAmount)}\n            hideBalance={true}\n          />\n        </div>\n\n        <DestinationAssetSelect\n          selectedChain={inputs.toChainID}\n          selectedToken={inputs.toToken}\n          onSelect={(toChainID, toToken) =>\n            setInputs({ ...inputs, toChainID, toToken })\n          }\n          disabled={Boolean(prefill?.toChainID && prefill?.toToken)}\n        />\n\n        {!swapIntent.current && (\n          <Button onClick={handleSwap} disabled={loading}>\n            {loading ? (\n              <LoaderPinwheel className=\"animate-spin size-5\" />\n            ) : (\n              \"Swap\"\n            )}\n          </Button>\n        )}\n\n        {swapIntent.current && (\n          <>\n            <div className=\"flex flex-col gap-y-2\">\n              <Label className=\"text-sm font-medium\" htmlFor=\"swap-receive\">\n                You receive (estimated)\n              </Label>\n              <Input\n                id=\"swap-receive\"\n                disabled\n                className=\"w-full border rounded px-3 py-2 text-sm bg-muted cursor-not-allowed\"\n                value={`${\n                  swapIntent.current?.intent?.destination?.amount ?? \"\"\n                }`}\n                placeholder=\"—\"\n                readOnly\n              />\n            </div>\n            <div className=\"w-full flex items-center gap-x-2 justify-between\">\n              <Button\n                variant={\"destructive\"}\n                onClick={() => {\n                  swapIntent.current?.deny();\n                  swapIntent.current = null;\n                  reset();\n                }}\n                className=\"w-1/2\"\n              >\n                Deny\n              </Button>\n              <Button\n                onClick={() => {\n                  swapIntent.current?.allow();\n                  setIsDialogOpen(true);\n                }}\n                className=\"w-1/2\"\n              >\n                Accept\n              </Button>\n            </div>\n            {swapIntent.current?.intent && (\n              <SwapSourceBreakdown intent={swapIntent.current?.intent} />\n            )}\n          </>\n        )}\n\n        <Dialog\n          open={isDialogOpen}\n          onOpenChange={(o) => {\n            if (loading) return;\n            if (!o) reset();\n            setIsDialogOpen(o);\n          }}\n        >\n          <DialogContent>\n            <DialogHeader className=\"sr-only\">\n              <DialogTitle>Swap Progress</DialogTitle>\n            </DialogHeader>\n            <TransactionProgress\n              timer={timer}\n              steps={steps}\n              sourceExplorerUrl={sourceExplorerUrl}\n              destinationExplorerUrl={destinationExplorerUrl}\n            />\n          </DialogContent>\n        </Dialog>\n\n        {txError && (\n          <div className=\"rounded-md border border-destructive bg-destructive/80 px-3 py-2 text-sm text-destructive-foreground flex items-start justify-between gap-x-3 mt-3 w-full max-w-lg\">\n            <span className=\"flex-1 max-w-md truncate\">{txError}</span>\n            <Button\n              type=\"button\"\n              size={\"icon\"}\n              variant={\"ghost\"}\n              onClick={() => {\n                reset();\n              }}\n              className=\"text-destructive-foreground/80 hover:text-destructive-foreground focus:outline-none\"\n              aria-label=\"Dismiss error\"\n            >\n              X\n            </Button>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default SwapExactOut;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-out/exact-out.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/source-asset-select.tsx",
      "content": "\"use client\";\nimport React, { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport {\n  CHAIN_METADATA,\n  UserAsset,\n  type SUPPORTED_CHAINS_IDS,\n} from \"@avail-project/nexus-core\";\nimport { TOKEN_IMAGES } from \"../config/destination\";\nimport { Loader2 } from \"lucide-react\";\n\ntype SourceTokenInfo = {\n  contractAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n  balance?: string;\n};\n\ninterface SourceAssetSelectProps {\n  selectedChain?: SUPPORTED_CHAINS_IDS;\n  selectedToken?: SourceTokenInfo;\n  onSelect: (chainId: SUPPORTED_CHAINS_IDS, token: SourceTokenInfo) => void;\n  disabled?: boolean;\n  label?: string;\n  swapBalance: UserAsset[] | null;\n}\n\nconst SourceAssetSelect: FC<SourceAssetSelectProps> = ({\n  selectedChain,\n  selectedToken,\n  onSelect,\n  disabled,\n  label = \"From\",\n  swapBalance,\n}) => {\n  const { swapSupportedChainsAndTokens, nexusSDK } = useNexus();\n  const [open, setOpen] = useState(false);\n  const [tempChain, setTempChain] = useState<number | null>(null);\n\n  const chains = swapSupportedChainsAndTokens ?? [];\n\n  const tokensForTempChain: SourceTokenInfo[] = useMemo(() => {\n    if (!tempChain || !swapBalance) return [] as SourceTokenInfo[];\n    const tokens: SourceTokenInfo[] = [];\n\n    for (const asset of swapBalance) {\n      if (!asset?.breakdown?.length) continue;\n      const breakdownForChain = asset.breakdown.find(\n        (b) => b.chain?.id === tempChain && Number.parseFloat(b.balance) > 0\n      );\n      if (!breakdownForChain) continue;\n\n      tokens.push({\n        contractAddress: breakdownForChain.contractAddress,\n        decimals: breakdownForChain.decimals ?? asset.decimals,\n        logo: TOKEN_IMAGES[asset.symbol] ?? \"\",\n        name: asset.symbol,\n        symbol: asset.symbol,\n        balance: nexusSDK?.utils?.formatTokenBalance(\n          breakdownForChain?.balance,\n          {\n            symbol: asset.symbol,\n            decimals: asset.decimals,\n          }\n        ),\n      });\n    }\n\n    const unique = new Map<string, SourceTokenInfo>();\n    for (const t of tokens) {\n      unique.set(t.contractAddress.toLowerCase(), t);\n    }\n    return Array.from(unique.values());\n  }, [tempChain, swapBalance]);\n\n  const handlePick = (tok: SourceTokenInfo) => {\n    if (!tempChain) return;\n    onSelect(tempChain as SUPPORTED_CHAINS_IDS, tok);\n    setOpen(false);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <p className=\"text-sm font-semibold mb-1\">{label}</p>\n      <Dialog open={open} onOpenChange={(o) => !disabled && setOpen(o)}>\n        <DialogTrigger asChild>\n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-between\"\n            disabled={disabled}\n          >\n            {selectedChain && selectedToken ? (\n              <div className=\"flex items-center gap-x-3\">\n                <div className=\"relative\">\n                  <img\n                    src={TOKEN_IMAGES[selectedToken?.symbol]}\n                    alt={selectedToken.symbol}\n                    width={24}\n                    height={24}\n                    className=\"rounded-full\"\n                  />\n                  <img\n                    src={CHAIN_METADATA[selectedChain].logo}\n                    alt={CHAIN_METADATA[selectedChain].name}\n                    width={16}\n                    height={16}\n                    className=\"rounded-full absolute bottom-0 right-0 translate-x-1/3 translate-y-1/6\"\n                  />\n                </div>\n\n                <span className=\"text-sm font-medium\">\n                  {selectedToken.symbol} on {CHAIN_METADATA[selectedChain].name}\n                </span>\n              </div>\n            ) : (\n              <span className=\"text-sm text-muted-foreground\">\n                Select chain and token\n              </span>\n            )}\n          </Button>\n        </DialogTrigger>\n        <DialogContent className=\"max-w-3xl\">\n          <DialogHeader>\n            <DialogTitle>Select source asset</DialogTitle>\n          </DialogHeader>\n          {swapBalance && (\n            <div className=\"grid grid-cols-2 gap-4\">\n              <div className=\"border rounded-md p-2 max-h-80 overflow-y-auto\">\n                <p className=\"text-xs font-medium mb-2\">Chains</p>\n                <div className=\"flex flex-col items-center sm:items-start gap-y-1 w-full\">\n                  {chains.map((c) => (\n                    <Button\n                      key={c.id}\n                      variant={\"ghost\"}\n                      onClick={() => setTempChain(c.id)}\n                      className={`flex items-center justify-start w-full gap-x-2 p-2 rounded hover:bg-muted ${\n                        tempChain === c.id ? \"bg-muted\" : \"\"\n                      }`}\n                    >\n                      <img\n                        src={c.logo}\n                        alt={c.name}\n                        width={18}\n                        height={18}\n                        className=\"rounded-full\"\n                      />\n                      <span className=\"text-sm\">{c.name}</span>\n                    </Button>\n                  ))}\n                </div>\n              </div>\n              <div className=\"border rounded-md p-2 max-h-80 overflow-y-auto\">\n                <p className=\"text-xs font-medium mb-2\">Tokens</p>\n                <div className=\"flex flex-col items-center sm:items-start gap-y-1 w-full\">\n                  {tempChain && tokensForTempChain ? (\n                    tokensForTempChain?.map((t) => (\n                      <Button\n                        key={t.symbol}\n                        variant={\"ghost\"}\n                        onClick={() => handlePick(t)}\n                        className=\"flex items-center justify-start gap-x-2 p-2 rounded hover:bg-muted w-full\"\n                      >\n                        {t.symbol ? (\n                          <img\n                            src={TOKEN_IMAGES[t.symbol]}\n                            alt={t.symbol}\n                            width={18}\n                            height={18}\n                            className=\"rounded-full\"\n                          />\n                        ) : null}\n                        <p className=\"text-sm text-foreground\">{t.balance}</p>\n                      </Button>\n                    ))\n                  ) : (\n                    <p className=\"text-xs text-muted-foreground\">\n                      Select a chain\n                    </p>\n                  )}\n                </div>\n              </div>\n            </div>\n          )}\n          {!swapBalance && (\n            <div className=\"flex flex-col items-center justify-center gap-y-3\">\n              <p className=\"text-sm text-muted-foreground\">\n                Fetching swappable assets\n              </p>\n              <Loader2 className=\"animate-spin size-5\" />\n            </div>\n          )}\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default SourceAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/source-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/destination-asset-select.tsx",
      "content": "\"use client\";\nimport React, { type FC, useMemo, useState } from \"react\";\nimport { Button } from \"../../ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport {\n  type SUPPORTED_CHAINS_IDS,\n  CHAIN_METADATA,\n} from \"@avail-project/nexus-core\";\nimport { DESTINATION_SWAP_TOKENS, TOKEN_IMAGES } from \"../config/destination\";\n\ntype DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n};\n\ninterface DestinationAssetSelectProps {\n  selectedChain?: SUPPORTED_CHAINS_IDS;\n  selectedToken?: DestinationTokenInfo;\n  onSelect: (\n    chainId: SUPPORTED_CHAINS_IDS,\n    token: DestinationTokenInfo\n  ) => void;\n  disabled?: boolean;\n  label?: string;\n}\n\nconst DestinationAssetSelect: FC<DestinationAssetSelectProps> = ({\n  selectedChain,\n  selectedToken,\n  onSelect,\n  disabled,\n  label = \"To\",\n}) => {\n  const [open, setOpen] = useState(false);\n  const [tempChain, setTempChain] = useState<number | null>(null);\n\n  const chains = useMemo(() => Array.from(DESTINATION_SWAP_TOKENS.keys()), []);\n  const tokensForTempChain: DestinationTokenInfo[] = useMemo(() => {\n    if (!tempChain) return [] as DestinationTokenInfo[];\n    return DESTINATION_SWAP_TOKENS.get(tempChain) ?? [];\n  }, [tempChain]);\n\n  const handlePick = (tok: DestinationTokenInfo) => {\n    if (!tempChain) return;\n    onSelect(tempChain as SUPPORTED_CHAINS_IDS, tok);\n    setOpen(false);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <p className=\"text-sm font-semibold mb-1\">{label}</p>\n      <Dialog open={open} onOpenChange={(o) => !disabled && setOpen(o)}>\n        <DialogTrigger asChild>\n          <Button\n            variant=\"outline\"\n            className=\"w-full justify-between\"\n            disabled={disabled}\n          >\n            {selectedChain && selectedToken ? (\n              <div className=\"flex items-center gap-x-3\">\n                <div className=\"relative\">\n                  <img\n                    src={TOKEN_IMAGES[selectedToken?.symbol]}\n                    alt={selectedToken.symbol}\n                    width={24}\n                    height={24}\n                    className=\"rounded-full\"\n                  />\n                  <img\n                    src={CHAIN_METADATA[selectedChain].logo}\n                    alt={CHAIN_METADATA[selectedChain].name}\n                    width={16}\n                    height={16}\n                    className=\"rounded-full absolute bottom-0 right-0 translate-x-1/3 translate-y-1/6\"\n                  />\n                </div>\n\n                <span className=\"text-sm font-medium\">\n                  {selectedToken.symbol} on {CHAIN_METADATA[selectedChain].name}\n                </span>\n              </div>\n            ) : (\n              <span className=\"text-sm text-muted-foreground\">\n                Select chain and token\n              </span>\n            )}\n          </Button>\n        </DialogTrigger>\n        <DialogContent className=\"max-w-3xl\">\n          <DialogHeader>\n            <DialogTitle>Select destination asset</DialogTitle>\n          </DialogHeader>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"border rounded-md p-2 max-h-80 overflow-y-auto\">\n              <p className=\"text-xs font-medium mb-2\">Chains</p>\n              <div className=\"flex flex-col gap-y-1\">\n                {chains.map((id) => {\n                  const meta = CHAIN_METADATA[id as SUPPORTED_CHAINS_IDS];\n                  return (\n                    <Button\n                      key={id}\n                      type=\"button\"\n                      variant=\"ghost\"\n                      onClick={() => setTempChain(id)}\n                      className={`flex items-center justify-start gap-x-2 p-2 rounded hover:bg-muted w-full ${\n                        tempChain === id ? \"bg-muted\" : \"\"\n                      }`}\n                    >\n                      <img\n                        src={meta.logo}\n                        alt={meta.name}\n                        width={18}\n                        height={18}\n                        className=\"rounded-full\"\n                      />\n                      <span className=\"text-sm\">{meta.name}</span>\n                    </Button>\n                  );\n                })}\n              </div>\n            </div>\n            <div className=\"border rounded-md p-2 max-h-80 overflow-y-auto\">\n              <p className=\"text-xs font-medium mb-2\">Tokens</p>\n              <div className=\"flex flex-col gap-y-1\">\n                {tempChain ? (\n                  tokensForTempChain.map((t) => (\n                    <Button\n                      key={t.symbol}\n                      type=\"button\"\n                      variant=\"ghost\"\n                      onClick={() => handlePick(t)}\n                      className=\"flex items-center justify-start gap-x-2 p-2 rounded hover:bg-muted w-full\"\n                    >\n                      {t.logo ? (\n                        <img\n                          src={t.logo}\n                          alt={t.symbol}\n                          width={18}\n                          height={18}\n                          className=\"rounded-full\"\n                        />\n                      ) : null}\n                      <span className=\"text-sm\">{t.symbol}</span>\n                    </Button>\n                  ))\n                ) : (\n                  <p className=\"text-xs text-muted-foreground\">\n                    Select a chain\n                  </p>\n                )}\n              </div>\n            </div>\n          </div>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default DestinationAssetSelect;\n",
      "type": "registry:component",
      "target": "components/swaps/components/destination-asset-select.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/amount-input.tsx",
      "content": "import React, { type FC, useEffect, useRef } from \"react\";\nimport { Input } from \"../../ui/input\";\n\ninterface AmountInputProps {\n  amount?: string;\n  onChange: (value: string) => void;\n  onCommit?: (value: string) => void;\n  disabled?: boolean;\n  symbol?: string;\n  hideBalance?: boolean;\n  balance?: string;\n}\n\nconst AmountInput: FC<AmountInputProps> = ({\n  amount,\n  onChange,\n  onCommit,\n  disabled,\n  symbol,\n  hideBalance = false,\n  balance,\n}) => {\n  const commitTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const scheduleCommit = (val: string) => {\n    if (!onCommit || disabled) return;\n    if (commitTimerRef.current) clearTimeout(commitTimerRef.current);\n    commitTimerRef.current = setTimeout(() => {\n      onCommit(val);\n    }, 600);\n  };\n\n  useEffect(() => {\n    return () => {\n      if (commitTimerRef.current) {\n        clearTimeout(commitTimerRef.current);\n        commitTimerRef.current = null;\n      }\n    };\n  }, []);\n\n  return (\n    <div className=\"w-full flex sm:flex-row flex-col border border-border rounded-lg gap-y-2\">\n      <Input\n        type=\"text\"\n        inputMode=\"decimal\"\n        value={amount ?? \"\"}\n        placeholder={`Enter Amount ${symbol ?? \"\"}`}\n        onChange={(e) => {\n          let next = e.target.value.replaceAll(/[^0-9.]/g, \"\");\n          const parts = next.split(\".\");\n          if (parts.length > 2) next = parts[0] + \".\" + parts.slice(1).join(\"\");\n          if (next === \".\") next = \"0.\";\n          onChange(next);\n          scheduleCommit(next);\n        }}\n        onKeyDown={(e) => {\n          if (e.key === \"Enter\") {\n            if (commitTimerRef.current) {\n              clearTimeout(commitTimerRef.current);\n              commitTimerRef.current = null;\n            }\n            onCommit?.(amount ?? \"\");\n          }\n        }}\n        className=\"w-full border-none bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 shadow-none py-0 px-3\"\n        aria-invalid={Boolean(amount) && Number.isNaN(Number(amount))}\n        disabled={disabled}\n      />\n      {!hideBalance && balance && (\n        <div className=\"flex items-center justify-end-safe gap-x-4 w-max px-2 border-l border-border\">\n          <p className=\"text-sm font-semibold w-max\">{balance}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default AmountInput;\n",
      "type": "registry:component",
      "target": "components/swaps/components/amount-input.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/components/swap-source-breakdown.tsx",
      "content": "import React from \"react\";\nimport { type OnSwapIntentHook } from \"@avail-project/nexus-core\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\n\ntype SwapIntent = Parameters<OnSwapIntentHook>[0][\"intent\"];\n\ninterface SwapSourceBreakdownProps {\n  intent: SwapIntent;\n  isLoading?: boolean;\n}\n\nconst SwapSourceBreakdown: React.FC<SwapSourceBreakdownProps> = ({\n  intent,\n}) => {\n  const { nexusSDK } = useNexus();\n  if (!intent) return null;\n  return (\n    <div className=\"w-full border rounded-md p-3\">\n      <p className=\"text-sm font-semibold mb-2\">Route</p>\n      <div className=\"flex flex-col gap-y-2\">\n        <div className=\"flex items-start justify-between gap-x-4\">\n          <p className=\"text-sm font-medium\">Destination</p>\n          <div className=\"text-right\">\n            <p className=\"text-sm font-semibold\">\n              {nexusSDK?.utils?.formatTokenBalance(intent.destination.amount, {\n                symbol: intent.destination.token.symbol,\n                decimals: intent.destination.token.decimals,\n              })}\n            </p>\n            <p className=\"text-xs text-muted-foreground\">\n              on {intent.destination.chain.name}\n            </p>\n          </div>\n        </div>\n        <div className=\"flex flex-col gap-y-1\">\n          <p className=\"text-sm font-medium\">Sources</p>\n          {intent.sources.map((s) => (\n            <div key={s.chain.id} className=\"flex items-center justify-between\">\n              <span className=\"text-xs text-muted-foreground\">\n                {s.chain.name}\n              </span>\n              <span className=\"text-sm font-medium\">\n                {nexusSDK?.utils?.formatTokenBalance(s.amount, {\n                  symbol: s.token.symbol,\n                  decimals: s.token.decimals,\n                })}\n              </span>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SwapSourceBreakdown;\n",
      "type": "registry:component",
      "target": "components/swaps/components/swap-source-breakdown.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-in/hooks/useExactIn.ts",
      "content": "import { type RefObject, useEffect, useMemo, useState } from \"react\";\nimport {\n  NexusSDK,\n  SUPPORTED_CHAINS,\n  type SUPPORTED_CHAINS_IDS,\n  type ExactInSwapInput,\n  NEXUS_EVENTS,\n  type SwapStepType,\n  type OnSwapIntentHookData,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\nimport {\n  resolveDestinationFromPrefill,\n  resolveSourceFromPrefill,\n} from \"../../utils/prefill\";\nimport {\n  useStopwatch,\n  useTransactionSteps,\n  SWAP_EXPECTED_STEPS,\n  useNexusError,\n} from \"../../../common\";\n\ntype SourceTokenInfo = {\n  contractAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n};\ntype DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n};\n\ninterface SwapInputs {\n  fromChainID: SUPPORTED_CHAINS_IDS;\n  fromToken?: SourceTokenInfo;\n  fromAmount?: string;\n  toChainID: SUPPORTED_CHAINS_IDS;\n  toToken?: DestinationTokenInfo;\n}\n\ninterface UseExactInProps {\n  nexusSDK: NexusSDK | null;\n  address?: Address;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  swapBalance: UserAsset[] | null;\n  fetchBalance: () => Promise<void>;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    fromChainID?: number;\n    fromToken?: string;\n    fromAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst useExactIn = ({\n  nexusSDK,\n  swapIntent,\n  swapBalance,\n  fetchBalance,\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}: UseExactInProps) => {\n  const handleNexusError = useNexusError();\n\n  const [inputs, setInputs] = useState<SwapInputs>({\n    fromChainID:\n      (prefill?.fromChainID as SUPPORTED_CHAINS_IDS) ?? SUPPORTED_CHAINS.BASE,\n    toChainID:\n      (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ?? SUPPORTED_CHAINS.OPTIMISM,\n    fromAmount: prefill?.fromAmount ?? undefined,\n  });\n  const [loading, setLoading] = useState(false);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [txError, setTxError] = useState<string | null>(null);\n  const [sourceExplorerUrl, setSourceExplorerUrl] = useState<string>(\"\");\n  const [destinationExplorerUrl, setDestinationExplorerUrl] =\n    useState<string>(\"\");\n  const {\n    steps,\n    seed,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<SwapStepType>();\n  const swapCompleted = useMemo(\n    () => steps.some((s) => s.step?.type === \"SWAP_COMPLETE\" && s.completed),\n    [steps]\n  );\n  const stopwatch = useStopwatch({\n    running: isDialogOpen && !swapCompleted,\n    intervalMs: 100,\n  });\n\n  const areInputsValid = useMemo(() => {\n    return (\n      inputs.fromChainID !== undefined &&\n      inputs.toChainID !== undefined &&\n      inputs.fromToken &&\n      inputs.toToken &&\n      inputs.fromAmount &&\n      Number(inputs.fromAmount) > 0\n    );\n  }, [inputs]);\n\n  const handleSwap = async () => {\n    if (\n      !nexusSDK ||\n      !areInputsValid ||\n      !inputs.fromToken ||\n      !inputs.toToken ||\n      !inputs.fromAmount\n    )\n      return;\n    try {\n      onStart?.();\n      setLoading(true);\n      setTxError(null);\n      seed(SWAP_EXPECTED_STEPS);\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        inputs.fromAmount,\n        inputs.fromToken.symbol,\n        inputs.fromChainID\n      );\n      const swapInput: ExactInSwapInput = {\n        from: [\n          {\n            chainId: inputs.fromChainID,\n            amount: amountBigInt,\n            tokenAddress: inputs.fromToken.contractAddress,\n          },\n        ],\n        toChainId: inputs.toChainID,\n        toTokenAddress: inputs.toToken.tokenAddress,\n      };\n\n      const result = await nexusSDK.swapWithExactIn(swapInput, {\n        onEvent: (event) => {\n          if (event.name === NEXUS_EVENTS.SWAP_STEP_COMPLETE) {\n            const step = event.args as SwapStepType & {\n              explorerURL?: string;\n              completed?: boolean;\n            };\n            if (step?.type === \"SOURCE_SWAP_HASH\" && step.explorerURL) {\n              setSourceExplorerUrl(step.explorerURL);\n            }\n            if (step?.type === \"DESTINATION_SWAP_HASH\" && step.explorerURL) {\n              setDestinationExplorerUrl(step.explorerURL);\n            }\n            onStepComplete(step);\n          }\n        },\n      });\n      if (!result?.success) {\n        throw new Error(result?.error || \"Swap failed\");\n      }\n      onComplete?.(swapIntent.current?.intent?.destination?.amount);\n      swapIntent.current = null;\n      await fetchBalance();\n    } catch (error) {\n      const { message } = handleNexusError(error);\n      setTxError(message);\n      onError?.(message);\n      swapIntent.current = null;\n      setIsDialogOpen(false);\n    } finally {\n      setLoading(false);\n      stopwatch.stop();\n    }\n  };\n\n  const resetLocal = () => {\n    setInputs({\n      fromChainID:\n        (prefill?.fromChainID as SUPPORTED_CHAINS_IDS) ?? SUPPORTED_CHAINS.BASE,\n      toChainID:\n        (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ??\n        SUPPORTED_CHAINS.OPTIMISM,\n      fromAmount: prefill?.fromAmount ?? undefined,\n      fromToken: undefined,\n      toToken: undefined,\n    });\n    setIsDialogOpen(false);\n    setTxError(null);\n    resetSteps();\n    swapIntent.current = null;\n    setSourceExplorerUrl(\"\");\n    setDestinationExplorerUrl(\"\");\n    setLoading(false);\n    stopwatch.stop();\n  };\n\n  useEffect(() => {\n    if (\n      prefill?.fromToken &&\n      inputs.fromChainID !== undefined &&\n      !inputs.fromToken\n    ) {\n      const src = resolveSourceFromPrefill(\n        swapBalance,\n        inputs.fromChainID,\n        prefill.fromToken\n      );\n      if (src) {\n        setInputs((prev) => ({ ...prev, fromToken: src }));\n      }\n    }\n    if (prefill?.toToken && inputs.toChainID !== undefined && !inputs.toToken) {\n      const dst = resolveDestinationFromPrefill(\n        inputs.toChainID,\n        prefill.toToken\n      );\n      if (dst) {\n        setInputs((prev) => ({ ...prev, toToken: dst }));\n      }\n    }\n  }, [\n    prefill,\n    swapBalance,\n    inputs.fromChainID,\n    inputs.toChainID,\n    inputs.fromToken,\n    inputs.toToken,\n  ]);\n\n  useEffect(() => {\n    if (!swapIntent || isDialogOpen) return;\n    const id = setInterval(async () => {\n      try {\n        const updated = await swapIntent.current?.refresh();\n        if (updated) {\n          swapIntent.current!.intent = updated;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 15000);\n    return () => clearInterval(id);\n  }, [swapIntent.current, isDialogOpen]);\n\n  return {\n    inputs,\n    setInputs,\n    loading,\n    isDialogOpen,\n    setIsDialogOpen,\n    txError,\n    setTxError,\n    timer: stopwatch.seconds,\n    steps,\n    sourceExplorerUrl,\n    destinationExplorerUrl,\n    handleSwap,\n    reset: resetLocal,\n    areInputsValid,\n  };\n};\n\nexport default useExactIn;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-in/hooks/useExactIn.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/exact-out/hooks/useExactOut.ts",
      "content": "import { type RefObject, useEffect, useMemo, useState } from \"react\";\nimport {\n  NexusSDK,\n  SUPPORTED_CHAINS,\n  type SUPPORTED_CHAINS_IDS,\n  type ExactOutSwapInput,\n  NEXUS_EVENTS,\n  type SwapStepType,\n  type UserAsset,\n  type OnSwapIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\nimport { resolveDestinationFromPrefill } from \"../../utils/prefill\";\nimport {\n  useStopwatch,\n  useTransactionSteps,\n  SWAP_EXPECTED_STEPS,\n  useNexusError,\n} from \"../../../common\";\n\ntype DestinationTokenInfo = {\n  tokenAddress: `0x${string}`;\n  decimals: number;\n  logo: string;\n  name: string;\n  symbol: string;\n};\n\ninterface SwapInputs {\n  toAmount?: string;\n  toChainID: SUPPORTED_CHAINS_IDS;\n  toToken?: DestinationTokenInfo;\n}\n\ninterface UseExactOutProps {\n  nexusSDK: NexusSDK | null;\n  address?: Address;\n  swapIntent: RefObject<OnSwapIntentHookData | null>;\n  swapBalance: UserAsset[] | null;\n  fetchBalance: () => Promise<void>;\n  onComplete?: (amount?: string) => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  prefill?: {\n    toAmount?: string;\n    toChainID?: number;\n    toToken?: string;\n  };\n}\n\nconst useExactOut = ({\n  nexusSDK,\n  swapIntent,\n  swapBalance,\n  fetchBalance,\n  onComplete,\n  onStart,\n  onError,\n  prefill,\n}: UseExactOutProps) => {\n  const handleNexusError = useNexusError();\n\n  const [inputs, setInputs] = useState<SwapInputs>({\n    toChainID:\n      (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ?? SUPPORTED_CHAINS.OPTIMISM,\n    toAmount: prefill?.toAmount ?? undefined,\n  });\n  const [loading, setLoading] = useState(false);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [txError, setTxError] = useState<string | null>(null);\n  const [sourceExplorerUrl, setSourceExplorerUrl] = useState<string>(\"\");\n  const [destinationExplorerUrl, setDestinationExplorerUrl] =\n    useState<string>(\"\");\n  const {\n    steps,\n    seed,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<SwapStepType>();\n  const swapCompleted = useMemo(\n    () => steps.some((s) => s.step?.type === \"SWAP_COMPLETE\" && s.completed),\n    [steps]\n  );\n  const stopwatch = useStopwatch({\n    running: isDialogOpen && !swapCompleted,\n    intervalMs: 100,\n  });\n\n  const areInputsValid = useMemo(() => {\n    return (\n      inputs.toChainID !== undefined &&\n      inputs.toToken &&\n      inputs.toAmount &&\n      Number(inputs.toAmount) > 0\n    );\n  }, [inputs]);\n\n  const handleSwap = async () => {\n    if (!nexusSDK || !areInputsValid || !inputs.toToken || !inputs.toAmount)\n      return;\n    try {\n      onStart?.();\n      setLoading(true);\n      setTxError(null);\n      seed(SWAP_EXPECTED_STEPS);\n\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        inputs.toAmount,\n        inputs.toToken.symbol,\n        inputs.toChainID\n      );\n      const swapInput: ExactOutSwapInput = {\n        toAmount: amountBigInt,\n        toChainId: inputs.toChainID,\n        toTokenAddress: inputs.toToken.tokenAddress,\n      };\n      const result = await nexusSDK.swapWithExactOut(swapInput, {\n        onEvent: (event) => {\n          if (event.name === NEXUS_EVENTS.SWAP_STEP_COMPLETE) {\n            const step = event.args as SwapStepType & {\n              explorerURL?: string;\n              completed?: boolean;\n            };\n            if (step?.type === \"SOURCE_SWAP_HASH\" && step.explorerURL) {\n              setSourceExplorerUrl(step.explorerURL);\n            }\n            if (step?.type === \"DESTINATION_SWAP_HASH\" && step.explorerURL) {\n              setDestinationExplorerUrl(step.explorerURL);\n            }\n            onStepComplete(step);\n          }\n        },\n      });\n      if (!result?.success) {\n        throw new Error(result?.error || \"Swap failed\");\n      }\n      onComplete?.(swapIntent.current?.intent?.destination?.amount);\n      swapIntent.current = null;\n\n      await fetchBalance();\n    } catch (error) {\n      const { message } = handleNexusError(error);\n      setTxError(message);\n      onError?.(message);\n      swapIntent.current = null;\n      setIsDialogOpen(false);\n    } finally {\n      setLoading(false);\n      stopwatch.stop();\n    }\n  };\n\n  const resetLocal = () => {\n    setInputs({\n      toChainID:\n        (prefill?.toChainID as SUPPORTED_CHAINS_IDS) ??\n        SUPPORTED_CHAINS.OPTIMISM,\n      toAmount: prefill?.toAmount ?? undefined,\n      toToken: undefined,\n    });\n    setIsDialogOpen(false);\n    setTxError(null);\n    resetSteps();\n    swapIntent.current = null;\n    setSourceExplorerUrl(\"\");\n    setDestinationExplorerUrl(\"\");\n    setLoading(false);\n    stopwatch.stop();\n  };\n\n  useEffect(() => {\n    if (prefill?.toToken && inputs.toChainID !== undefined && !inputs.toToken) {\n      const tok = resolveDestinationFromPrefill(\n        inputs.toChainID,\n        prefill.toToken\n      );\n      if (tok) {\n        setInputs((prev) => ({\n          ...prev,\n          toToken: tok,\n        }));\n      }\n    }\n  }, [prefill, swapBalance, inputs.toChainID, inputs.toToken]);\n\n  useEffect(() => {\n    if (!swapIntent || isDialogOpen) return;\n    const id = setInterval(async () => {\n      try {\n        const updated = await swapIntent.current?.refresh();\n        if (updated) {\n          swapIntent.current!.intent = updated;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 15000);\n    return () => clearInterval(id);\n  }, [swapIntent.current, isDialogOpen]);\n\n  return {\n    inputs,\n    setInputs,\n    loading,\n    isDialogOpen,\n    setIsDialogOpen,\n    txError,\n    setTxError,\n    timer: stopwatch.seconds,\n    steps,\n    sourceExplorerUrl,\n    destinationExplorerUrl,\n    handleSwap,\n    reset: resetLocal,\n  };\n};\n\nexport default useExactOut;\n",
      "type": "registry:component",
      "target": "components/swaps/exact-out/hooks/useExactOut.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/config/destination.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\n\nexport const DESTINATION_SWAP_TOKENS = new Map<\n  number,\n  {\n    decimals: number;\n    logo: string;\n    name: string;\n    symbol: string;\n    tokenAddress: `0x${string}`;\n  }[]\n>([\n  [\n    SUPPORTED_CHAINS.OPTIMISM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0x94b008aa00579c1307b0ef2c499ad98a8ce58e58\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n        name: \"Optimism\",\n        symbol: \"OP\",\n        tokenAddress: \"0x4200000000000000000000000000000000000042\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n        name: \"Aave Token\",\n        symbol: \"AAVE\",\n        tokenAddress: \"0x76fb31fb4af56892a25e32cfc43de717950c9278\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n        name: \"Uniswap\",\n        symbol: \"UNI\",\n        tokenAddress: \"0x6fd9d7ad17242c41f7131d257212c54a0e816691\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.ARBITRUM,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n        name: \"Pepe\",\n        symbol: \"PEPE\",\n        tokenAddress: \"0x25d887ce7a35172c62febfd67a1856f20faebb00\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n        name: \"Lido DAO Token\",\n        symbol: \"LDO\",\n        tokenAddress: \"0x13ad51ed4f1b7e9dc168d8a00cb3f4ddd85efa60\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.SCROLL,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n        name: \"USDT Coin\",\n        symbol: \"USDT\",\n        tokenAddress: \"0xf55bec9cafdbe8730f096aa55dad6d22d44099df\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BASE,\n    [\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n        name: \"Ether\",\n        symbol: \"ETH\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n      {\n        decimals: 6,\n        logo: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694\",\n        name: \"USD Coin\",\n        symbol: \"USDC\",\n        tokenAddress: \"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n        name: \"Dai Stablecoin\",\n        symbol: \"DAI\",\n        tokenAddress: \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n        name: \"LayerZero\",\n        symbol: \"ZRO\",\n        tokenAddress: \"0x6985884c4392d348587b19cb9eaaf157f13271cd\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n        name: \"MANTRA\",\n        symbol: \"OM\",\n        tokenAddress: \"0x3992b27da26848c2b19cea6fd25ad5568b68ab98\",\n      },\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n        name: \"KAITO\",\n        symbol: \"KAITO\",\n        tokenAddress: \"0x98d0baa52b2d063e780de12f615f963fe8537553\",\n      },\n    ],\n  ],\n  [\n    SUPPORTED_CHAINS.BNB,\n    [\n      {\n        decimals: 18,\n        logo: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n        name: \"BNB\",\n        symbol: \"BNB\",\n        tokenAddress: \"0x0000000000000000000000000000000000000000\",\n      },\n    ],\n  ],\n]);\n\nexport const TOKEN_IMAGES: Record<string, string> = {\n  USDC: \"https://coin-images.coingecko.com/coins/images/6319/large/usdc.png\",\n  USDT: \"https://coin-images.coingecko.com/coins/images/35023/large/USDT.png\",\n  WETH: \"https://assets.coingecko.com/coins/images/279/large/ethereum.png?1595348880\",\n  USDS: \"https://assets.coingecko.com/coins/images/39926/standard/usds.webp?1726666683\",\n  SOPH: \"https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png\",\n  KAIA: \"https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png\",\n  BNB: \"https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png\",\n  // Add ETH as fallback for any ETH-related tokens\n  ETH: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628\",\n  // Add common token fallbacks\n  POL: \"https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png\",\n  AVAX: \"https://assets.coingecko.com/coins/images/12559/standard/Avalanche_Circle_RedWhite_Trans.png\",\n  FUEL: \"https://coin-images.coingecko.com/coins/images/279/large/ethereum.png\",\n  HYPE: \"https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png\",\n  // Popular swap tokens\n  DAI: \"https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996\",\n  UNI: \"https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319\",\n  AAVE: \"https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452\",\n  LDO: \"https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326\",\n  PEPE: \"https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776\",\n  OP: \"https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385\",\n  ZRO: \"https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208\",\n  OM: \"https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991\",\n  KAITO:\n    \"https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg\",\n};\n",
      "type": "registry:component",
      "target": "components/swaps/config/destination.ts"
    },
    {
      "path": "registry/nexus-elements/swaps/components/transaction-progress.tsx",
      "content": "import { Check, Circle, Link as LinkIcon, LoaderPinwheel } from \"lucide-react\";\nimport React, { type FC, memo, useMemo } from \"react\";\nimport {\n  type BridgeStepType,\n  type SwapStepType,\n} from \"@avail-project/nexus-core\";\n\ntype ProgressStep = BridgeStepType | SwapStepType;\n\ninterface TransactionProgressProps {\n  timer: number;\n  steps: Array<{ id: number; completed: boolean; step: ProgressStep }>;\n  sourceExplorerUrl?: string;\n  destinationExplorerUrl?: string;\n}\n\ntype DisplayStep = { id: string; label: string; completed: boolean };\n\nconst StepList: FC<{ steps: DisplayStep[]; currentIndex: number }> = memo(\n  ({ steps, currentIndex }) => {\n    return (\n      <div className=\"w-full mt-6 space-y-6\">\n        {steps.map((s, idx) => {\n          const isCompleted = !!s.completed;\n          const isCurrent = currentIndex === -1 ? false : idx === currentIndex;\n\n          let rightIcon = <Circle className=\"size-5 text-muted-foreground\" />;\n          if (isCompleted) {\n            rightIcon = <Check className=\"size-5 text-green-600\" />;\n          } else if (isCurrent) {\n            rightIcon = (\n              <LoaderPinwheel className=\"size-5 animate-spin text-muted-foreground\" />\n            );\n          }\n\n          return (\n            <div\n              key={s.id}\n              className=\"flex items-center justify-between w-full\"\n            >\n              <div className=\"flex items-center gap-x-3\">\n                <span className=\"text-base font-semibold\">{s.label}</span>\n              </div>\n              {rightIcon}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n);\nStepList.displayName = \"StepList\";\n\nconst TransactionProgress: FC<TransactionProgressProps> = ({\n  timer,\n  steps,\n  sourceExplorerUrl,\n  destinationExplorerUrl,\n}) => {\n  const { effectiveSteps, currentIndex, allCompleted } = useMemo(() => {\n    const completedTypes = new Set<string | undefined>(\n      steps?.filter((s) => s?.completed).map((s) => s?.step?.type)\n    );\n    // Consider only steps that were actually emitted by the SDK (ignore pre-seeded placeholders)\n    const eventfulTypes = new Set<string | undefined>(\n      steps\n        ?.filter((s) => {\n          const st = s?.step ?? {};\n          return (\n            \"explorerURL\" in st || \"chain\" in st || \"completed\" in st // present when event args were merged into step\n          );\n        })\n        .map((s) => s?.step?.type)\n    );\n    const hasAny = (types: string[]) =>\n      types.some((t) => completedTypes.has(t));\n    const sawAny = (types: string[]) => types.some((t) => eventfulTypes.has(t));\n\n    const intentVerified = hasAny([\"DETERMINING_SWAP\", \"SWAP_START\"]);\n\n    // If the flow does not include SOURCE_* steps, consider it implicitly collected\n    const sourceStepTypes = [\n      \"CREATE_PERMIT_EOA_TO_EPHEMERAL\",\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n      \"SOURCE_SWAP_BATCH_TX\",\n      \"SOURCE_SWAP_HASH\",\n    ];\n    const collectedOnSources =\n      (sawAny(sourceStepTypes) &&\n        hasAny([\"SOURCE_SWAP_HASH\", \"SOURCE_SWAP_BATCH_TX\"])) ||\n      (!sawAny(sourceStepTypes) &&\n        hasAny([\n          \"DESTINATION_SWAP_BATCH_TX\",\n          \"DESTINATION_SWAP_HASH\",\n          \"SWAP_COMPLETE\",\n        ]));\n\n    const filledOnDestination = hasAny([\n      \"DESTINATION_SWAP_HASH\",\n      \"DESTINATION_SWAP_BATCH_TX\",\n      \"SWAP_COMPLETE\",\n    ]);\n\n    const displaySteps: DisplayStep[] = [\n      { id: \"intent\", label: \"Intent verified\", completed: intentVerified },\n      {\n        id: \"collected\",\n        label: \"Collected on sources\",\n        completed: collectedOnSources,\n      },\n      {\n        id: \"filled\",\n        label: \"Filled on destination\",\n        completed: filledOnDestination,\n      },\n    ];\n\n    // Mark overall completion ONLY when the SDK reports SWAP_COMPLETE\n    const done = hasAny([\"SWAP_COMPLETE\"]);\n    const current = displaySteps.findIndex((st) => !st.completed);\n    return {\n      effectiveSteps: displaySteps,\n      currentIndex: current,\n      allCompleted: done,\n    };\n  }, [steps]);\n\n  return (\n    <div className=\"w-full flex flex-col items-center\">\n      <div className=\"flex flex-col items-center gap-y-3\">\n        {allCompleted ? (\n          <Check className=\"size-6 text-green-600\" />\n        ) : (\n          <LoaderPinwheel className=\"size-6 animate-spin\" />\n        )}\n        <p>{allCompleted ? \"Swap Completed\" : \"Swap In Progress...\"}</p>\n        <div className=\"flex items-center justify-center w-full\">\n          <span className=\"text-2xl font-semibold\">{Math.floor(timer)}</span>\n          <span className=\"text-base font-semibold\">.</span>\n          <span className=\"text-base font-semibold\">\n            {String(Math.floor((timer % 1) * 1000)).padStart(3, \"0\")}s\n          </span>\n        </div>\n      </div>\n\n      <StepList steps={effectiveSteps} currentIndex={currentIndex} />\n\n      <div className=\"mt-6 w-full flex items-center justify-center gap-x-4\">\n        {sourceExplorerUrl && (\n          <a\n            href={sourceExplorerUrl}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n            className=\"underline text-sm inline-flex items-center gap-x-1\"\n          >\n            <LinkIcon className=\"size-3\" /> View Source Tx\n          </a>\n        )}\n        {destinationExplorerUrl && (\n          <a\n            href={destinationExplorerUrl}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n            className=\"underline text-sm inline-flex items-center gap-x-1\"\n          >\n            <LinkIcon className=\"size-3\" /> View Destination Tx\n          </a>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TransactionProgress;\n",
      "type": "registry:component",
      "target": "components/swaps/components/transaction-progress.tsx"
    },
    {
      "path": "registry/nexus-elements/swaps/utils/prefill.ts",
      "content": "import type {\n  SUPPORTED_CHAINS_IDS,\n  UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { DESTINATION_SWAP_TOKENS, TOKEN_IMAGES } from \"../config/destination\";\n\nexport function resolveSourceFromPrefill(\n  unifiedBalance: UserAsset[] | null | undefined,\n  fromChainID: SUPPORTED_CHAINS_IDS | undefined,\n  prefillTokenAddress: string | undefined\n):\n  | {\n      contractAddress: `0x${string}`;\n      decimals: number;\n      logo: string;\n      name: string;\n      symbol: string;\n    }\n  | undefined {\n  if (!unifiedBalance || !fromChainID || !prefillTokenAddress) return undefined;\n  const targetAddr = prefillTokenAddress.toLowerCase();\n  for (const a of unifiedBalance) {\n    const candidate = a.breakdown?.find(\n      (b) =>\n        b.contractAddress?.toLowerCase() === targetAddr &&\n        (b.chain?.id as number | undefined) === fromChainID\n    ) as\n      | {\n          chain?: { id?: number };\n          contractAddress: `0x${string}`;\n          decimals?: number;\n        }\n      | undefined;\n    if (candidate) {\n      return {\n        contractAddress: candidate.contractAddress,\n        decimals: candidate.decimals ?? a.decimals,\n        logo: TOKEN_IMAGES[a.symbol] ?? \"\",\n        name: a.symbol,\n        symbol: a.symbol,\n      };\n    }\n  }\n  return undefined;\n}\n\nexport function resolveDestinationFromPrefill(\n  toChainID: SUPPORTED_CHAINS_IDS | undefined,\n  prefillTokenAddress: string | undefined\n):\n  | {\n      tokenAddress: `0x${string}`;\n      decimals: number;\n      logo: string;\n      name: string;\n      symbol: string;\n    }\n  | undefined {\n  if (!toChainID || !prefillTokenAddress) return undefined;\n  const list = DESTINATION_SWAP_TOKENS.get(toChainID);\n  const targetAddr = prefillTokenAddress.toLowerCase();\n  return list?.find((t) => t.tokenAddress?.toLowerCase() === targetAddr);\n}\n",
      "type": "registry:component",
      "target": "components/swaps/utils/prefill.ts"
    }
  ]
}