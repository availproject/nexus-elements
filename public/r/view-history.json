{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "view-history",
  "type": "registry:component",
  "title": "View History",
  "description": "A simple component built with Nexus to display view history",
  "dependencies": [
    "@avail-project/nexus-core@1.0.0-beta.64",
    "lucide-react"
  ],
  "registryDependencies": [
    "https://elements.nexus.availproject.org/r/badge.json",
    "https://elements.nexus.availproject.org/r/button.json",
    "https://elements.nexus.availproject.org/r/card.json",
    "https://elements.nexus.availproject.org/r/dialog.json",
    "https://elements.nexus.availproject.org/r/nexus-provider.json",
    "https://elements.nexus.availproject.org/r/separator.json",
    "https://elements.nexus.availproject.org/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/nexus-elements/view-history/hooks/useViewHistory.ts",
      "content": "import { type RFF } from \"@avail-project/nexus-core\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nconst ITEMS_PER_PAGE = 10;\n\nfunction formatExpiryDate(timestamp: number) {\n  const date = new Date(timestamp * 1000);\n  const formatted = date.toLocaleString(\"en-US\", {\n    month: \"short\",\n    day: \"2-digit\",\n    year: \"numeric\",\n  });\n  return formatted.replace(\" \", \", \");\n}\n\nconst useViewHistory = () => {\n  const { nexusSDK } = useNexus();\n  const [history, setHistory] = useState<RFF[] | null>(null);\n  const [displayedHistory, setDisplayedHistory] = useState<RFF[]>([]);\n  const [page, setPage] = useState(0);\n  const [hasMore, setHasMore] = useState(true);\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\n  const [sentinelNode, setSentinelNode] = useState<HTMLDivElement | null>(null);\n\n  const observerTarget = useCallback((node: HTMLDivElement | null) => {\n    setSentinelNode(node);\n  }, []);\n\n  const fetchIntentHistory = async () => {\n    try {\n      const history = await nexusSDK?.getMyIntents();\n      if (history) {\n        setHistory(history);\n        const firstPage = history.slice(0, ITEMS_PER_PAGE);\n        setDisplayedHistory(firstPage);\n        setHasMore(history.length > ITEMS_PER_PAGE);\n      }\n    } catch (error) {\n      console.error(\"Error fetching intent history:\", error);\n    }\n  };\n\n  useEffect(() => {\n    if (!history) {\n      fetchIntentHistory();\n    }\n  }, [history]);\n\n  const loadMore = useCallback(() => {\n    if (!history || isLoadingMore || !hasMore) return;\n    setIsLoadingMore(true);\n\n    setTimeout(() => {\n      const nextPage = page + 1;\n      const startIndex = nextPage * ITEMS_PER_PAGE;\n      const endIndex = startIndex + ITEMS_PER_PAGE;\n      const newItems = history.slice(startIndex, endIndex);\n\n      if (newItems.length > 0) {\n        setDisplayedHistory((prev) => [...prev, ...newItems]);\n        setPage(nextPage);\n        setHasMore(endIndex < history.length);\n      } else {\n        setHasMore(false);\n      }\n\n      setIsLoadingMore(false);\n    }, 300);\n  }, [history, page, isLoadingMore, hasMore]);\n\n  useEffect(() => {\n    if (!sentinelNode) {\n      return;\n    }\n\n    const rootElement = sentinelNode.parentElement;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && hasMore && !isLoadingMore) {\n          loadMore();\n        }\n      },\n      { threshold: 0.1, root: rootElement ?? null }\n    );\n\n    observer.observe(sentinelNode);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [sentinelNode, loadMore, hasMore, isLoadingMore, displayedHistory.length]);\n\n  const getStatus = (pastIntent: RFF) => {\n    if (pastIntent?.fulfilled) {\n      return \"Fulfilled\";\n    } else if (pastIntent?.deposited) {\n      return \"Deposited\";\n    } else if (pastIntent?.refunded) {\n      return \"Refunded\";\n    } else {\n      return \"Failed\";\n    }\n  };\n\n  return {\n    history,\n    displayedHistory,\n    page,\n    hasMore,\n    isLoadingMore,\n    getStatus,\n    observerTarget,\n    ITEMS_PER_PAGE,\n    formatExpiryDate,\n  };\n};\n\nexport default useViewHistory;\n",
      "type": "registry:component",
      "target": "components/view-history/hooks/useViewHistory.ts"
    },
    {
      "path": "registry/nexus-elements/view-history/view-history.tsx",
      "content": "\"use client\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n  DialogTitle,\n} from \"@/registry/nexus-elements/ui/dialog\";\nimport { Clock, LoaderPinwheel, SquareArrowOutUpRight } from \"lucide-react\";\nimport { TOKEN_METADATA, type RFF } from \"@avail-project/nexus-core\";\nimport { cn } from \"@/lib/utils\";\nimport { Badge } from \"@/registry/nexus-elements/ui/badge\";\nimport { Button } from \"@/registry/nexus-elements/ui/button\";\nimport { Card } from \"@/registry/nexus-elements/ui/card\";\nimport { Separator } from \"@/registry/nexus-elements/ui/separator\";\nimport useViewHistory from \"./hooks/useViewHistory\";\n\nconst SourceChains = ({ sources }: { sources: RFF[\"sources\"] }) => {\n  return (\n    <div className=\"flex items-center\">\n      {sources?.map((source, index) => (\n        <div\n          key={source?.chain?.id}\n          className={cn(\n            \"rounded-full transition-transform hover:scale-110\",\n            index > 0 && \"-ml-2\"\n          )}\n          style={{ zIndex: sources.length - index }}\n        >\n          <img\n            src={source?.chain?.logo}\n            alt={source?.chain?.name}\n            width={24}\n            height={24}\n            className=\"rounded-full\"\n          />\n        </div>\n      ))}\n    </div>\n  );\n};\n\nconst StatusBadge = ({ status }: { status: string }) => {\n  const getVariant = (status: string) => {\n    if (status === \"Fulfilled\") {\n      return \"default\";\n    } else if (status === \"Deposited\") {\n      return \"secondary\";\n    } else if (status === \"Refunded\") {\n      return \"outline\";\n    } else if (status === \"Failed\") {\n      return \"destructive\";\n    } else {\n      return \"default\";\n    }\n  };\n\n  return (\n    <Badge variant={getVariant(status)} className=\"px-3 py-1\">\n      <p className=\"text-xs font-semibold tracking-wide\">{status}</p>\n    </Badge>\n  );\n};\n\nconst DestinationToken = ({\n  destination,\n}: {\n  destination: RFF[\"destinations\"];\n}) => {\n  return (\n    <div className=\"flex items-center\">\n      {destination.map((dest, index) => (\n        <div\n          key={dest.token.symbol}\n          className={cn(\n            \"rounded-full transition-transform hover:scale-110\",\n            index > 0 && \"-ml-2\"\n          )}\n          style={{ zIndex: destination.length - index }}\n        >\n          <img\n            src={TOKEN_METADATA[dest.token.symbol]?.icon ?? \"\"}\n            alt={TOKEN_METADATA[dest.token.symbol]?.name}\n            width={24}\n            height={24}\n            className=\"rounded-full\"\n          />\n        </div>\n      ))}\n    </div>\n  );\n};\n\nconst ViewHistory = ({\n  viewAsModal = true,\n  className,\n}: {\n  viewAsModal?: boolean;\n  className?: string;\n}) => {\n  const {\n    history,\n    displayedHistory,\n    hasMore,\n    isLoadingMore,\n    getStatus,\n    observerTarget,\n    ITEMS_PER_PAGE,\n    formatExpiryDate,\n  } = useViewHistory();\n\n  const renderHistoryContent = () => {\n    if (displayedHistory.length > 0) {\n      return (\n        <>\n          {displayedHistory?.map((pastIntent) => (\n            <Card\n              key={pastIntent.id}\n              className=\"p-4 hover:shadow-md transition-shadow duration-200 border-border/50 gap-3\"\n            >\n              <div className=\"flex items-start justify-between gap-4\">\n                <div className=\"flex items-center gap-3\">\n                  <DestinationToken destination={pastIntent?.destinations} />\n                  <div className=\"flex flex-col\">\n                    <p className=\"text-sm font-medium\">\n                      {pastIntent?.destinations\n                        .map((d) => d?.token?.symbol)\n                        .join(\", \")}\n                    </p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      Intent #{pastIntent?.id}\n                    </p>\n                  </div>\n                </div>\n                <StatusBadge status={getStatus(pastIntent)} />\n              </div>\n\n              <Separator className=\"my-1\" />\n\n              <div className=\"flex flex-col sm:flex-row  items-start sm:items-center justify-between gap-4\">\n                <div className=\"flex items-center justify-between gap-x-3 flex-1 w-full sm:min-w-fit\">\n                  <SourceChains sources={pastIntent?.sources} />\n                  <div className=\"flex items-center gap-2 text-muted-foreground\">\n                    <div className=\"h-px w-8 bg-border\" />\n                    <span className=\"text-xs\">â†’</span>\n                    <div className=\"h-px w-8 bg-border\" />\n                  </div>\n                  <div className=\"rounded-full hover:scale-110\">\n                    <img\n                      src={pastIntent?.destinationChain?.logo ?? \"\"}\n                      alt={pastIntent?.destinationChain?.name}\n                      width={24}\n                      height={24}\n                      className=\"rounded-full\"\n                    />\n                  </div>\n                </div>\n\n                <div className=\"flex items-center justify-between sm:justify-end  gap-x-2 w-full\">\n                  <div className=\"text-left sm:text-right\">\n                    <p className=\"text-xs text-muted-foreground\">Expiry</p>\n                    <p className=\"text-xs font-medium\">\n                      {formatExpiryDate(pastIntent?.expiry)}\n                    </p>\n                  </div>\n                  <a\n                    href={pastIntent?.explorerUrl}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                  >\n                    <Button variant=\"outline\" size=\"icon\">\n                      <SquareArrowOutUpRight className=\"size-4\" />\n                    </Button>\n                  </a>\n                </div>\n              </div>\n            </Card>\n          ))}\n\n          {hasMore && (\n            <div ref={observerTarget} className=\"flex justify-center py-4\">\n              {isLoadingMore && (\n                <div className=\"flex items-center gap-2 text-muted-foreground\">\n                  <LoaderPinwheel className=\"size-4 animate-spin\" />\n                  <span className=\"text-sm\">Loading more...</span>\n                </div>\n              )}\n            </div>\n          )}\n\n          {!hasMore && displayedHistory?.length > ITEMS_PER_PAGE && (\n            <div className=\"flex justify-center py-4\">\n              <p className=\"text-sm text-muted-foreground\">\n                No more transactions to load\n              </p>\n            </div>\n          )}\n        </>\n      );\n    }\n\n    if (history === null) {\n      return (\n        <div className=\"flex flex-col items-center justify-center py-16 gap-4\">\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-primary/10 blur-xl rounded-full\" />\n            <LoaderPinwheel className=\"relative animate-spin size-12 text-primary\" />\n          </div>\n          <div className=\"text-center space-y-1\">\n            <p className=\"text-base font-medium\">Loading your history</p>\n            <p className=\"text-sm text-muted-foreground\">\n              Fetching your past transactions...\n            </p>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col items-center justify-center py-16 gap-4\">\n        <Clock className=\"size-16 text-muted-foreground/30\" />\n        <div className=\"text-center space-y-1\">\n          <p className=\"text-base font-medium\">No history yet</p>\n          <p className=\"text-sm text-muted-foreground\">\n            Your transaction history will appear here\n          </p>\n        </div>\n      </div>\n    );\n  };\n\n  if (!viewAsModal) {\n    return (\n      <div className=\"flex flex-col gap-y-3 max-h-96 no-scrollbar overflow-y-auto w-full max-w-md\">\n        {renderHistoryContent()}\n      </div>\n    );\n  }\n\n  return (\n    <Dialog>\n      <DialogTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          className={cn(\"relative group\", className)}\n        >\n          <Clock className=\"size-5 text-primary transition-transform group-hover:scale-110\" />\n        </Button>\n      </DialogTrigger>\n      <DialogContent className=\"max-w-2xl flex flex-col\">\n        <DialogHeader>\n          <DialogTitle className=\"text-2xl font-semibold\">\n            Transaction History\n          </DialogTitle>\n        </DialogHeader>\n        <div className=\"flex flex-col gap-y-3 max-h-96 no-scrollbar overflow-y-auto w-full\">\n          {renderHistoryContent()}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default ViewHistory;\n",
      "type": "registry:component",
      "target": "components/view-history/view-history.tsx"
    },
    {
      "path": "registry/nexus-elements/common/components/ErrorBoundary.tsx",
      "content": "\"use client\";\n\nimport { Component, type ErrorInfo, type ReactNode } from \"react\";\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n}\n\n/**\n * Error boundary component that catches JavaScript errors in child components.\n * Displays a fallback UI instead of crashing the entire widget.\n *\n * @example\n * <ErrorBoundary\n *   fallback={<div>Something went wrong</div>}\n *   onError={(error) => console.error(error)}\n * >\n *   <MyComponent />\n * </ErrorBoundary>\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\"ErrorBoundary caught an error:\", error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n          <div className=\"text-destructive font-medium mb-2\">\n            Something went wrong\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            An unexpected error occurred. Please try again.\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false, error: null })}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * A more specific error boundary for widget containers with reset capability.\n */\ninterface WidgetErrorBoundaryProps extends ErrorBoundaryProps {\n  widgetName?: string;\n  onReset?: () => void;\n}\n\nexport class WidgetErrorBoundary extends Component<\n  WidgetErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: WidgetErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\n      `WidgetErrorBoundary [${this.props.widgetName ?? \"Unknown\"}]:`,\n      error,\n      errorInfo\n    );\n    this.props.onError?.(error, errorInfo);\n  }\n\n  handleReset = (): void => {\n    this.props.onReset?.();\n    this.setState({ hasError: false, error: null });\n  };\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center bg-destructive/5 rounded-lg border border-destructive/20\">\n          <div className=\"text-destructive font-medium mb-2\">\n            {this.props.widgetName\n              ? `${this.props.widgetName} encountered an error`\n              : \"Widget error\"}\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            {this.state.error?.message || \"An unexpected error occurred.\"}\n          </p>\n          <button\n            onClick={this.handleReset}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Reset widget\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/components/ErrorBoundary.tsx"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedCallback.ts",
      "content": "import { useEffect, useMemo, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype AnyFn = (...args: any[]) => any;\n\nexport interface Debounced<T extends AnyFn> {\n  (...args: Parameters<T>): void;\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Returns a debounced function that delays invoking `fn` until after `delay`\n * milliseconds have elapsed since the last call.\n */\nexport function useDebouncedCallback<T extends AnyFn>(\n  fn: T,\n  delay: number\n): Debounced<T> {\n  const latest = useStableCallback(fn);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  const cancel = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const flush = () => {\n    if (timerRef.current && lastArgsRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n       \n      latest(...lastArgsRef.current);\n      lastArgsRef.current = null;\n    }\n  };\n\n  // cancel when delay changes/unmounts\n  useEffect(() => cancel, [delay]);\n\n  return useMemo(() => {\n    const debounced = ((...args: Parameters<T>) => {\n      lastArgsRef.current = args;\n      cancel();\n      timerRef.current = setTimeout(() => {\n         \n        latest(...lastArgsRef.current!);\n        lastArgsRef.current = null;\n        timerRef.current = null;\n      }, delay);\n    }) as Debounced<T>;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, latest]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedValue.ts",
      "content": "import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\n\n/**\n * Derives a debounced value from an input value and delay.\n */\nexport function useDebouncedValue<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState<T>(value);\n  const setter = useDebouncedCallback((v: T) => setDebounced(v), delay);\n\n  useEffect(() => {\n    setter(value);\n    return setter.cancel;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, delay]);\n\n  return debounced;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedValue.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useInterval.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ninterface UseIntervalOptions {\n  enabled?: boolean;\n  immediate?: boolean;\n}\n\n/**\n * Declarative setInterval with pause/resume and latest-callback semantics.\n * Pass delay=null to pause.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options: UseIntervalOptions = {}\n) {\n  const { enabled = true, immediate = false } = options;\n  const savedCallback = useStableCallback(callback);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (!enabled || delay == null) return;\n    if (immediate) {\n      savedCallback();\n    }\n    intervalRef.current = setInterval(savedCallback, delay);\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [delay, enabled, immediate, savedCallback]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useInterval.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useLatest.ts",
      "content": "import { useRef, useLayoutEffect } from \"react\";\n\n/**\n * Returns a ref that always contains the latest value.\n * Useful for accessing current values in callbacks without causing re-renders.\n *\n * @example\n * const countRef = useLatest(count);\n * const handleClick = useCallback(() => {\n *   console.log(countRef.current); // Always the latest count\n * }, []); // No dependency needed!\n */\nexport function useLatest<T>(value: T): React.MutableRefObject<T> {\n  const ref = useRef<T>(value);\n\n  // Use useLayoutEffect to update synchronously before any effects run\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n\n  return ref;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useLatest.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useNexusError.ts",
      "content": "import { NexusError } from \"@avail-project/nexus-core\";\n\nfunction handler(err: unknown) {\n  if (err instanceof NexusError) {\n    return {\n      code: err?.code,\n      message: err?.message,\n      context: err?.data?.context,\n      details: err?.data?.details,\n    };\n  } else {\n    console.error(\"Unexpected error:\", err);\n    return {\n      code: \"unexpected_error\",\n      message: \"Oops! Something went wrong. Please try again.\",\n      context: undefined,\n      details: undefined,\n    };\n  }\n}\nexport function useNexusError() {\n  return handler;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useNexusError.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/usePolling.ts",
      "content": "import { useRef } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { useStableCallback } from \"./useStableCallback\";\n\n/**\n * Declarative polling with in-flight protection (no overlap).\n * When enabled becomes true, an immediate run is executed,\n * followed by interval-based runs.\n */\nexport function usePolling(\n  enabled: boolean,\n  fn: () => Promise<void> | void,\n  intervalMs: number\n) {\n  const inFlightRef = useRef(false);\n  const wrapped = useStableCallback(async () => {\n    if (inFlightRef.current) return;\n    try {\n      inFlightRef.current = true;\n      await fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      inFlightRef.current = false;\n    }\n  });\n\n  useInterval(wrapped, enabled ? intervalMs : null, {\n    enabled,\n    immediate: enabled,\n  });\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/usePolling.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStableCallback.ts",
      "content": "import { useCallback, useRef } from \"react\";\n\n/**\n * Returns a stable function identity that always calls the latest implementation.\n * Useful when passing callbacks to memoized children without re-creating handlers.\n */\nexport function useStableCallback<Args extends readonly unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const fnRef = useRef<(...args: Args) => Return>(fn);\n  fnRef.current = fn;\n\n   \n  const stable = useCallback(\n    ((...args: Args) => {\n      return fnRef.current(...args);\n    }) as (...args: Args) => Return,\n    []\n  );\n\n  return stable;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStableCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStopwatch.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\ninterface UseStopwatchOptions {\n  running?: boolean;\n  intervalMs?: number;\n}\n\n/**\n * Simple stopwatch that increments elapsed seconds while running.\n * Designed to replace scattered timer effects.\n */\nexport function useStopwatch(options: UseStopwatchOptions = {}) {\n  const { running = false, intervalMs = 100 } = options;\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const reset = () => {\n    setElapsedSeconds(0);\n  };\n\n  const stop = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const start = () => {\n    if (timerRef.current) return;\n    timerRef.current = setInterval(() => {\n      // 1s == 1000ms; we add fractional seconds per tick\n      setElapsedSeconds((prev) => prev + intervalMs / 1000);\n    }, intervalMs);\n  };\n\n  useEffect(() => {\n    if (running) {\n      start();\n    } else {\n      stop();\n    }\n    return stop;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [running, intervalMs]);\n\n  return {\n    seconds: elapsedSeconds,\n    start,\n    stop,\n    reset,\n    running: Boolean(timerRef.current),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStopwatch.ts"
    },
    {
      "path": "registry/nexus-elements/common/index.ts",
      "content": "export * from \"./hooks/useStopwatch\";\nexport * from \"./hooks/usePolling\";\nexport * from \"./hooks/useInterval\";\nexport * from \"./hooks/useStableCallback\";\nexport * from \"./hooks/useLatest\";\nexport * from \"./hooks/useDebouncedValue\";\nexport * from \"./hooks/useDebouncedCallback\";\nexport * from \"./hooks/useNexusError\";\nexport * from \"./tx/types\";\nexport * from \"./tx/steps\";\nexport * from \"./tx/useTransactionSteps\";\nexport * from \"./utils/constant\";\nexport * from \"./components/ErrorBoundary\";\n",
      "type": "registry:component",
      "target": "components/common/index.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/steps.ts",
      "content": "import type { SwapStepType } from \"@avail-project/nexus-core\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\n\n/**\n * Predefined expected steps for swaps to seed UI before events arrive.\n * Kept here to avoid duplication across exact-in and exact-out hooks.\n */\nexport const SWAP_EXPECTED_STEPS: SwapStepType[] = [\n  { type: \"SWAP_START\", typeID: \"SWAP_START\" } as SwapStepType,\n  { type: \"DETERMINING_SWAP\", typeID: \"DETERMINING_SWAP\" } as SwapStepType,\n  {\n    type: \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    typeID:\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_BATCH_TX\",\n    typeID: \"SOURCE_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_HASH\",\n    typeID: \"SOURCE_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"RFF_ID\", typeID: \"RFF_ID\" } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_BATCH_TX\",\n    typeID: \"DESTINATION_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_HASH\",\n    typeID: \"DESTINATION_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"SWAP_COMPLETE\", typeID: \"SWAP_COMPLETE\" } as SwapStepType,\n];\n\nexport function seedSteps<T>(expected: T[]): Array<GenericStep<T>> {\n  return expected.map((st, index) => ({\n    id: index,\n    completed: false,\n    step: st,\n  }));\n}\n\nexport function computeAllCompleted<T>(steps: Array<GenericStep<T>>): boolean {\n  return steps.length > 0 && steps.every((s) => s.completed);\n}\n\n/**\n * Replace the current list of steps with a new list, preserving completion\n * for any steps that were already marked completed (matched by key).\n */\nexport function mergeStepsList<T>(\n  prev: Array<GenericStep<T>>,\n  list: T[]\n): Array<GenericStep<T>> {\n  const completedKeys = new Set<string>();\n  for (const prevStep of prev) {\n    if (prevStep.completed) {\n      completedKeys.add(getStepKey(prevStep.step));\n    }\n  }\n  const next: Array<GenericStep<T>> = [];\n  for (let index = 0; index < list.length; index++) {\n    const step = list[index];\n    const key = getStepKey(step);\n    next.push({\n      id: index,\n      completed: completedKeys.has(key),\n      step,\n    });\n  }\n  return next;\n}\n\n/**\n * Mark a step complete in-place; if the step doesn't yet exist, append it.\n */\nexport function mergeStepComplete<T>(\n  prev: Array<GenericStep<T>>,\n  step: T\n): Array<GenericStep<T>> {\n  const key = getStepKey(step);\n  const updated: Array<GenericStep<T>> = [];\n  let found = false;\n  for (const s of prev) {\n    if (getStepKey(s.step) === key) {\n      updated.push({ ...s, completed: true, step: { ...s.step, ...step } });\n      found = true;\n    } else {\n      updated.push(s);\n    }\n  }\n  if (!found) {\n    updated.push({\n      id: updated.length,\n      completed: true,\n      step,\n    });\n  }\n  return updated;\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/steps.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/types.ts",
      "content": "export type TransactionStatus =\n  | \"idle\"\n  | \"preview\"\n  | \"awaiting-approval\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\nexport type GenericStep<TStep> = {\n  id: number;\n  completed: boolean;\n  step: TStep;\n};\n\n/**\n * Normalizes a step to a stable key. Prefers typeID, then type, otherwise JSON.\n */\nexport function getStepKey(step: any): string {\n  if (!step) return \"\";\n  if (typeof step.typeID === \"string\" && step.typeID.length > 0) {\n    return step.typeID;\n  }\n  if (typeof step.type === \"string\" && step.type.length > 0) {\n    return step.type;\n  }\n  try {\n    return JSON.stringify(step);\n  } catch {\n    return String(step);\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/types.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/useTransactionSteps.ts",
      "content": "import { useMemo, useRef, useState } from \"react\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\nimport {\n  computeAllCompleted,\n  mergeStepComplete,\n  mergeStepsList,\n  seedSteps,\n} from \"./steps\";\n\ninterface UseTransactionStepsOptions<T> {\n  expected?: T[];\n}\n\n/**\n * Manages transaction steps with utilities to seed from expected steps,\n * replace the list on \"steps list\" events, and mark individual steps complete.\n */\nexport function useTransactionSteps<\n  T extends { typeID?: string; type?: string }\n>(options: UseTransactionStepsOptions<T> = {}) {\n  const { expected } = options;\n  const [steps, setSteps] = useState<Array<GenericStep<T>>>(() =>\n    expected ? seedSteps(expected) : []\n  );\n  const lastSignatureRef = useRef<string>(\"\");\n\n  const onStepsList = (list: T[]) => {\n    const signature = list.map((step) => getStepKey(step)).join(\"|\");\n    if (lastSignatureRef.current === signature) {\n      setSteps((prev) => mergeStepsList(prev, list));\n      return;\n    }\n    lastSignatureRef.current = signature;\n    setSteps((prev) => mergeStepsList(prev, list));\n  };\n\n  const onStepComplete = (step: T) => {\n    setSteps((prev) => mergeStepComplete(prev, step));\n  };\n\n  const seed = (expectedSteps: T[]) => {\n    setSteps(seedSteps(expectedSteps));\n  };\n\n  const reset = () => {\n    setSteps(expected ? seedSteps(expected) : []);\n    lastSignatureRef.current = \"\";\n  };\n\n  const allCompleted = useMemo(() => computeAllCompleted(steps), [steps]);\n\n  return {\n    steps,\n    allCompleted,\n    onStepsList,\n    onStepComplete,\n    seed,\n    reset,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/useTransactionSteps.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/constant.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\nimport { formatUnits, parseUnits } from \"viem\";\n\nexport const SHORT_CHAIN_NAME: Record<number, string> = {\n  [SUPPORTED_CHAINS.ETHEREUM]: \"Ethereum\",\n  [SUPPORTED_CHAINS.BASE]: \"Base\",\n  [SUPPORTED_CHAINS.ARBITRUM]: \"Arbitrum\",\n  [SUPPORTED_CHAINS.OPTIMISM]: \"Optimism\",\n  [SUPPORTED_CHAINS.POLYGON]: \"Polygon\",\n  [SUPPORTED_CHAINS.AVALANCHE]: \"Avalanche\",\n  [SUPPORTED_CHAINS.SCROLL]: \"Scroll\",\n  [SUPPORTED_CHAINS.SOPHON]: \"Sophon\",\n  [SUPPORTED_CHAINS.KAIA]: \"Kaia\",\n  [SUPPORTED_CHAINS.BNB]: \"BNB\",\n  [SUPPORTED_CHAINS.MONAD]: \"Monad\",\n  [SUPPORTED_CHAINS.HYPEREVM]: \"HyperEVM\",\n  [SUPPORTED_CHAINS.CITREA]: \"Citrea\",\n  // [SUPPORTED_CHAINS.TRON]: \"Tron\",\n  [SUPPORTED_CHAINS.SEPOLIA]: \"Sepolia\",\n  [SUPPORTED_CHAINS.BASE_SEPOLIA]: \"Base Sepolia\",\n  [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: \"Arbitrum Sepolia\",\n  [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: \"Optimism Sepolia\",\n  [SUPPORTED_CHAINS.POLYGON_AMOY]: \"Polygon Amoy\",\n  [SUPPORTED_CHAINS.MONAD_TESTNET]: \"Monad Testnet\",\n  // [SUPPORTED_CHAINS.TRON_SHASTA]: \"Tron Shasta\",\n} as const;\n\nconst DEFAULT_SAFETY_MARGIN = 0.01; // 1%\n\n/**\n * Compute an amount string for fraction buttons (25%, 50%, 75%, 100%).\n *\n * @param balanceStr - user's balance as a human decimal string (e.g. \"12.345\") OR as base-unit integer string if `balanceIsBaseUnits` true\n * @param fraction - fraction e.g. 0.25, 0.5, 0.75, 1\n * @param decimals - token decimals (6 for USDC/USDT, 18 for ETH)\n * @param safetyMargin - 0.01 for 1% default\n * @param balanceIsBaseUnits - if true, balanceStr is already base units integer string (wei / smallest unit)\n * @returns decimal string clipped to token decimals (rounded down)\n */\nexport function computeAmountFromFraction(\n  balanceStr: string,\n  fraction: number,\n  decimals: number,\n  safetyMargin = DEFAULT_SAFETY_MARGIN,\n  balanceIsBaseUnits = false,\n): string {\n  if (!balanceStr) return \"0\";\n\n  // parse balance into base units (BigInt)\n  const balanceUnits: bigint = balanceIsBaseUnits\n    ? BigInt(balanceStr)\n    : parseUnits(balanceStr, decimals);\n\n  if (balanceUnits === BigInt(0)) return \"0\";\n\n  // Use an integer precision multiplier to avoid FP issues\n  const PREC = 1_000_000; // 1e6 precision for fraction & safety margin\n  const safetyMul = BigInt(Math.max(0, Math.floor((1 - safetyMargin) * PREC))); // (1 - safetyMargin) * PREC\n  const fractionMul = BigInt(Math.max(0, Math.floor(fraction * PREC))); // fraction * PREC\n\n  // Apply safety margin: floor(balance * (1 - safetyMargin))\n  const maxAfterSafety = (balanceUnits * safetyMul) / BigInt(PREC);\n\n  // Apply fraction and floor: floor(maxAfterSafety * fraction)\n  let desiredUnits = (maxAfterSafety * fractionMul) / BigInt(PREC);\n\n  // Extra clamp just in case\n  if (desiredUnits > balanceUnits) desiredUnits = balanceUnits;\n  if (desiredUnits < BigInt(0)) desiredUnits = BigInt(0);\n\n  // format back to human readable decimal string with token decimals (formatUnits truncates/keeps decimals)\n  // formatUnits will produce exactly decimals digits if fractional part exists; we'll strip trailing zeros.\n  const raw = formatUnits(desiredUnits, decimals);\n  // strip trailing zeros and possible trailing dot\n  return raw\n    .replace(/(\\.\\d*?[1-9])0+$/u, \"$1\")\n    .replace(/\\.0+$/u, \"\")\n    .replace(/^\\.$/u, \"0\");\n}\n\nexport const usdFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n",
      "type": "registry:component",
      "target": "components/common/utils/constant.ts"
    }
  ]
}