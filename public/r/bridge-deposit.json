{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bridge-deposit",
  "type": "registry:component",
  "title": "Bridge Deposit",
  "description": "A component built with Nexus for bridge deposit functionality",
  "dependencies": [
    "@avail-project/nexus-core@1.1.0",
    "lucide-react",
    "viem"
  ],
  "registryDependencies": [
    "https://elements.nexus.availproject.org/r/accordion.json",
    "https://elements.nexus.availproject.org/r/button.json",
    "https://elements.nexus.availproject.org/r/card.json",
    "https://elements.nexus.availproject.org/r/checkbox.json",
    "https://elements.nexus.availproject.org/r/collapsible.json",
    "https://elements.nexus.availproject.org/r/dialog.json",
    "https://elements.nexus.availproject.org/r/input.json",
    "https://elements.nexus.availproject.org/r/label.json",
    "https://elements.nexus.availproject.org/r/nexus-provider.json",
    "https://elements.nexus.availproject.org/r/popover.json",
    "https://elements.nexus.availproject.org/r/skeleton.json",
    "https://elements.nexus.availproject.org/r/tabs.json",
    "https://elements.nexus.availproject.org/r/tooltip.json",
    "https://elements.nexus.availproject.org/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/nexus-elements/bridge-deposit/components/allowance-modal.tsx",
      "content": "\"use client\";\nimport React, {\n  type FC,\n  memo,\n  type RefObject,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { Button } from \"../../ui/button\";\nimport { Input } from \"../../ui/input\";\nimport { Label } from \"../../ui/label\";\nimport {\n  type AllowanceHookSource,\n  CHAIN_METADATA,\n  type OnAllowanceHookData,\n} from \"@avail-project/nexus-core\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { Loader2 } from \"lucide-react\";\n\ninterface AllowanceModalProps {\n  allowance: RefObject<OnAllowanceHookData | null>;\n  callback?: () => void;\n  onCloseCallback?: () => void;\n}\n\ntype AllowanceChoice = \"min\" | \"max\" | \"custom\";\n\ninterface AllowanceOptionProps {\n  index: number;\n  name: string;\n  choice: AllowanceChoice;\n  selectedChoice?: AllowanceChoice;\n  onSelect: (index: number, choice: AllowanceChoice) => void;\n  title: string;\n  description?: string;\n  children?: React.ReactNode;\n  allowanceValue?: string;\n}\n\nconst ALLOWANCE_CHOICES: Array<{\n  choice: AllowanceChoice;\n  title: string;\n  description: string;\n}> = [\n  {\n    choice: \"min\",\n    title: \"Minimum\",\n    description: \"Grant the lowest allowance required for this action.\",\n  },\n  {\n    choice: \"max\",\n    title: \"Maximum\",\n    description: \"Approve once and skip future approvals for this token.\",\n  },\n  {\n    choice: \"custom\",\n    title: \"Custom amount\",\n    description: \"Specify an allowance that fits your threshold.\",\n  },\n];\n\nconst AllowanceOption: FC<AllowanceOptionProps> = ({\n  index,\n  name,\n  choice,\n  selectedChoice,\n  onSelect,\n  title,\n  description,\n  children,\n  allowanceValue,\n}) => {\n  const isActive = selectedChoice === choice;\n\n  return (\n    <Label className=\"block cursor-pointer\">\n      <input\n        type=\"radio\"\n        name={name}\n        value={choice}\n        checked={isActive}\n        onChange={() => onSelect(index, choice)}\n        className=\"peer sr-only\"\n      />\n      <div className=\"flex flex-col gap-3 rounded-xl border border-border/40 bg-background/40 px-4 py-3 transition peer-focus-visible:outline-none peer-focus-visible:ring-2 peer-focus-visible:ring-primary/50 peer-checked:border-primary peer-checked:bg-primary/10 sm:flex-row sm:items-center sm:justify-between\">\n        <div className=\"flex items-center justify-between w-full\">\n          <div>\n            <p className=\"text-sm font-medium leading-tight\">{title}</p>\n            {description ? (\n              <p className=\"text-xs text-muted-foreground\">{description}</p>\n            ) : null}\n          </div>\n          {allowanceValue && (\n            <p className=\"text-sm font-medium leading-tight\">\n              {allowanceValue}\n            </p>\n          )}\n        </div>\n\n        {children}\n      </div>\n    </Label>\n  );\n};\n\nconst AllowanceModal: FC<AllowanceModalProps> = ({\n  allowance,\n  callback,\n  onCloseCallback,\n}) => {\n  const { nexusSDK } = useNexus();\n  const [selectedOption, setSelectedOption] = useState<AllowanceChoice[]>([]);\n  const [customValues, setCustomValues] = useState<string[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const { sources, allow, deny } = allowance.current ?? {\n    sources: [],\n    allow: () => {},\n    deny: () => {},\n  };\n  const defaultChoices = useMemo<AllowanceChoice[]>(\n    () => Array.from({ length: sources.length }, () => \"min\"),\n    [sources.length]\n  );\n\n  const isCustomValueValid = (\n    value: string,\n    minimumRaw: bigint,\n    decimals: number\n  ): boolean => {\n    if (!value || value.trim() === \"\") return false;\n    try {\n      const parsedValue = nexusSDK?.utils?.parseUnits(value, decimals);\n      if (parsedValue === undefined) return false;\n      return parsedValue >= minimumRaw;\n    } catch {\n      return false;\n    }\n  };\n\n  const hasValidationErrors = useMemo(() => {\n    return sources.some((source, index) => {\n      if (selectedOption[index] !== \"custom\") return false;\n      const value = customValues[index];\n      if (!value || value.trim() === \"\") return false;\n      return !isCustomValueValid(\n        value,\n        source.allowance.minimumRaw,\n        source.token.decimals\n      );\n    });\n  }, [sources, selectedOption, customValues]);\n\n  const onClose = () => {\n    deny();\n    allowance.current = null;\n    onCloseCallback?.();\n  };\n\n  const onApprove = () => {\n    const processed = sources.map((_, i) => {\n      const opt = selectedOption[i];\n      if (opt === \"min\" || opt === \"max\") return opt;\n      const rawValue = customValues[i]?.trim();\n      if (!rawValue) return \"min\";\n      const parsed = Number(rawValue);\n      if (!Number.isFinite(parsed) || parsed < 0) return \"min\";\n      return rawValue;\n    });\n    setLoading(true);\n    try {\n      allow(processed);\n      callback?.();\n    } catch (error) {\n      console.error(\"AllowanceModal onApprove error\", error);\n      onCloseCallback?.();\n    } finally {\n      allowance.current = null;\n      setLoading(false);\n    }\n  };\n\n  const handleChoiceChange = (index: number, value: AllowanceChoice) => {\n    setSelectedOption((prev) => {\n      const next = [...(prev.length ? prev : defaultChoices)];\n      next[index] = value;\n      return next;\n    });\n  };\n\n  const formatAmount = (value: string | bigint, source: AllowanceHookSource) =>\n    nexusSDK?.utils?.formatTokenBalance(value, {\n      symbol: source.token.symbol,\n      decimals: source.token.decimals,\n    }) ?? \"â€”\";\n\n  useEffect(() => {\n    setSelectedOption(defaultChoices);\n  }, [defaultChoices]);\n\n  useEffect(() => {\n    setCustomValues(Array.from({ length: sources.length }, () => \"\"));\n  }, [sources.length]);\n\n  return (\n    <>\n      <div className=\"space-y-1\">\n        <p className=\"text-lg font-semibold tracking-tight\">\n          Set Token Allowances\n        </p>\n        <p className=\"text-sm text-muted-foreground\">\n          Review every required token and choose the minimum, an unlimited max,\n          or define a custom amount before approving.\n        </p>\n      </div>\n\n      <div className=\"space-y-4 py-2 max-h-[60vh] overflow-y-auto pr-1\">\n        {sources?.map((source: AllowanceHookSource, index: number) => (\n          <div\n            key={`${source.token.symbol}-${index}`}\n            className=\"rounded-2xl border border-border/40 bg-muted/10 p-4 shadow-sm transition hover:border-border\"\n          >\n            <div className=\"flex flex-wrap items-center justify-between gap-3\">\n              <div className=\"flex items-center gap-3\">\n                <div className=\"flex h-12 w-12 items-center justify-center rounded-full bg-background shadow-inner\">\n                  <img\n                    src={CHAIN_METADATA[source.chain.id]?.logo}\n                    alt={source.chain.name}\n                    width={24}\n                    height={24}\n                    className=\"rounded-full\"\n                  />\n                </div>\n                <div>\n                  <p className=\"text-base font-semibold\">\n                    {source.token.symbol}\n                  </p>\n                  <p className=\"text-xs text-muted-foreground\">\n                    {source.chain.name}\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"text-right\">\n                <p className=\"text-xs uppercase tracking-wide text-muted-foreground\">\n                  Current allowance\n                </p>\n                <p className=\"text-sm font-semibold\">\n                  {formatAmount(source.allowance.currentRaw, source)}\n                </p>\n              </div>\n            </div>\n\n            <div className=\"mt-4 space-y-2\">\n              {ALLOWANCE_CHOICES.map((choice) => {\n                if (choice.choice === \"custom\") {\n                  const customValue = customValues[index] ?? \"\";\n                  const isCustomSelected = selectedOption[index] === \"custom\";\n                  const showError =\n                    isCustomSelected &&\n                    customValue.trim() !== \"\" &&\n                    !isCustomValueValid(\n                      customValue,\n                      source.allowance.minimumRaw,\n                      source.token.decimals\n                    );\n                  return (\n                    <AllowanceOption\n                      key={choice.choice}\n                      index={index}\n                      name={`allowance-${index}`}\n                      choice={choice.choice}\n                      selectedChoice={selectedOption[index]}\n                      onSelect={handleChoiceChange}\n                      title={choice.title}\n                      description={choice.description}\n                    >\n                      <div className=\"flex flex-col gap-1\">\n                        <Input\n                          type=\"number\"\n                          step=\"any\"\n                          min=\"0\"\n                          inputMode=\"decimal\"\n                          placeholder=\"0.00\"\n                          value={isCustomSelected ? customValue : \"\"}\n                          onChange={(e) => {\n                            const next = [...customValues];\n                            next[index] = e.target.value;\n                            setCustomValues(next);\n                          }}\n                          maxLength={source.token.decimals}\n                          className={`h-9 w-40 rounded-lg border bg-background/80 text-sm disabled:opacity-60 ${\n                            showError ? \"border-destructive\" : \"\"\n                          }`}\n                          disabled={!isCustomSelected}\n                        />\n                        {showError && (\n                          <p className=\"text-xs text-destructive\">\n                            Min: {source.allowance.minimum}\n                          </p>\n                        )}\n                      </div>\n                    </AllowanceOption>\n                  );\n                }\n                return (\n                  <AllowanceOption\n                    key={choice.choice}\n                    index={index}\n                    name={`allowance-${index}`}\n                    choice={choice.choice}\n                    selectedChoice={selectedOption[index]}\n                    onSelect={handleChoiceChange}\n                    title={choice.title}\n                    description={choice.description}\n                    allowanceValue={\n                      choice.choice === \"min\"\n                        ? formatAmount(source.allowance.minimumRaw, source)\n                        : \"Unlimited\"\n                    }\n                  />\n                );\n              })}\n            </div>\n          </div>\n        ))}\n      </div>\n\n      <div className=\"mt-4 flex flex-col-reverse gap-3 sm:flex-row sm:items-center sm:justify-end\">\n        <Button variant=\"ghost\" onClick={onClose} className=\"font-semibold\">\n          Deny\n        </Button>\n        <Button\n          onClick={onApprove}\n          className=\"w-full sm:w-auto font-semibold\"\n          disabled={hasValidationErrors || loading}\n        >\n          {loading ? (\n            <Loader2 className=\"size-5 animate-spin\" />\n          ) : (\n            \"Approve Selected\"\n          )}\n        </Button>\n      </div>\n    </>\n  );\n};\n\nAllowanceModal.displayName = \"AllowanceModal\";\n\nexport default memo(AllowanceModal);\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/allowance-modal.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/amount-input.tsx",
      "content": "\"use client\";\n\nimport {\n  type SUPPORTED_CHAINS_IDS,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport { Button } from \"../../ui/button\";\nimport { Input } from \"../../ui/input\";\nimport { Fragment } from \"react\";\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"../../ui/accordion\";\nimport { computeAmountFromFraction, SHORT_CHAIN_NAME } from \"../../common\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { LoaderCircle } from \"lucide-react\";\n\nconst RANGE_OPTIONS = [\n  {\n    label: \"25%\",\n    value: 0.25,\n  },\n  {\n    label: \"50%\",\n    value: 0.5,\n  },\n  {\n    label: \"75%\",\n    value: 0.75,\n  },\n  {\n    label: \"MAX\",\n    value: 1,\n  },\n];\n\nconst SAFETY_MARGIN = 0.05;\n\ninterface AmountInputProps\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"onChange\" | \"value\"\n  > {\n  value?: string;\n  onChange?: (value: string) => void;\n  bridgableBalance?: UserAsset;\n  destinationChain: SUPPORTED_CHAINS_IDS;\n}\n\nconst AmountInput = ({\n  value,\n  onChange,\n  bridgableBalance,\n  disabled,\n  destinationChain,\n  ...props\n}: AmountInputProps) => {\n  const { nexusSDK, loading } = useNexus();\n\n  const hasSelectedSources =\n    bridgableBalance && bridgableBalance.breakdown.length > 0;\n  const hasBalance =\n    hasSelectedSources && Number.parseFloat(bridgableBalance.balance) > 0;\n\n  return (\n    <div className=\"flex flex-col items-start gap-y-1 w-full py-2\">\n      <Accordion type=\"single\" collapsible className=\"w-full\">\n        <AccordionItem value=\"balance-breakdown\">\n          <div className=\"flex items-center justify-between gap-x-3 w-full\">\n            <Input\n              {...props}\n              type=\"number\"\n              inputMode=\"decimal\"\n              step=\"any\"\n              min=\"0\"\n              placeholder=\"0.00\"\n              value={value ?? \"\"}\n              onChange={(e) => onChange?.(e.target.value)}\n              className=\"p-0 text-2xl! placeholder:text-2xl w-full border-none focus-visible:ring-0 focus-visible:ring-offset-0 shadow-none bg-transparent!\"\n              disabled={disabled || loading || !hasSelectedSources}\n            />\n            {bridgableBalance && hasSelectedSources && (\n              <p className=\"text-base font-semibold min-w-max\">\n                {nexusSDK?.utils?.formatTokenBalance(\n                  bridgableBalance?.balance,\n                  {\n                    symbol: bridgableBalance?.symbol,\n                    decimals: bridgableBalance?.decimals,\n                  }\n                )}\n              </p>\n            )}\n            {bridgableBalance && !hasSelectedSources && (\n              <p className=\"text-sm text-muted-foreground min-w-max\">\n                No sources selected\n              </p>\n            )}\n            {loading && !bridgableBalance && (\n              <LoaderCircle className=\"size-4 animate-spin\" />\n            )}\n          </div>\n          <div className=\"flex w-full items-center justify-between\">\n            <div className=\"flex gap-x-3\">\n              {RANGE_OPTIONS.map((option) => (\n                <Button\n                  size={\"icon\"}\n                  variant={\"ghost\"}\n                  key={option.label}\n                  className=\"text-xs py-0.5 px-0 size-max\"\n                  disabled={disabled || !hasBalance}\n                  onClick={() => {\n                    if (!bridgableBalance?.balance) return;\n\n                    const amount = computeAmountFromFraction(\n                      bridgableBalance.balance,\n                      option.value,\n                      bridgableBalance?.breakdown.find(\n                        (chain) => chain?.chain?.id === destinationChain\n                      )?.decimals ?? bridgableBalance?.decimals,\n                      SAFETY_MARGIN\n                    );\n                    onChange?.(amount);\n                  }}\n                >\n                  {option.label}\n                </Button>\n              ))}\n            </div>\n            {hasSelectedSources && (\n              <AccordionTrigger\n                className=\"w-fit justify-end items-center py-0 gap-x-0.5 cursor-pointer\"\n                hideChevron={false}\n              >\n                <p className=\"text-xs font-semibold min-w-max\">View Assets</p>\n              </AccordionTrigger>\n            )}\n          </div>\n\n          <AccordionContent className=\"pb-0\">\n            <div className=\"space-y-3 py-2 max-h-40 overflow-y-auto no-scrollbar\">\n              {bridgableBalance?.breakdown.map((chain) => {\n                if (Number.parseFloat(chain.balance) === 0) return null;\n                return (\n                  <Fragment key={chain.chain.id}>\n                    <div className=\"flex items-center justify-between px-2 py-1 rounded-md\">\n                      <div className=\"flex items-center gap-2\">\n                        <div className=\"relative h-6 w-6\">\n                          <img\n                            src={chain?.chain?.logo}\n                            alt={chain.chain.name}\n                            sizes=\"100%\"\n                            className=\"rounded-full\"\n                            loading=\"lazy\"\n                            decoding=\"async\"\n                            width=\"24\"\n                            height=\"24\"\n                          />\n                        </div>\n                        <span className=\"text-sm sm:block hidden\">\n                          {SHORT_CHAIN_NAME[chain.chain.id]}\n                        </span>\n                      </div>\n                      <div className=\"text-right\">\n                        <p className=\"text-sm font-medium\">\n                          {nexusSDK?.utils?.formatTokenBalance(chain.balance, {\n                            symbol: bridgableBalance?.symbol,\n                            decimals: bridgableBalance?.decimals,\n                          })}\n                        </p>\n                        <p className=\"text-xs text-muted-foreground\">\n                          ${chain.balanceInFiat.toFixed(2)}\n                        </p>\n                      </div>\n                    </div>\n                  </Fragment>\n                );\n              })}\n            </div>\n          </AccordionContent>\n        </AccordionItem>\n      </Accordion>\n    </div>\n  );\n};\n\nexport default AmountInput;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/amount-input.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/container.tsx",
      "content": "\"use client\";\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"../../ui/tabs\";\nimport SimpleDeposit from \"./simple-deposit\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { type BaseDepositProps } from \"../deposit\";\n\ninterface ContainerProps extends BaseDepositProps {\n  fiatSubheading?: string;\n  destinationLabel?: string;\n}\n\nconst Container = ({\n  address,\n  fiatSubheading = \"Cards, Apple Pay\",\n  token,\n  chain,\n  chainOptions,\n  destinationLabel,\n  depositExecute,\n}: ContainerProps) => {\n  const { nexusSDK } = useNexus();\n  return (\n    <Tabs defaultValue=\"simple\" className=\"sm:min-w-sm\">\n      <TabsList className=\"h-12 p-0 w-full\">\n        <TabsTrigger value=\"simple\" className=\"px-2 py-1\">\n          <div className=\"flex items-center flex-col gap-y-1\">\n            <p className=\"text-sm data-[state=active]:font-bold\">Wallet</p>\n            <p className=\"text-[10px]\">\n              {nexusSDK?.utils?.truncateAddress(address, 4, 4)}\n            </p>\n          </div>\n        </TabsTrigger>\n        <TabsTrigger value=\"qr\" className=\"px-2 py-1\">\n          <div className=\"flex items-center flex-col gap-y-1\">\n            <p className=\"text-sm data-[state=active]:font-bold\">Transfer QR</p>\n            <p className=\"text-[10px]\">{chainOptions?.length ?? \"0\"} chains</p>\n          </div>\n        </TabsTrigger>\n        <TabsTrigger value=\"fiat\" className=\"px-2 py-1\">\n          <div className=\"flex items-center flex-col gap-y-1\">\n            <p className=\"text-sm data-[state=active]:font-bold\">Fiat</p>\n            <p className=\"text-[10px]\">{fiatSubheading}</p>\n          </div>\n        </TabsTrigger>\n      </TabsList>\n      <TabsContent value=\"simple\">\n        <SimpleDeposit\n          address={address}\n          token={token}\n          chain={chain}\n          chainOptions={chainOptions}\n          destinationLabel={destinationLabel}\n          depositExecute={depositExecute}\n        />\n      </TabsContent>\n      <TabsContent value=\"qr\">\n        <p className=\"text-xl text-primary text-center\">Coming soon</p>\n      </TabsContent>\n      <TabsContent value=\"fiat\">\n        <p className=\"text-xl text-primary text-center\">Coming soon</p>\n      </TabsContent>\n    </Tabs>\n  );\n};\n\nexport default Container;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/container.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/deposit-modal.tsx",
      "content": "\"use client\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../../ui/dialog\";\nimport { type BaseDepositProps } from \"../deposit\";\nimport { Button } from \"../../ui/button\";\nimport SimpleDeposit from \"./simple-deposit\";\n\ninterface DepositModalProps extends BaseDepositProps {\n  heading?: string;\n  destinationLabel?: string;\n}\n\nconst DepositModal = ({\n  address,\n  token,\n  chain,\n  chainOptions,\n  heading,\n  destinationLabel,\n  depositExecute,\n}: DepositModalProps) => {\n  return (\n    <Dialog>\n      <DialogTrigger asChild>\n        <Button>Deposit</Button>\n      </DialogTrigger>\n      <DialogContent className=\"py-4 px-1 sm:p-6\">\n        <DialogHeader>\n          <DialogTitle>{heading}</DialogTitle>\n        </DialogHeader>\n        <SimpleDeposit\n          address={address}\n          token={token}\n          chain={chain}\n          chainOptions={chainOptions}\n          destinationLabel={destinationLabel}\n          depositExecute={depositExecute}\n        />\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default DepositModal;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/deposit-modal.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/fee-breakdown.tsx",
      "content": "import React from \"react\";\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"../../ui/accordion\";\nimport { Skeleton } from \"../../ui/skeleton\";\nimport { Tooltip, TooltipContent, TooltipTrigger } from \"../../ui/tooltip\";\nimport { MessageCircleQuestion } from \"lucide-react\";\n\ninterface DepositFeeBreakdownProps {\n  total: string;\n  bridge: string;\n  execute: string;\n  isLoading?: boolean;\n}\n\nconst DepositFeeBreakdown = ({\n  total,\n  bridge,\n  execute,\n  isLoading = false,\n}: DepositFeeBreakdownProps) => {\n  const feeRows = [\n    {\n      key: \"transaction\",\n      label: \"Transaction Fee\",\n      value: bridge,\n      description:\n        \"Cost required to bridge assets through Nexus, covering the cross-chain operation.\",\n    },\n    {\n      key: \"deposit\",\n      label: \"Deposit Fee\",\n      value: execute,\n      description:\n        \"Gas fee required to execute the deposit contract call on chain.\",\n    },\n  ];\n\n  return (\n    <Accordion type=\"single\" collapsible className=\"w-full\">\n      <AccordionItem value=\"deposit-fee-breakdown\">\n        <div className=\"w-full flex items-start justify-between\">\n          <p className=\"font-semibold text-base\">Total Fees</p>\n\n          <div className=\"flex flex-col items-end justify-end-safe gap-y-1\">\n            {isLoading ? (\n              <Skeleton className=\"h-5 w-24\" />\n            ) : (\n              <p className=\"font-semibold text-base min-w-max text-center\">\n                {total}\n              </p>\n            )}\n            <AccordionTrigger\n              containerClassName=\"w-fit\"\n              className=\"p-0 items-center gap-x-1\"\n              hideChevron={false}\n            >\n              <p className=\"text-sm font-medium\">View Breakdown</p>\n            </AccordionTrigger>\n          </div>\n        </div>\n        <AccordionContent>\n          <div className=\"w-full flex flex-col items-center justify-between gap-y-3 bg-muted px-4 py-2 rounded-lg mt-2\">\n            {feeRows.map(({ key, label, value, description }) => {\n              if (!value) return null;\n              return (\n                <Tooltip key={key}>\n                  <div className=\"flex items-center w-full justify-between\">\n                    <div className=\"flex items-center gap-x-2\">\n                      <p className=\"text-sm font-semibold\">{label}</p>\n                      <TooltipTrigger asChild>\n                        <MessageCircleQuestion className=\"size-4\" />\n                      </TooltipTrigger>\n                    </div>\n                    {isLoading ? (\n                      <Skeleton className=\"h-4 w-20\" />\n                    ) : (\n                      <p className=\"text-sm font-semibold\">{value}</p>\n                    )}\n                  </div>\n                  <TooltipContent className=\"max-w-sm text-balance\">\n                    <p className=\"text-sm font-semibold\">{description}</p>\n                  </TooltipContent>\n                </Tooltip>\n              );\n            })}\n          </div>\n        </AccordionContent>\n      </AccordionItem>\n    </Accordion>\n  );\n};\n\nexport default DepositFeeBreakdown;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/fee-breakdown.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/info.tsx",
      "content": "\"use client\";\n\nimport type { ReactNode, PropsWithChildren } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface InfoCardProps extends PropsWithChildren {\n  className?: string;\n}\n\nexport const InfoCard = ({ className, children }: InfoCardProps) => {\n  return (\n    <div\n      className={cn(\n        \"rounded-xl border border-border bg-card px-4 py-1 shadow-sm\",\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n};\n\ninterface InfoRowProps {\n  label: ReactNode;\n  value: ReactNode;\n  className?: string;\n  labelClassName?: string;\n  valueClassName?: string;\n}\n\nexport const InfoRow = ({\n  label,\n  value,\n  className,\n  labelClassName,\n  valueClassName,\n}: InfoRowProps) => {\n  return (\n    <div\n      className={cn(\n        \"flex items-center justify-between py-0.5 leading-tight text-sm\",\n        className\n      )}\n    >\n      <span className={cn(\"text-muted-foreground\", labelClassName)}>\n        {label}\n      </span>\n      <span className={cn(\"text-foreground font-medium\", valueClassName)}>\n        {value}\n      </span>\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/info.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/simple-deposit.tsx",
      "content": "\"use client\";\n\nimport { useCallback } from \"react\";\nimport { type BaseDepositProps } from \"../deposit\";\nimport AmountInput from \"./amount-input\";\nimport SourceSelect from \"./source-select\";\nimport { Button } from \"../../ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"../../ui/dialog\";\nimport AllowanceModal from \"./allowance-modal\";\nimport DepositTransactionStatusStep from \"./transaction-status-step\";\nimport DepositFeeBreakdown from \"./fee-breakdown\";\nimport SourceBreakdown from \"./source-breakdown\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport useDeposit from \"../hooks/useDeposit\";\nimport { LoaderPinwheel, X } from \"lucide-react\";\nimport { Skeleton } from \"../../ui/skeleton\";\nimport { type SUPPORTED_TOKENS } from \"@avail-project/nexus-core\";\n\ninterface SimpleDepositProps extends BaseDepositProps {\n  destinationLabel?: string;\n}\n\nconst SimpleDeposit = ({\n  address,\n  token,\n  chain,\n  chainOptions,\n  destinationLabel = \"on Hyperliquid Perps\",\n  depositExecute,\n}: SimpleDepositProps) => {\n  const {\n    nexusSDK,\n    intent,\n    bridgableBalance,\n    fetchBridgableBalance,\n    allowance,\n  } = useNexus();\n\n  const {\n    inputs,\n    setInputs,\n    status,\n    explorerUrls,\n    loading,\n    isProcessing,\n    isSuccess,\n    isError,\n    simulating,\n    refreshing,\n    txError,\n    setTxError,\n    timer,\n    filteredBridgableBalance,\n    unfilteredBridgableBalance,\n    simulation,\n    startTransaction,\n    cancelSimulation,\n    steps,\n    feeBreakdown,\n    reset,\n  } = useDeposit({\n    token: token ?? \"USDC\",\n    chain,\n    nexusSDK,\n    intent,\n    bridgableBalance,\n    allowance,\n    chainOptions,\n    address,\n    executeBuilder: depositExecute,\n    fetchBridgableBalance,\n  });\n\n  const renderDepositButtonContent = useCallback(() => {\n    if (refreshing)\n      return (\n        <div className=\"flex items-center gap-x-2\">\n          <LoaderPinwheel className=\"animate-spin size-4\" />\n          <p>Refreshing Quote</p>\n        </div>\n      );\n    if (simulating)\n      return (\n        <div className=\"flex items-center gap-x-2\">\n          <LoaderPinwheel className=\"animate-spin size-4\" />\n          <p>Preparing Quote</p>\n        </div>\n      );\n    return \"Deposit\";\n  }, [refreshing, simulating]);\n\n  if (isProcessing || isSuccess || isError) {\n    return (\n      <>\n        {allowance.current && (\n          <Dialog open={true} onOpenChange={() => {}}>\n            <DialogContent>\n              <DialogHeader className=\"sr-only\">\n                <DialogTitle>Set Token Allowances</DialogTitle>\n              </DialogHeader>\n              <AllowanceModal\n                allowance={allowance}\n                callback={startTransaction}\n                onCloseCallback={reset}\n              />\n            </DialogContent>\n          </Dialog>\n        )}\n        <DepositTransactionStatusStep\n          status={status}\n          timer={timer}\n          steps={steps}\n          tokenSymbol={token ?? \"USDC\"}\n          amount={inputs?.amount ?? \"0\"}\n          destinationLabel={destinationLabel}\n          explorerUrls={explorerUrls}\n          feeBreakdown={feeBreakdown}\n          onClose={reset}\n        />\n      </>\n    );\n  }\n\n  // Default: show form view (idle/previewing states)\n  return (\n    <div className=\"flex flex-col items-center w-full gap-y-3 rounded-lg\">\n      {/* Sources */}\n      <SourceSelect\n        token={token ?? \"USDC\"}\n        balanceBreakdown={unfilteredBridgableBalance}\n        selected={inputs?.selectedSources}\n        onChange={(selected) =>\n          setInputs({ ...inputs, selectedSources: selected })\n        }\n        disabled={Boolean(simulation && !simulation?.bridgeSimulation)}\n      />\n      <AmountInput\n        value={inputs?.amount}\n        onChange={(value) => {\n          setInputs({ ...inputs, amount: value });\n          if (!value) {\n            cancelSimulation();\n            setTxError(null);\n          }\n        }}\n        destinationChain={inputs?.chain}\n        bridgableBalance={filteredBridgableBalance}\n        disabled={loading || simulating}\n        maxLength={filteredBridgableBalance?.decimals}\n      />\n      {/* Shimmer while simulating */}\n      {simulating && !simulation && (\n        <>\n          <SourceBreakdown\n            isLoading\n            tokenSymbol={filteredBridgableBalance?.symbol as SUPPORTED_TOKENS}\n            chain={chain}\n          />\n          <div className=\"w-full flex items-start justify-between gap-x-4\">\n            <p className=\"text-base font-semibold\">You Receive</p>\n            <div className=\"flex flex-col gap-y-1 min-w-fit items-end\">\n              <Skeleton className=\"h-5 w-28\" />\n              <Skeleton className=\"h-4 w-36\" />\n            </div>\n          </div>\n          <DepositFeeBreakdown\n            isLoading\n            total={\"0\"}\n            bridge={\"0\"}\n            execute={\"0\"}\n          />\n        </>\n      )}\n      {simulation && inputs?.amount && (\n        <>\n          <SourceBreakdown\n            intent={simulation?.bridgeSimulation?.intent}\n            tokenSymbol={filteredBridgableBalance?.symbol as SUPPORTED_TOKENS}\n            isLoading={refreshing}\n            chain={chain}\n            bridgableBalance={filteredBridgableBalance}\n            requiredAmount={inputs?.amount}\n          />\n\n          <div className=\"w-full flex items-start justify-between gap-x-4\">\n            <p className=\"text-base font-semibold\">You Receive</p>\n            <div className=\"flex flex-col gap-y-1 min-w-fit\">\n              {refreshing ? (\n                <Skeleton className=\"h-5 w-28\" />\n              ) : (\n                <p className=\"text-base font-semibold text-right\">\n                  {inputs?.amount} {filteredBridgableBalance?.symbol}\n                </p>\n              )}\n              <p className=\"text-sm font-medium text-right\">\n                {destinationLabel}\n              </p>\n            </div>\n          </div>\n\n          <DepositFeeBreakdown\n            total={`${feeBreakdown?.totalGasFee}`}\n            bridge={feeBreakdown?.bridgeFormatted ?? \"\"}\n            execute={feeBreakdown?.gasFormatted ?? \"\"}\n            isLoading={refreshing}\n          />\n          {!simulation.bridgeSimulation && (\n            <div className=\"w-full text-sm text-muted-foreground\">\n              Bridge skipped, executing directly on destination chain\n            </div>\n          )}\n        </>\n      )}\n      {simulation ? (\n        <div className=\"w-full flex items-center justify-center gap-x-2 px-1\">\n          <Button\n            variant={\"destructive\"}\n            onClick={() => {\n              reset();\n              setTxError(null);\n            }}\n            className=\"w-1/2\"\n          >\n            Cancel\n          </Button>\n          <Button\n            onClick={startTransaction}\n            disabled={loading || simulating || refreshing}\n            className=\"w-1/2\"\n          >\n            {renderDepositButtonContent()}\n          </Button>\n        </div>\n      ) : (\n        <Button disabled={true} className=\"w-full px-2\">\n          {renderDepositButtonContent()}\n        </Button>\n      )}\n\n      {txError && (\n        <div className=\"rounded-md border border-destructive bg-destructive/80 px-3 py-2 text-sm text-destructive-foreground flex items-start justify-between gap-x-3 mt-3 w-full max-w-sm\">\n          <span className=\"flex-1 max-w-md truncate\">{txError}</span>\n          <Button\n            type=\"button\"\n            size={\"icon\"}\n            variant={\"ghost\"}\n            onClick={() => {\n              reset();\n              setTxError(null);\n            }}\n            className=\"text-destructive-foreground/80 hover:text-destructive-foreground focus:outline-none\"\n            aria-label=\"Dismiss error\"\n          >\n            <X className=\"size-4\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SimpleDeposit;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/simple-deposit.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/source-breakdown.tsx",
      "content": "import {\n  CHAIN_METADATA,\n  type SUPPORTED_CHAINS_IDS,\n  type UserAsset,\n  type ReadableIntent,\n  type SUPPORTED_TOKENS,\n} from \"@avail-project/nexus-core\";\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"../../ui/accordion\";\nimport { Skeleton } from \"../../ui/skeleton\";\nimport { useMemo } from \"react\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\n\ninterface SourceBreakdownProps {\n  intent?: ReadableIntent;\n  tokenSymbol: SUPPORTED_TOKENS;\n  isLoading?: boolean;\n  chain: SUPPORTED_CHAINS_IDS;\n  bridgableBalance?: UserAsset;\n  requiredAmount?: string;\n}\n\ntype ReadableIntentSource = {\n  amount: string;\n  chainID: number;\n  chainLogo: string | undefined;\n  chainName: string;\n  contractAddress: `0x${string}`;\n};\n\nconst SourceBreakdown = ({\n  intent,\n  tokenSymbol,\n  isLoading = false,\n  chain,\n  bridgableBalance,\n  requiredAmount,\n}: SourceBreakdownProps) => {\n  const { nexusSDK } = useNexus();\n  const fundsOnDestination = useMemo(() => {\n    return Number.parseFloat(\n      bridgableBalance?.breakdown?.find((b) => b.chain?.id === chain)\n        ?.balance ?? \"0\"\n    );\n  }, [bridgableBalance, chain]);\n\n  const amountSpend = useMemo(() => {\n    const amountToFormat = intent\n      ? Number.parseFloat(requiredAmount ?? \"0\") +\n        Number.parseFloat(intent?.fees?.total ?? \"0\")\n      : requiredAmount ?? \"0\";\n    return nexusSDK?.utils?.formatTokenBalance(amountToFormat, {\n      symbol: tokenSymbol,\n      decimals: intent?.token?.decimals,\n    });\n  }, [requiredAmount, intent, tokenSymbol]);\n\n  const displaySources = useMemo(() => {\n    if (!intent)\n      return [\n        {\n          chainID: chain,\n          chainLogo: CHAIN_METADATA[chain]?.logo,\n          chainName: CHAIN_METADATA[chain]?.name ?? \"Destination\",\n          amount: requiredAmount ?? \"0\",\n          contractAddress: \"\",\n        },\n      ];\n    const baseSources: ReadableIntentSource[] = intent?.sources ?? [];\n    const requiredAmountNumber = Number(requiredAmount ?? \"0\");\n    const destUsed = Math.max(\n      Math.min(requiredAmountNumber, fundsOnDestination),\n      0\n    );\n    if (destUsed <= 0) {\n      return baseSources;\n    }\n    const allSources = intent?.allSources ?? [];\n    const destDetails = allSources?.find?.(\n      (s: ReadableIntentSource) => s?.chainID === chain\n    );\n    const hasDest = baseSources?.some?.(\n      (s: ReadableIntentSource) => s?.chainID === chain\n    );\n    const destSource = {\n      chainID: chain,\n      chainLogo: destDetails?.chainLogo,\n      chainName: destDetails?.chainName ?? \"Destination\",\n      amount: destUsed.toString(),\n      contractAddress: destDetails?.contractAddress ?? \"\",\n    };\n    if (hasDest) {\n      return baseSources.map((s: ReadableIntentSource) =>\n        s?.chainID === chain ? { ...s, amount: destSource.amount } : s\n      );\n    }\n    return [...baseSources, destSource];\n  }, [intent, requiredAmount, fundsOnDestination, chain]);\n\n  return (\n    <Accordion type=\"single\" collapsible className=\"w-full\">\n      <AccordionItem value=\"sources\">\n        <div className=\"flex items-start justify-between gap-x-4 w-full\">\n          {isLoading ? (\n            <>\n              <div className=\"flex flex-col items-start gap-y-1 min-w-fit\">\n                <p className=\"text-base font-semibold\">You Spend</p>\n                <Skeleton className=\"h-4 w-44\" />\n              </div>\n              <div className=\"flex flex-col items-end gap-y-1 min-w-fit\">\n                <Skeleton className=\"h-5 w-24\" />\n                <div className=\"w-fit\">\n                  <Skeleton className=\"h-4 w-24\" />\n                </div>\n              </div>\n            </>\n          ) : (\n            <>\n              <div className=\"flex flex-col items-start gap-y-1 min-w-fit\">\n                <p className=\"text-base font-semibold\">You Spend</p>\n                <p className=\"text-sm font-medium\">\n                  {displaySources?.length < 2\n                    ? \"1 Asset on 1 Chain\"\n                    : `1 Asset on ${displaySources?.length} Chains`}\n                </p>\n              </div>\n\n              <div className=\"flex flex-col items-end gap-y-1 min-w-fit\">\n                <p className=\"text-base font-semibold\">{amountSpend}</p>\n                <AccordionTrigger\n                  containerClassName=\"w-fit\"\n                  className=\"py-0 items-center gap-x-1\"\n                  hideChevron={false}\n                >\n                  <p className=\"text-sm font-medium\">View Sources</p>\n                </AccordionTrigger>\n              </div>\n            </>\n          )}\n        </div>\n        {!isLoading && displaySources?.length > 0 && (\n          <AccordionContent className=\"my-4 bg-muted pb-0 px-4 py-2 rounded-lg w-full\">\n            <div className=\"flex flex-col items-center gap-y-3\">\n              {displaySources?.map((source) => (\n                <div\n                  key={source.chainID}\n                  className=\"flex items-center justify-between w-full gap-x-2\"\n                >\n                  <div className=\"flex items-center gap-x-2\">\n                    <img\n                      src={source?.chainLogo}\n                      alt={source?.chainName}\n                      width={20}\n                      height={20}\n                      className=\"rounded-full\"\n                    />\n                    <p className=\"text-sm font-semibold sm:block hidden\">\n                      {source.chainName}\n                    </p>\n                  </div>\n\n                  <p className=\"text-sm font-semibold\">\n                    {source.amount} {tokenSymbol}\n                  </p>\n                </div>\n              ))}\n            </div>\n          </AccordionContent>\n        )}\n      </AccordionItem>\n    </Accordion>\n  );\n};\n\nexport default SourceBreakdown;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/source-breakdown.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/source-select.tsx",
      "content": "import { ChevronDown } from \"lucide-react\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"../../ui/popover\";\nimport { Label } from \"../../ui/label\";\nimport { Checkbox } from \"../../ui/checkbox\";\nimport {\n  type SUPPORTED_TOKENS,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\n\ninterface SourceSelectProps {\n  token?: SUPPORTED_TOKENS;\n  balanceBreakdown?: UserAsset;\n  selected?: number[];\n  onChange?: (selected: number[]) => void;\n  disabled?: boolean;\n}\n\nconst SourceSelect = ({\n  token,\n  balanceBreakdown,\n  selected = [],\n  onChange,\n  disabled = false,\n}: SourceSelectProps) => {\n  const isSelected = (id: number) => selected?.includes(id);\n  const toggle = (id: number) => {\n    if (!onChange) return;\n    if (disabled) return;\n    if (isSelected(id)) onChange(selected.filter((s) => s !== id));\n    else onChange([...selected, id]);\n  };\n\n  const allSelected =\n    Boolean(balanceBreakdown?.breakdown.length) &&\n    balanceBreakdown?.breakdown.every((chain) =>\n      selected.includes(chain.chain.id)\n    );\n\n  const toggleAll = () => {\n    if (!onChange || disabled || !balanceBreakdown?.breakdown.length) return;\n    if (allSelected) {\n      onChange([]);\n    } else {\n      onChange(balanceBreakdown.breakdown.map((chain) => chain.chain.id));\n    }\n  };\n\n  return (\n    <Popover>\n      <PopoverTrigger\n        disabled={disabled}\n        aria-disabled={disabled}\n        className={`flex items-center justify-between w-full px-0 py-2 ${\n          disabled ? \"cursor-not-allowed opacity-60\" : \"cursor-pointer\"\n        }`}\n      >\n        Customise source chains\n        <ChevronDown className=\"size-4 text-primary data-[state=open]:rotate-180 shrink-0 translate-y-0.5 transition-transform duration-200\" />\n      </PopoverTrigger>\n      <PopoverContent className=\"w-max sm:w-sm no-scrollbar\">\n        {balanceBreakdown && balanceBreakdown?.breakdown.length > 0 ? (\n          <>\n            <div className=\"flex items-center gap-x-2 pb-3 mb-3 border-b border-border w-full\">\n              <Checkbox\n                checked={allSelected}\n                onCheckedChange={toggleAll}\n                disabled={disabled}\n                className={`${\n                  disabled ? \"cursor-not-allowed\" : \"cursor-pointer\"\n                }`}\n              />\n              <Label\n                className=\"text-primary text-sm cursor-pointer\"\n                onClick={toggleAll}\n              >\n                Select All\n              </Label>\n            </div>\n            <div className=\"grid grid-cols-1 gap-1 w-full overflow-y-auto max-h-[300px] no-scrollbar\">\n              {balanceBreakdown?.breakdown.map((chain) => (\n                <div key={chain.chain.id} className=\"flex items-center gap-x-2\">\n                  <Checkbox\n                    checked={isSelected(chain.chain.id)}\n                    onCheckedChange={() => toggle(chain.chain.id)}\n                    value={chain.chain.id}\n                    disabled={disabled}\n                    className={`${\n                      disabled ? \"cursor-not-allowed\" : \"cursor-pointer\"\n                    }`}\n                  />\n                  <div className=\"w-full flex items-center justify-between\">\n                    <div className=\"flex items-center gap-x-2 p-2\">\n                      <img\n                        src={chain.chain.logo}\n                        alt={chain.chain.name}\n                        width={24}\n                        height={24}\n                        className=\"rounded-full\"\n                      />\n                      <Label\n                        className=\"text-primary text-sm\"\n                        htmlFor={String(chain.chain.id)}\n                      >\n                        {chain.chain.name}\n                      </Label>\n                    </div>\n                    <p className=\"text-sm font-semibold\">\n                      {chain.balance} {token}\n                    </p>\n                  </div>\n                </div>\n              ))}\n            </div>\n          </>\n        ) : (\n          <p className=\"text-sm text-muted-foreground\">\n            No chains with balance\n          </p>\n        )}\n      </PopoverContent>\n    </Popover>\n  );\n};\nexport default SourceSelect;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/source-select.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/step-indicator.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Check, Loader2 } from \"lucide-react\";\nimport { useEffect, useState, useMemo } from \"react\";\n\ninterface StepIndicatorProps {\n  /** Number from 0 to 1 representing progress */\n  progress: number;\n  /** Whether the transaction is fully complete */\n  isComplete: boolean;\n  /** Whether the transaction has failed */\n  isError?: boolean;\n}\n\nconst MILESTONES = [\n  { id: 1, label: \"Intent verified\" },\n  { id: 2, label: \"Collected\" },\n  { id: 3, label: \"Filled\" },\n  { id: 4, label: \"Depositing\" },\n];\n\nexport const StepIndicator = ({\n  progress,\n  isComplete,\n  isError = false,\n}: StepIndicatorProps) => {\n  const [isMerged, setIsMerged] = useState(false);\n\n  // Calculate which step is active based on progress\n  const currentStep = useMemo(() => {\n    if (isComplete) return MILESTONES.length;\n    // Map progress (0-1) to steps (1-4)\n    return Math.min(\n      MILESTONES.length,\n      Math.floor(progress * MILESTONES.length) + 1\n    );\n  }, [progress, isComplete]);\n\n  useEffect(() => {\n    if (isComplete) {\n      const timer = setTimeout(() => setIsMerged(true), 500);\n      return () => clearTimeout(timer);\n    } else {\n      setIsMerged(false);\n    }\n  }, [isComplete]);\n\n  // Don't show merged state on error\n  const showMerged = isMerged && !isError;\n\n  return (\n    <div className=\"relative flex h-14 items-center justify-center w-full\">\n      {/* Merged success state */}\n      <div\n        className={cn(\n          \"absolute inset-0 flex items-center justify-center transition-all duration-700 ease-in-out\",\n          showMerged\n            ? \"opacity-100 scale-100 translate-y-0\"\n            : \"opacity-0 scale-50 translate-y-4 pointer-events-none\"\n        )}\n      >\n        <div className=\"flex h-10 w-10 items-center justify-center rounded-full bg-success text-success-foreground shadow-[0_0_15px_rgba(34,197,94,0.4)] ring-2 ring-success/20\">\n          <Check\n            className=\"h-5 w-5 animate-in zoom-in duration-300\"\n            strokeWidth={3}\n          />\n        </div>\n      </div>\n\n      {/* Steps */}\n      <div\n        className={cn(\n          \"flex items-center gap-1.5 transition-all duration-500 ease-in-out\",\n          showMerged\n            ? \"opacity-0 scale-90 blur-sm\"\n            : \"opacity-100 scale-100 blur-0\"\n        )}\n      >\n        {MILESTONES.map((step, index) => {\n          const isStepComplete = step.id < currentStep || isComplete;\n          // Stop showing active spinner on error\n          const isStepActive =\n            step.id === currentStep && !isComplete && !isError;\n          // Show error state on current step when error occurs\n          const isStepError = step.id === currentStep && isError;\n\n          return (\n            <div\n              key={step.id}\n              className=\"flex items-center gap-1 text-xs font-medium\"\n            >\n              <div\n                className={cn(\n                  \"relative flex h-6 w-6 items-center justify-center rounded-full border transition-all duration-300\",\n                  isStepComplete &&\n                    \"border-primary bg-success text-success-foreground\",\n                  isStepActive &&\n                    \"border-primary border-2 text-primary ring-2 ring-primary/20 opacity-100\",\n                  isStepError &&\n                    \"border-2 border-destructive text-destructive-foreground\",\n                  !isStepComplete &&\n                    !isStepActive &&\n                    !isStepError &&\n                    \"border-border text-muted-foreground opacity-30\"\n                )}\n              >\n                <span className=\"absolute inset-0 flex items-center justify-center\">\n                  {isStepComplete && (\n                    <Check className=\"h-3 w-3 animate-in zoom-in duration-300\" />\n                  )}\n                  {isStepActive && <Loader2 className=\"h-3 w-3 animate-spin\" />}\n                  {isStepError && (\n                    <span className=\"text-[10px] font-bold text-destructive\">\n                      !\n                    </span>\n                  )}\n                  {!isStepComplete && !isStepActive && !isStepError && (\n                    <span className=\"text-[10px] text-foreground\">\n                      {step.id}\n                    </span>\n                  )}\n                </span>\n              </div>\n\n              {index < MILESTONES.length - 1 && (\n                <div className=\"h-px w-4 bg-border overflow-hidden rounded-full\">\n                  <div\n                    className={cn(\n                      \"h-full bg-success transition-transform duration-500 ease-in-out origin-left\",\n                      isStepComplete ? \"scale-x-100\" : \"scale-x-0\"\n                    )}\n                  />\n                </div>\n              )}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/step-indicator.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/components/transaction-status-step.tsx",
      "content": "\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { StepIndicator } from \"./step-indicator\";\nimport { InfoRow, InfoCard } from \"./info\";\nimport { Button } from \"../../ui/button\";\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from \"../../ui/collapsible\";\nimport { ChevronRight, ExternalLink, Loader2 } from \"lucide-react\";\nimport { type DepositStatus } from \"../hooks/useDeposit\";\nimport { type BridgeStepType } from \"@avail-project/nexus-core\";\n\ninterface DepositTransactionStatusProps {\n  status: DepositStatus;\n  timer: number;\n  steps: Array<{ id: number; completed: boolean; step: BridgeStepType }>;\n  tokenSymbol: string;\n  amount: string;\n  destinationLabel: string;\n  explorerUrls: {\n    intentUrl: string | null;\n    executeUrl: string | null;\n  };\n  feeBreakdown?: {\n    totalGasFee: string | number;\n    gasFormatted?: string;\n    bridgeFormatted?: string;\n  };\n  onClose: () => void;\n}\n\nconst DepositTransactionStatusStep = ({\n  status,\n  timer,\n  steps,\n  tokenSymbol,\n  amount,\n  destinationLabel,\n  explorerUrls,\n  feeBreakdown,\n  onClose,\n}: DepositTransactionStatusProps) => {\n  const [open, setOpen] = useState(false);\n\n  const isSuccess = status === \"success\";\n  const isError = status === \"error\";\n  const isExecuting = status === \"executing\";\n  const totalSteps = Array.isArray(steps) ? steps.length : 0;\n  const completedSteps = Array.isArray(steps)\n    ? steps.reduce((acc, s) => acc + (s?.completed ? 1 : 0), 0)\n    : 0;\n  const stepPercent = totalSteps > 0 ? completedSteps / totalSteps : 0;\n  const progress = isSuccess ? 1 : Math.min(stepPercent, 0.75);\n\n  const title = useMemo(() => {\n    if (isSuccess) return \"Deposit successful\";\n    if (isError) return \"Deposit failed\";\n    return \"Processing your deposit\";\n  }, [isSuccess, isError]);\n\n  const subtitle = useMemo(() => {\n    if (isSuccess) return \"Your funds were successfully deposited.\";\n    if (isError) return \"Something went wrong with your deposit.\";\n    return \"This may take a few seconds to complete.\";\n  }, [isSuccess, isError]);\n\n  const totalTime = useMemo(() => {\n    if (!isSuccess) return undefined;\n    return `${Math.max(1, Math.floor(timer))}s`;\n  }, [isSuccess, timer]);\n\n  const statusValue = useMemo(() => {\n    if (isSuccess) {\n      return <span className=\"text-success font-semibold\">Successful</span>;\n    }\n    if (isError) {\n      return <span className=\"text-destructive font-semibold\">Failed</span>;\n    }\n    return (\n      <span className=\"flex items-center gap-2\">\n        <Loader2 className=\"h-3.5 w-3.5 animate-spin\" />\n        Processing\n      </span>\n    );\n  }, [isSuccess, isError]);\n\n  // Format live timer display\n  const liveTimer = useMemo(() => {\n    const seconds = Math.floor(timer);\n    const ms = String(Math.floor((timer % 1) * 1000)).padStart(3, \"0\");\n    return `${seconds}.${ms}s`;\n  }, [timer]);\n\n  return (\n    <div className=\"flex h-full flex-col bg-transparent\">\n      <div className=\"flex-1 space-y-4 overflow-y-auto no-scrollbar px-4 py-4\">\n        <StepIndicator\n          progress={progress}\n          isComplete={isSuccess}\n          isError={isError}\n        />\n\n        <div className=\"text-center space-y-2\">\n          <h2 className=\"text-lg font-semibold text-foreground\">{title}</h2>\n          <p className=\"text-sm text-muted-foreground\">{subtitle}</p>\n          {isExecuting && (\n            <p className=\"text-2xl font-semibold text-foreground\">\n              {liveTimer}\n            </p>\n          )}\n        </div>\n\n        <InfoCard>\n          <InfoRow label=\"Status\" value={statusValue} />\n          {isSuccess && totalTime && (\n            <InfoRow label=\"Total time\" value={totalTime} />\n          )}\n        </InfoCard>\n\n        <InfoCard>\n          <InfoRow\n            label={isSuccess ? \"You deposited\" : \"Depositing\"}\n            value={`${amount} ${tokenSymbol}`}\n          />\n          <InfoRow label=\"Destination\" value={destinationLabel} />\n        </InfoCard>\n\n        {(explorerUrls.intentUrl || explorerUrls.executeUrl) && (\n          <InfoCard>\n            {explorerUrls.intentUrl && (\n              <InfoRow\n                label=\"Bridge Intent\"\n                value={\n                  <a\n                    href={explorerUrls.intentUrl}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                    className=\"flex items-center gap-1.5 text-primary hover:underline\"\n                  >\n                    View\n                    <ExternalLink className=\"h-3.5 w-3.5\" />\n                  </a>\n                }\n              />\n            )}\n            {explorerUrls.executeUrl && (\n              <InfoRow\n                label=\"Execute Transaction\"\n                value={\n                  <a\n                    href={explorerUrls.executeUrl}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                    className=\"flex items-center gap-1.5 text-primary hover:underline\"\n                  >\n                    View\n                    <ExternalLink className=\"h-3.5 w-3.5\" />\n                  </a>\n                }\n              />\n            )}\n          </InfoCard>\n        )}\n\n        {feeBreakdown && (\n          <Collapsible open={open} onOpenChange={setOpen}>\n            <CollapsibleTrigger className=\"flex w-full items-center justify-between py-3 text-sm text-muted-foreground transition-colors hover:text-foreground\">\n              <span>Fee breakdown</span>\n              <ChevronRight\n                className={`h-4 w-4 transition-transform ${\n                  open ? \"rotate-90\" : \"\"\n                }`}\n              />\n            </CollapsibleTrigger>\n            <CollapsibleContent>\n              <InfoCard className=\"space-y-0\">\n                {feeBreakdown.bridgeFormatted && (\n                  <InfoRow\n                    label=\"Bridge fee\"\n                    value={feeBreakdown.bridgeFormatted}\n                  />\n                )}\n                {feeBreakdown.gasFormatted && (\n                  <InfoRow label=\"Gas fee\" value={feeBreakdown.gasFormatted} />\n                )}\n                <InfoRow\n                  label=\"Total fees\"\n                  value={\n                    typeof feeBreakdown.totalGasFee === \"string\"\n                      ? feeBreakdown.totalGasFee\n                      : `$${feeBreakdown.totalGasFee.toFixed(4)}`\n                  }\n                />\n              </InfoCard>\n            </CollapsibleContent>\n          </Collapsible>\n        )}\n      </div>\n\n      <div className=\"flex gap-3 border-t border-border p-4\">\n        <Button\n          variant=\"destructive\"\n          onClick={onClose}\n          className=\"flex-1 rounded-xl text-base\"\n        >\n          Close\n        </Button>\n        <Button\n          onClick={onClose}\n          className=\"flex-1 rounded-xl text-base\"\n          disabled={!isSuccess && !isError}\n        >\n          {isSuccess || isError ? (\n            \"New Deposit\"\n          ) : (\n            <Loader2 className=\"size-5 animate-spin\" />\n          )}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default DepositTransactionStatusStep;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/components/transaction-status-step.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/deposit.tsx",
      "content": "import {\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n  type ExecuteParams,\n} from \"@avail-project/nexus-core\";\nimport DepositModal from \"./components/deposit-modal\";\nimport { type Address } from \"viem\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"../ui/card\";\nimport { useNexus } from \"../nexus/NexusProvider\";\nimport SimpleDeposit from \"./components/simple-deposit\";\n\nexport interface BaseDepositProps {\n  address: Address;\n  token?: SUPPORTED_TOKENS;\n  chain: SUPPORTED_CHAINS_IDS;\n  chainOptions?: {\n    id: number;\n    name: string;\n    logo: string;\n  }[];\n  depositExecute: (\n    token: SUPPORTED_TOKENS,\n    amount: string,\n    chainId: SUPPORTED_CHAINS_IDS,\n    userAddress: `0x${string}`\n  ) => Omit<ExecuteParams, \"toChainId\">;\n}\n\ninterface NexusDepositProps extends BaseDepositProps {\n  heading?: string;\n  embed?: boolean;\n  destinationLabel?: string;\n}\n\nconst NexusDeposit = ({\n  address,\n  token = \"USDC\",\n  chain,\n  chainOptions, // pass to customise sources displayed, if not provided, all sources will be shown\n  heading = \"Deposit USDC\",\n  embed = false,\n  destinationLabel,\n  depositExecute,\n}: NexusDepositProps) => {\n  const { supportedChainsAndTokens } = useNexus();\n  const formatedChainOptions =\n    chainOptions ??\n    supportedChainsAndTokens?.map((chain) => {\n      return {\n        id: chain.id,\n        name: chain.name,\n        logo: chain.logo,\n      };\n    });\n  if (embed) {\n    return (\n      <Card>\n        <CardHeader className=\"px-3\">\n          <CardTitle>{heading}</CardTitle>\n        </CardHeader>\n        <CardContent className=\"px-3\">\n          <SimpleDeposit\n            address={address}\n            token={token}\n            chain={chain}\n            chainOptions={formatedChainOptions}\n            destinationLabel={destinationLabel}\n            depositExecute={depositExecute}\n          />\n        </CardContent>\n      </Card>\n    );\n  }\n  return (\n    <DepositModal\n      address={address}\n      token={token}\n      chain={chain}\n      chainOptions={formatedChainOptions}\n      heading={heading}\n      destinationLabel={destinationLabel}\n      depositExecute={depositExecute}\n    />\n  );\n};\n\nexport default NexusDeposit;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/deposit.tsx"
    },
    {
      "path": "registry/nexus-elements/bridge-deposit/hooks/useDeposit.ts",
      "content": "\"use client\";\n\nimport {\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n  type UserAsset,\n  NexusSDK,\n  type OnIntentHookData,\n  type OnAllowanceHookData,\n  type ExecuteParams,\n  type BridgeAndExecuteParams,\n  type BridgeAndExecuteResult,\n  type BridgeAndExecuteSimulationResult,\n  NEXUS_EVENTS,\n  type BridgeStepType,\n  CHAIN_METADATA,\n} from \"@avail-project/nexus-core\";\nimport {\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useReducer,\n  useCallback,\n  type RefObject,\n} from \"react\";\nimport { useNexus } from \"../../nexus/NexusProvider\";\nimport { type Address } from \"viem\";\nimport {\n  useDebouncedValue,\n  useNexusError,\n  usePolling,\n  useStopwatch,\n  useTransactionSteps,\n} from \"../../common\";\n\nexport type DepositStatus =\n  | \"idle\"\n  | \"previewing\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\ninterface DepositInputs {\n  chain: SUPPORTED_CHAINS_IDS;\n  amount?: string;\n  selectedSources: number[];\n}\n\ninterface UseDepositProps {\n  token: SUPPORTED_TOKENS;\n  chain: SUPPORTED_CHAINS_IDS;\n  nexusSDK: NexusSDK | null;\n  intent: RefObject<OnIntentHookData | null>;\n  allowance: RefObject<OnAllowanceHookData | null>;\n  bridgableBalance: UserAsset[] | null;\n  fetchBridgableBalance: () => Promise<void>;\n  chainOptions?: { id: number; name: string; logo: string }[];\n  address: Address;\n  executeBuilder?: (\n    token: SUPPORTED_TOKENS,\n    amount: string,\n    chainId: SUPPORTED_CHAINS_IDS,\n    userAddress: `0x${string}`\n  ) => Omit<ExecuteParams, \"toChainId\">;\n  executeConfig?: Omit<ExecuteParams, \"toChainId\">;\n}\n\ntype DepositState = {\n  inputs: DepositInputs;\n  status: DepositStatus;\n  explorerUrls: {\n    intentUrl: string | null;\n    executeUrl: string | null;\n  };\n  error: string | null;\n  lastResult: BridgeAndExecuteResult | null;\n};\n\ntype Action =\n  | { type: \"setInputs\"; payload: Partial<DepositInputs> }\n  | { type: \"resetInputs\" }\n  | { type: \"setStatus\"; payload: DepositStatus }\n  | { type: \"setExplorerUrls\"; payload: Partial<DepositState[\"explorerUrls\"]> }\n  | { type: \"setError\"; payload: string | null }\n  | { type: \"setLastResult\"; payload: BridgeAndExecuteResult | null }\n  | { type: \"reset\" };\n\nconst useDeposit = ({\n  token,\n  chain,\n  nexusSDK,\n  intent,\n  bridgableBalance,\n  chainOptions,\n  address,\n  executeBuilder,\n  executeConfig,\n  allowance,\n  fetchBridgableBalance,\n}: UseDepositProps) => {\n  const { getFiatValue } = useNexus();\n  const handleNexusError = useNexusError();\n\n  const allSourceIds = useMemo(\n    () => chainOptions?.map((c) => c.id) ?? [],\n    [chainOptions]\n  );\n\n  const createInitialState = useCallback(\n    (): DepositState => ({\n      inputs: {\n        chain,\n        amount: undefined,\n        selectedSources: allSourceIds,\n      },\n      status: \"idle\",\n      explorerUrls: {\n        intentUrl: null,\n        executeUrl: null,\n      },\n      error: null,\n      lastResult: null,\n    }),\n    [chain, allSourceIds]\n  );\n\n  const initialState = createInitialState();\n\n  function reducer(state: DepositState, action: Action): DepositState {\n    switch (action.type) {\n      case \"setInputs\": {\n        const newInputs = { ...state.inputs, ...action.payload };\n        let newStatus = state.status;\n        if (\n          state.status === \"idle\" &&\n          newInputs.amount &&\n          Number.parseFloat(newInputs.amount) > 0\n        ) {\n          newStatus = \"previewing\";\n        }\n        if (\n          state.status === \"previewing\" &&\n          (!newInputs.amount || Number.parseFloat(newInputs.amount) <= 0)\n        ) {\n          newStatus = \"idle\";\n        }\n        return { ...state, inputs: newInputs, status: newStatus };\n      }\n      case \"resetInputs\":\n        return {\n          ...state,\n          inputs: { chain, amount: undefined, selectedSources: allSourceIds },\n          status: \"idle\",\n        };\n      case \"setStatus\":\n        return { ...state, status: action.payload };\n      case \"setExplorerUrls\":\n        return {\n          ...state,\n          explorerUrls: { ...state.explorerUrls, ...action.payload },\n        };\n      case \"setError\":\n        return { ...state, error: action.payload };\n      case \"setLastResult\":\n        return { ...state, lastResult: action.payload };\n      case \"reset\":\n        return createInitialState();\n      default:\n        return state;\n    }\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { inputs, status, explorerUrls, error: txError, lastResult } = state;\n\n  const setInputs = (next: Partial<DepositInputs>) => {\n    dispatch({ type: \"setInputs\", payload: next });\n  };\n\n  const setTxError = (error: string | null) => {\n    dispatch({ type: \"setError\", payload: error });\n  };\n\n  const loading = status === \"executing\";\n  const isProcessing = status === \"executing\";\n  const isSuccess = status === \"success\";\n  const isError = status === \"error\";\n\n  // Simulation state (useState)\n  const [simulation, setSimulation] =\n    useState<BridgeAndExecuteSimulationResult | null>(null);\n  const [simulating, setSimulating] = useState(false);\n\n  // Derived: refreshing = simulating while we already have a simulation\n  const refreshing = simulating && simulation !== null;\n\n  // Refs for non-rendering state\n  const autoAllowRef = useRef(false);\n  const transactionStartedRef = useRef(false);\n  const simulationRequestIdRef = useRef(0);\n  const activeSimulationIdRef = useRef<number | null>(null);\n\n  const {\n    steps,\n    onStepsList,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<BridgeStepType>();\n\n  const unfilteredBridgableBalance = useMemo(() => {\n    const tokenBalance = bridgableBalance?.find((bal) => bal?.symbol === token);\n    if (!tokenBalance) return undefined;\n\n    const nonZeroBreakdown = tokenBalance.breakdown.filter(\n      (chain) => Number.parseFloat(chain.balance) > 0\n    );\n\n    const totalBalance = nonZeroBreakdown.reduce(\n      (sum, chain) => sum + Number.parseFloat(chain.balance),\n      0\n    );\n\n    const totalBalanceInFiat = nonZeroBreakdown.reduce(\n      (sum, chain) => sum + chain.balanceInFiat,\n      0\n    );\n\n    return {\n      ...tokenBalance,\n      balance: totalBalance.toString(),\n      balanceInFiat: totalBalanceInFiat,\n      breakdown: nonZeroBreakdown,\n    };\n  }, [bridgableBalance, token]);\n\n  const filteredBridgableBalance = useMemo(() => {\n    const tokenBalance = bridgableBalance?.find((bal) => bal?.symbol === token);\n    if (!tokenBalance) return undefined;\n\n    const selectedSourcesSet = new Set(inputs.selectedSources);\n    const filteredBreakdown = tokenBalance.breakdown.filter(\n      (chain) =>\n        selectedSourcesSet.has(chain.chain.id) &&\n        Number.parseFloat(chain.balance) > 0\n    );\n\n    const totalBalance = filteredBreakdown.reduce(\n      (sum, chain) => sum + Number.parseFloat(chain.balance),\n      0\n    );\n\n    const totalBalanceInFiat = filteredBreakdown.reduce(\n      (sum, chain) => sum + chain.balanceInFiat,\n      0\n    );\n\n    return {\n      ...tokenBalance,\n      balance: totalBalance.toString(),\n      balanceInFiat: totalBalanceInFiat,\n      breakdown: filteredBreakdown,\n    };\n  }, [bridgableBalance, token, inputs.selectedSources]);\n\n  const allCompleted = useMemo(\n    () => (steps?.length ?? 0) > 0 && steps.every((s) => s.completed),\n    [steps]\n  );\n\n  const stopwatch = useStopwatch({\n    running: isProcessing && !allCompleted && transactionStartedRef.current,\n    intervalMs: 100,\n  });\n\n  const debouncedAmount = useDebouncedValue(inputs?.amount ?? \"\", 1200);\n\n  const feeBreakdown = useMemo(() => {\n    if (!nexusSDK || !simulation || !token)\n      return {\n        totalGasFee: 0,\n        bridgeUsd: 0,\n        bridgeFormatted: \"0\",\n        gasUsd: 0,\n        gasFormatted: \"0\",\n      };\n    const native = CHAIN_METADATA[chain]?.nativeCurrency;\n    const nativeSymbol = native.symbol;\n    const nativeDecimals = native.decimals;\n\n    const gasFormatted =\n      nexusSDK?.utils?.formatTokenBalance(\n        simulation?.executeSimulation?.gasFee,\n        {\n          symbol: nativeSymbol,\n          decimals: nativeDecimals,\n        }\n      ) ?? \"0\";\n    const gasUnits = Number.parseFloat(\n      nexusSDK?.utils?.formatUnits(\n        simulation?.executeSimulation?.gasFee,\n        nativeDecimals\n      )\n    );\n\n    const gasUsd = getFiatValue(gasUnits, nativeSymbol);\n    if (simulation?.bridgeSimulation) {\n      const tokenDecimals =\n        simulation?.bridgeSimulation?.intent?.token?.decimals;\n      const bridgeFormatted =\n        nexusSDK?.utils?.formatTokenBalance(\n          simulation?.bridgeSimulation?.intent?.fees?.total,\n          {\n            symbol: token,\n            decimals: tokenDecimals,\n          }\n        ) ?? \"0\";\n      const bridgeUsd = getFiatValue(\n        Number.parseFloat(simulation?.bridgeSimulation?.intent?.fees?.total),\n        token\n      );\n\n      const totalGasFee = bridgeUsd + gasUsd;\n\n      return {\n        totalGasFee: `$${totalGasFee.toFixed(4)} USD`,\n        bridgeUsd,\n        bridgeFormatted,\n        gasUsd,\n        gasFormatted,\n      };\n    }\n    return {\n      totalGasFee: gasFormatted,\n      gasUsd,\n      gasFormatted,\n    };\n  }, [nexusSDK, simulation, chain, token, getFiatValue]);\n\n  const handleTransaction = async () => {\n    if (!inputs?.amount || !inputs?.chain) return;\n    if (!inputs.selectedSources?.length) {\n      dispatch({\n        type: \"setError\",\n        payload: \"Select at least 1 source chain to continue.\",\n      });\n      return;\n    }\n    dispatch({ type: \"setStatus\", payload: \"executing\" });\n    dispatch({ type: \"setError\", payload: null });\n    try {\n      if (!nexusSDK) throw new Error(\"Nexus SDK not initialized\");\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        inputs.amount,\n        token,\n        inputs.chain\n      );\n      const executeParams: Omit<ExecuteParams, \"toChainId\"> | undefined =\n        executeBuilder\n          ? executeBuilder(token, inputs.amount, inputs.chain, address)\n          : executeConfig;\n      const params: BridgeAndExecuteParams = {\n        token,\n        amount: amountBigInt,\n        toChainId: inputs.chain,\n        sourceChains: inputs.selectedSources,\n        execute: executeParams as Omit<ExecuteParams, \"toChainId\">,\n        waitForReceipt: true,\n      };\n\n      const result: BridgeAndExecuteResult = await nexusSDK.bridgeAndExecute(\n        params,\n        {\n          onEvent: (event) => {\n            if (event.name === NEXUS_EVENTS.STEPS_LIST) {\n              const list = Array.isArray(event.args) ? event.args : [];\n              onStepsList(list);\n            }\n            if (event.name === NEXUS_EVENTS.STEP_COMPLETE) {\n              if (\n                !transactionStartedRef.current &&\n                event.args.type === \"INTENT_HASH_SIGNED\"\n              ) {\n                transactionStartedRef.current = true;\n              }\n              onStepComplete(event.args);\n            }\n          },\n        }\n      );\n\n      if (!result) {\n        dispatch({ type: \"setError\", payload: \"Transaction rejected by user\" });\n        dispatch({ type: \"setStatus\", payload: \"error\" });\n        return;\n      }\n      dispatch({ type: \"setLastResult\", payload: result });\n      dispatch({\n        type: \"setExplorerUrls\",\n        payload: {\n          intentUrl: result.bridgeExplorerUrl ?? null,\n          executeUrl: result.executeExplorerUrl ?? null,\n        },\n      });\n      await onSuccess();\n    } catch (error) {\n      const { message } = handleNexusError(error);\n      intent.current?.deny();\n      intent.current = null;\n      allowance.current = null;\n      dispatch({ type: \"setError\", payload: message });\n      dispatch({ type: \"setStatus\", payload: \"error\" });\n    }\n  };\n\n  const simulate = async (overrideAmount?: string) => {\n    if (!nexusSDK || isProcessing || isSuccess) return;\n\n    const amountToUse = overrideAmount ?? inputs?.amount;\n\n    if (!amountToUse || !inputs?.chain) {\n      activeSimulationIdRef.current = null;\n      setSimulation(null);\n      return;\n    }\n    if (\n      Number.parseFloat(amountToUse) >\n      Number.parseFloat(filteredBridgableBalance?.balance ?? \"0\")\n    ) {\n      activeSimulationIdRef.current = null;\n      dispatch({ type: \"setError\", payload: \"Insufficient balance\" });\n      setSimulation(null);\n      return;\n    }\n    if (!inputs.selectedSources?.length) {\n      activeSimulationIdRef.current = null;\n      dispatch({\n        type: \"setError\",\n        payload: \"Select at least 1 source chain to continue.\",\n      });\n      setSimulation(null);\n      return;\n    }\n    const requestId = ++simulationRequestIdRef.current;\n    activeSimulationIdRef.current = requestId;\n    setSimulating(true);\n    try {\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        amountToUse,\n        token,\n        inputs.chain\n      );\n      const executeParams: Omit<ExecuteParams, \"toChainId\"> | undefined =\n        executeBuilder\n          ? executeBuilder(token, amountToUse, inputs.chain, address)\n          : executeConfig;\n      const params: BridgeAndExecuteParams = {\n        token,\n        amount: amountBigInt,\n        toChainId: inputs.chain,\n        sourceChains: inputs.selectedSources,\n        execute: executeParams as Omit<ExecuteParams, \"toChainId\">,\n        waitForReceipt: false,\n      };\n      const sim = await nexusSDK.simulateBridgeAndExecute(params);\n      if (activeSimulationIdRef.current !== requestId) {\n        return;\n      }\n      if (sim) {\n        dispatch({ type: \"setError\", payload: null });\n        setSimulation(sim);\n      } else {\n        setSimulation(null);\n        dispatch({ type: \"setError\", payload: \"Simulation failed\" });\n      }\n    } catch (error) {\n      if (activeSimulationIdRef.current !== requestId) {\n        return;\n      }\n      setSimulation(null);\n      const { message } = handleNexusError(error);\n      dispatch({ type: \"setError\", payload: message });\n    } finally {\n      if (activeSimulationIdRef.current === requestId) {\n        setSimulating(false);\n      }\n    }\n  };\n\n  const refreshSimulation = async () => {\n    if (simulating) return;\n    if (!simulation?.bridgeSimulation?.intent) return;\n    if (!inputs?.amount) return;\n    await simulate(inputs?.amount);\n  };\n\n  const onSuccess = async () => {\n    stopwatch.stop();\n    dispatch({ type: \"setStatus\", payload: \"success\" });\n    await fetchBridgableBalance();\n  };\n\n  const resetState = useCallback(() => {\n    allowance.current = null;\n    intent.current = null;\n    setSimulation(null);\n    setSimulating(false);\n    transactionStartedRef.current = false;\n    autoAllowRef.current = false;\n    activeSimulationIdRef.current = null;\n    resetSteps();\n    stopwatch.stop();\n    stopwatch.reset();\n    dispatch({ type: \"reset\" });\n  }, [allowance, intent, resetSteps, stopwatch]);\n\n  const reset = useCallback(() => {\n    intent.current?.deny();\n    resetState();\n  }, [intent, resetState]);\n\n  const startTransaction = useCallback(() => {\n    // Prevent re-entrancy while a transaction is already executing\n    if (isProcessing) return;\n    activeSimulationIdRef.current = null;\n    setSimulating(false);\n    dispatch({ type: \"setError\", payload: null });\n    autoAllowRef.current = true;\n    void handleTransaction();\n  }, [handleTransaction, isProcessing]);\n\n  useEffect(() => {\n    const hasRequiredInputs =\n      Boolean(debouncedAmount) && Boolean(inputs?.chain) && Boolean(token);\n    if (!hasRequiredInputs || isProcessing || isSuccess) return;\n    void simulate(debouncedAmount);\n  }, [debouncedAmount, inputs?.chain, token, isProcessing, isSuccess]);\n\n  useEffect(() => {\n    if (autoAllowRef.current && intent.current) {\n      intent.current.allow();\n      autoAllowRef.current = false;\n    }\n  }, [intent.current]);\n\n  usePolling(\n    Boolean(simulation?.bridgeSimulation?.intent) &&\n      !isProcessing &&\n      !isSuccess,\n    async () => {\n      await refreshSimulation();\n    },\n    15000\n  );\n\n  return {\n    // State\n    inputs,\n    setInputs,\n    status,\n    explorerUrls,\n\n    // Derived state\n    loading,\n    isProcessing,\n    isSuccess,\n    isError,\n    simulating,\n    refreshing,\n\n    // Error handling\n    txError,\n    setTxError,\n\n    // Timer\n    timer: stopwatch.seconds,\n\n    // Balance data\n    filteredBridgableBalance,\n    unfilteredBridgableBalance,\n\n    // Simulation data\n    simulation,\n    lastResult,\n    steps,\n    feeBreakdown,\n\n    // Actions\n    handleTransaction,\n    startTransaction,\n    reset,\n    simulate,\n    cancelSimulation: () => {\n      activeSimulationIdRef.current = null;\n      setSimulating(false);\n      setSimulation(null);\n    },\n  };\n};\n\nexport default useDeposit;\n",
      "type": "registry:component",
      "target": "components/bridge-deposit/hooks/useDeposit.ts"
    },
    {
      "path": "registry/nexus-elements/common/components/ErrorBoundary.tsx",
      "content": "\"use client\";\n\nimport { Component, type ErrorInfo, type ReactNode } from \"react\";\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n}\n\n/**\n * Error boundary component that catches JavaScript errors in child components.\n * Displays a fallback UI instead of crashing the entire widget.\n *\n * @example\n * <ErrorBoundary\n *   fallback={<div>Something went wrong</div>}\n *   onError={(error) => console.error(error)}\n * >\n *   <MyComponent />\n * </ErrorBoundary>\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\"ErrorBoundary caught an error:\", error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n          <div className=\"text-destructive font-medium mb-2\">\n            Something went wrong\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            An unexpected error occurred. Please try again.\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false, error: null })}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * A more specific error boundary for widget containers with reset capability.\n */\ninterface WidgetErrorBoundaryProps extends ErrorBoundaryProps {\n  widgetName?: string;\n  onReset?: () => void;\n}\n\nexport class WidgetErrorBoundary extends Component<\n  WidgetErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: WidgetErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error(\n      `WidgetErrorBoundary [${this.props.widgetName ?? \"Unknown\"}]:`,\n      error,\n      errorInfo\n    );\n    this.props.onError?.(error, errorInfo);\n  }\n\n  handleReset = (): void => {\n    this.props.onReset?.();\n    this.setState({ hasError: false, error: null });\n  };\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex flex-col items-center justify-center p-6 text-center bg-destructive/5 rounded-lg border border-destructive/20\">\n          <div className=\"text-destructive font-medium mb-2\">\n            {this.props.widgetName\n              ? `${this.props.widgetName} encountered an error`\n              : \"Widget error\"}\n          </div>\n          <p className=\"text-muted-foreground text-sm mb-4\">\n            {this.state.error?.message || \"An unexpected error occurred.\"}\n          </p>\n          <button\n            onClick={this.handleReset}\n            className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 transition-colors\"\n          >\n            Reset widget\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/components/ErrorBoundary.tsx"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedCallback.ts",
      "content": "import { useEffect, useMemo, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype AnyFn = (...args: any[]) => any;\n\nexport interface Debounced<T extends AnyFn> {\n  (...args: Parameters<T>): void;\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Returns a debounced function that delays invoking `fn` until after `delay`\n * milliseconds have elapsed since the last call.\n */\nexport function useDebouncedCallback<T extends AnyFn>(\n  fn: T,\n  delay: number\n): Debounced<T> {\n  const latest = useStableCallback(fn);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  const cancel = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const flush = () => {\n    if (timerRef.current && lastArgsRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n       \n      latest(...lastArgsRef.current);\n      lastArgsRef.current = null;\n    }\n  };\n\n  // cancel when delay changes/unmounts\n  useEffect(() => cancel, [delay]);\n\n  return useMemo(() => {\n    const debounced = ((...args: Parameters<T>) => {\n      lastArgsRef.current = args;\n      cancel();\n      timerRef.current = setTimeout(() => {\n         \n        latest(...lastArgsRef.current!);\n        lastArgsRef.current = null;\n        timerRef.current = null;\n      }, delay);\n    }) as Debounced<T>;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, latest]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useDebouncedValue.ts",
      "content": "import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\n\n/**\n * Derives a debounced value from an input value and delay.\n */\nexport function useDebouncedValue<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState<T>(value);\n  const setter = useDebouncedCallback((v: T) => setDebounced(v), delay);\n\n  useEffect(() => {\n    setter(value);\n    return setter.cancel;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, delay]);\n\n  return debounced;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useDebouncedValue.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useInterval.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ninterface UseIntervalOptions {\n  enabled?: boolean;\n  immediate?: boolean;\n}\n\n/**\n * Declarative setInterval with pause/resume and latest-callback semantics.\n * Pass delay=null to pause.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options: UseIntervalOptions = {}\n) {\n  const { enabled = true, immediate = false } = options;\n  const savedCallback = useStableCallback(callback);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (!enabled || delay == null) return;\n    if (immediate) {\n      savedCallback();\n    }\n    intervalRef.current = setInterval(savedCallback, delay);\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [delay, enabled, immediate, savedCallback]);\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useInterval.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useLatest.ts",
      "content": "import { useRef, useLayoutEffect } from \"react\";\n\n/**\n * Returns a ref that always contains the latest value.\n * Useful for accessing current values in callbacks without causing re-renders.\n *\n * @example\n * const countRef = useLatest(count);\n * const handleClick = useCallback(() => {\n *   console.log(countRef.current); // Always the latest count\n * }, []); // No dependency needed!\n */\nexport function useLatest<T>(value: T): React.MutableRefObject<T> {\n  const ref = useRef<T>(value);\n\n  // Use useLayoutEffect to update synchronously before any effects run\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n\n  return ref;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useLatest.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useNexusError.ts",
      "content": "import { NexusError } from \"@avail-project/nexus-core\";\n\nfunction handler(err: unknown) {\n  if (err instanceof NexusError) {\n    return {\n      code: err?.code,\n      message: err?.message,\n      context: err?.data?.context,\n      details: err?.data?.details,\n    };\n  } else {\n    console.error(\"Unexpected error:\", err);\n    return {\n      code: \"unexpected_error\",\n      message: \"Oops! Something went wrong. Please try again.\",\n      context: undefined,\n      details: undefined,\n    };\n  }\n}\nexport function useNexusError() {\n  return handler;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useNexusError.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/usePolling.ts",
      "content": "import { useRef } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { useStableCallback } from \"./useStableCallback\";\n\n/**\n * Declarative polling with in-flight protection (no overlap).\n * When enabled becomes true, an immediate run is executed,\n * followed by interval-based runs.\n */\nexport function usePolling(\n  enabled: boolean,\n  fn: () => Promise<void> | void,\n  intervalMs: number\n) {\n  const inFlightRef = useRef(false);\n  const wrapped = useStableCallback(async () => {\n    if (inFlightRef.current) return;\n    try {\n      inFlightRef.current = true;\n      await fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      inFlightRef.current = false;\n    }\n  });\n\n  useInterval(wrapped, enabled ? intervalMs : null, {\n    enabled,\n    immediate: enabled,\n  });\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/usePolling.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStableCallback.ts",
      "content": "import { useCallback, useRef } from \"react\";\n\n/**\n * Returns a stable function identity that always calls the latest implementation.\n * Useful when passing callbacks to memoized children without re-creating handlers.\n */\nexport function useStableCallback<Args extends readonly unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const fnRef = useRef<(...args: Args) => Return>(fn);\n  fnRef.current = fn;\n\n   \n  const stable = useCallback(\n    ((...args: Args) => {\n      return fnRef.current(...args);\n    }) as (...args: Args) => Return,\n    []\n  );\n\n  return stable;\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStableCallback.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useStopwatch.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\ninterface UseStopwatchOptions {\n  running?: boolean;\n  intervalMs?: number;\n}\n\n/**\n * Simple stopwatch that increments elapsed seconds while running.\n * Designed to replace scattered timer effects.\n */\nexport function useStopwatch(options: UseStopwatchOptions = {}) {\n  const { running = false, intervalMs = 100 } = options;\n  const [elapsedSeconds, setElapsedSeconds] = useState(0);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const reset = () => {\n    setElapsedSeconds(0);\n  };\n\n  const stop = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n\n  const start = () => {\n    if (timerRef.current) return;\n    timerRef.current = setInterval(() => {\n      // 1s == 1000ms; we add fractional seconds per tick\n      setElapsedSeconds((prev) => prev + intervalMs / 1000);\n    }, intervalMs);\n  };\n\n  useEffect(() => {\n    if (running) {\n      start();\n    } else {\n      stop();\n    }\n    return stop;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [running, intervalMs]);\n\n  return {\n    seconds: elapsedSeconds,\n    start,\n    stop,\n    reset,\n    running: Boolean(timerRef.current),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useStopwatch.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useTransactionExecution.ts",
      "content": "import {\n  type BridgeStepType,\n  NEXUS_EVENTS,\n  type NexusSDK,\n  type OnAllowanceHookData,\n  type OnIntentHookData,\n} from \"@avail-project/nexus-core\";\nimport {\n  type Dispatch,\n  type RefObject,\n  type SetStateAction,\n  useCallback,\n  useRef,\n} from \"react\";\nimport { type TransactionStatus } from \"../tx/types\";\nimport {\n  type SourceSelectionValidation,\n  type TransactionFlowEvent,\n  type TransactionFlowExecutor,\n  type TransactionFlowInputs,\n} from \"../types/transaction-flow\";\n\ninterface NexusErrorInfo {\n  code: string;\n  message: string;\n  context?: unknown;\n  details?: unknown;\n}\n\ntype NexusErrorHandler = (error: unknown) => NexusErrorInfo;\n\ninterface UseTransactionExecutionProps {\n  operationName: \"bridge\" | \"transfer\";\n  nexusSDK: NexusSDK | null;\n  intent: RefObject<OnIntentHookData | null>;\n  allowance: RefObject<OnAllowanceHookData | null>;\n  inputs: TransactionFlowInputs;\n  configuredMaxAmount?: string;\n  allAvailableSourceChainIds: number[];\n  sourceChainsForSdk?: number[];\n  sourceSelectionKey: string;\n  sourceSelection: SourceSelectionValidation;\n  loading: boolean;\n  txError: string | null;\n  areInputsValid: boolean;\n  executeTransaction: TransactionFlowExecutor;\n  getMaxForCurrentSelection: () => Promise<string | undefined>;\n  onStepsList: (steps: BridgeStepType[]) => void;\n  onStepComplete: (step: BridgeStepType) => void;\n  resetSteps: () => void;\n  setStatus: (status: TransactionStatus) => void;\n  resetInputs: () => void;\n  setRefreshing: Dispatch<SetStateAction<boolean>>;\n  setIsDialogOpen: Dispatch<SetStateAction<boolean>>;\n  setTxError: Dispatch<SetStateAction<string | null>>;\n  setLastExplorerUrl: Dispatch<SetStateAction<string>>;\n  setSelectedSourceChains: Dispatch<SetStateAction<number[] | null>>;\n  setAppliedSourceSelectionKey: Dispatch<SetStateAction<string>>;\n  stopwatch: {\n    start: () => void;\n    stop: () => void;\n    reset: () => void;\n  };\n  handleNexusError: NexusErrorHandler;\n  onStart?: () => void;\n  onComplete?: () => void;\n  onError?: (message: string) => void;\n  fetchBalance: () => Promise<void>;\n  notifyHistoryRefresh?: () => void;\n}\n\nexport function useTransactionExecution({\n  operationName,\n  nexusSDK,\n  intent,\n  allowance,\n  inputs,\n  configuredMaxAmount,\n  allAvailableSourceChainIds,\n  sourceChainsForSdk,\n  sourceSelectionKey,\n  sourceSelection,\n  loading,\n  txError,\n  areInputsValid,\n  executeTransaction,\n  getMaxForCurrentSelection,\n  onStepsList,\n  onStepComplete,\n  resetSteps,\n  setStatus,\n  resetInputs,\n  setRefreshing,\n  setIsDialogOpen,\n  setTxError,\n  setLastExplorerUrl,\n  setSelectedSourceChains,\n  setAppliedSourceSelectionKey,\n  stopwatch,\n  handleNexusError,\n  onStart,\n  onComplete,\n  onError,\n  fetchBalance,\n  notifyHistoryRefresh,\n}: UseTransactionExecutionProps) {\n  const commitLockRef = useRef(false);\n  const runIdRef = useRef(0);\n\n  const refreshIntent = async (options?: { reportError?: boolean }) => {\n    if (!intent.current) return false;\n    const activeRunId = runIdRef.current;\n    setRefreshing(true);\n    try {\n      const updated = await intent.current.refresh(sourceChainsForSdk);\n      if (activeRunId !== runIdRef.current) return false;\n      if (updated) {\n        intent.current.intent = updated;\n      }\n      setAppliedSourceSelectionKey(sourceSelectionKey);\n      return true;\n    } catch (error) {\n      if (activeRunId !== runIdRef.current) return false;\n      console.error(\"Transaction failed:\", error);\n      if (options?.reportError) {\n        const message = \"Unable to refresh source selection. Please try again.\";\n        setTxError(message);\n        onError?.(message);\n      }\n      return false;\n    } finally {\n      if (activeRunId !== runIdRef.current) return;\n      setRefreshing(false);\n    }\n  };\n\n  const onSuccess = async () => {\n    stopwatch.stop();\n    setStatus(\"success\");\n    onComplete?.();\n    intent.current = null;\n    allowance.current = null;\n    resetInputs();\n    setRefreshing(false);\n    setSelectedSourceChains(null);\n    setAppliedSourceSelectionKey(\"ALL\");\n    await fetchBalance();\n    notifyHistoryRefresh?.();\n  };\n\n  const handleTransaction = async () => {\n    if (commitLockRef.current) return;\n    commitLockRef.current = true;\n    const currentRunId = ++runIdRef.current;\n    let didEnterExecutingState = false;\n    const cleanupSupersededExecution = () => {\n      if (!didEnterExecutingState) return;\n      setRefreshing(false);\n      setIsDialogOpen(false);\n      setLastExplorerUrl(\"\");\n      stopwatch.stop();\n      stopwatch.reset();\n      resetSteps();\n      setStatus(\"idle\");\n    };\n\n    try {\n      if (\n        !inputs?.amount ||\n        !inputs?.recipient ||\n        !inputs?.chain ||\n        !inputs?.token\n      ) {\n        console.error(\"Missing required inputs\");\n        return;\n      }\n      if (!nexusSDK) {\n        const message = \"Nexus SDK not initialized\";\n        setTxError(message);\n        onError?.(message);\n        return;\n      }\n      if (allAvailableSourceChainIds.length === 0) {\n        const message =\n          \"No eligible source chains available for the selected token and destination.\";\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      const parsedAmount = Number(inputs.amount);\n      if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {\n        const message = \"Enter a valid amount greater than 0.\";\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      const amountBigInt = nexusSDK.convertTokenReadableAmountToBigInt(\n        inputs.amount,\n        inputs.token,\n        inputs.chain,\n      );\n\n      if (configuredMaxAmount) {\n        const configuredMaxRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n          configuredMaxAmount,\n          inputs.token,\n          inputs.chain,\n        );\n        if (amountBigInt > configuredMaxRaw) {\n          const message = `Amount exceeds maximum limit of ${configuredMaxAmount} ${inputs.token}.`;\n          setTxError(message);\n          onError?.(message);\n          setStatus(\"error\");\n          return;\n        }\n      }\n\n      const maxForCurrentSelection = await getMaxForCurrentSelection();\n      if (currentRunId !== runIdRef.current) return;\n      if (!maxForCurrentSelection) {\n        const message = `Unable to determine max ${operationName} amount for selected sources. Please try again.`;\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n      const maxForSelectionRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n        maxForCurrentSelection,\n        inputs.token,\n        inputs.chain,\n      );\n      if (amountBigInt > maxForSelectionRaw) {\n        const message = `Selected sources can provide up to ${maxForCurrentSelection} ${inputs.token}. Reduce amount or enable more sources.`;\n        setTxError(message);\n        onError?.(message);\n        setStatus(\"error\");\n        return;\n      }\n\n      setStatus(\"executing\");\n      didEnterExecutingState = true;\n      setTxError(null);\n      onStart?.();\n      setLastExplorerUrl(\"\");\n      setAppliedSourceSelectionKey(sourceSelectionKey);\n\n      const onEvent = (event: TransactionFlowEvent) => {\n        if (currentRunId !== runIdRef.current) return;\n        if (event.name === NEXUS_EVENTS.STEPS_LIST) {\n          const list = Array.isArray(event.args) ? event.args : [];\n          onStepsList(list as BridgeStepType[]);\n        }\n        if (event.name === NEXUS_EVENTS.STEP_COMPLETE) {\n          if (\n            !Array.isArray(event.args) &&\n            \"type\" in event.args &&\n            event.args.type === \"INTENT_HASH_SIGNED\"\n          ) {\n            stopwatch.start();\n          }\n          if (!Array.isArray(event.args)) {\n            onStepComplete(event.args as BridgeStepType);\n          }\n        }\n      };\n\n      const transactionResult = await executeTransaction({\n        token: inputs.token,\n        amount: amountBigInt,\n        toChainId: inputs.chain,\n        recipient: inputs.recipient,\n        sourceChains: sourceChainsForSdk,\n        onEvent,\n      });\n\n      if (currentRunId !== runIdRef.current) {\n        cleanupSupersededExecution();\n        return;\n      }\n      if (!transactionResult) {\n        throw new Error(\"Transaction rejected by user\");\n      }\n      setLastExplorerUrl(transactionResult.explorerUrl);\n      await onSuccess();\n    } catch (error) {\n      if (currentRunId !== runIdRef.current) {\n        cleanupSupersededExecution();\n        return;\n      }\n      const { message, code, context, details } = handleNexusError(error);\n      console.error(`Fast ${operationName} transaction failed:`, {\n        code,\n        message,\n        context,\n        details,\n      });\n      intent.current?.deny();\n      intent.current = null;\n      allowance.current = null;\n      setTxError(message);\n      onError?.(message);\n      setIsDialogOpen(false);\n      setSelectedSourceChains(null);\n      setRefreshing(false);\n      stopwatch.stop();\n      stopwatch.reset();\n      resetSteps();\n      void fetchBalance();\n      setStatus(\"error\");\n    } finally {\n      commitLockRef.current = false;\n    }\n  };\n\n  const reset = () => {\n    runIdRef.current += 1;\n    intent.current?.deny();\n    intent.current = null;\n    allowance.current = null;\n    resetInputs();\n    setStatus(\"idle\");\n    setRefreshing(false);\n    setSelectedSourceChains(null);\n    setAppliedSourceSelectionKey(\"ALL\");\n    setLastExplorerUrl(\"\");\n    stopwatch.stop();\n    stopwatch.reset();\n    resetSteps();\n  };\n\n  const startTransaction = () => {\n    if (!intent.current) return;\n    if (allAvailableSourceChainIds.length === 0) {\n      const message =\n        \"No eligible source chains available for the selected token and destination.\";\n      setTxError(message);\n      onError?.(message);\n      return;\n    }\n    if (sourceSelection.isBelowRequired && inputs?.token) {\n      const message = `Selected sources are not enough. Add ${sourceSelection.missingToProceed} ${inputs.token} more to make this transaction.`;\n      setTxError(message);\n      onError?.(message);\n      return;\n    }\n    void (async () => {\n      const refreshed = await refreshIntent({ reportError: true });\n      if (!refreshed || !intent.current) return;\n      intent.current.allow();\n      setIsDialogOpen(true);\n      setTxError(null);\n    })();\n  };\n\n  const commitAmount = async () => {\n    if (intent.current || loading || txError || !areInputsValid) return;\n    await handleTransaction();\n  };\n\n  const invalidatePendingExecution = useCallback(() => {\n    runIdRef.current += 1;\n    if (intent.current) {\n      intent.current.deny();\n      intent.current = null;\n    }\n    setRefreshing(false);\n    setAppliedSourceSelectionKey(\"ALL\");\n  }, [intent, setAppliedSourceSelectionKey, setRefreshing]);\n\n  return {\n    refreshIntent,\n    handleTransaction,\n    startTransaction,\n    commitAmount,\n    reset,\n    invalidatePendingExecution,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useTransactionExecution.ts"
    },
    {
      "path": "registry/nexus-elements/common/hooks/useTransactionFlow.ts",
      "content": "import {\n  type BridgeStepType,\n  type NexusNetwork,\n  NexusSDK,\n  type OnAllowanceHookData,\n  type OnIntentHookData,\n  type UserAsset,\n} from \"@avail-project/nexus-core\";\nimport {\n  useEffect,\n  useMemo,\n  useCallback,\n  useRef,\n  useState,\n  useReducer,\n  type RefObject,\n} from \"react\";\nimport { type Address, isAddress } from \"viem\";\nimport { useNexusError } from \"./useNexusError\";\nimport { useTransactionExecution } from \"./useTransactionExecution\";\nimport { usePolling } from \"./usePolling\";\nimport { useStopwatch } from \"./useStopwatch\";\nimport { useDebouncedCallback } from \"./useDebouncedCallback\";\nimport { type TransactionStatus } from \"../tx/types\";\nimport { useTransactionSteps } from \"../tx/useTransactionSteps\";\nimport {\n  type SourceCoverageState,\n  type TransactionFlowExecutor,\n  type TransactionFlowInputs,\n  type TransactionFlowPrefill,\n  type TransactionFlowType,\n} from \"../types/transaction-flow\";\nimport {\n  MAX_AMOUNT_DEBOUNCE_MS,\n  buildInitialInputs,\n  clampAmountToMax,\n  formatAmountForDisplay,\n  getCoverageDecimals,\n  normalizeMaxAmount,\n} from \"../utils/transaction-flow\";\n\ninterface BaseTransactionFlowProps {\n  type: TransactionFlowType;\n  network: NexusNetwork;\n  nexusSDK: NexusSDK | null;\n  intent: RefObject<OnIntentHookData | null>;\n  allowance: RefObject<OnAllowanceHookData | null>;\n  bridgableBalance: UserAsset[] | null;\n  prefill?: TransactionFlowPrefill;\n  onComplete?: () => void;\n  onStart?: () => void;\n  onError?: (message: string) => void;\n  fetchBalance: () => Promise<void>;\n  maxAmount?: string | number;\n  isSourceMenuOpen?: boolean;\n  notifyHistoryRefresh?: () => void;\n  executeTransaction: TransactionFlowExecutor;\n}\n\nexport interface UseTransactionFlowProps extends BaseTransactionFlowProps {\n  connectedAddress?: Address;\n}\n\ntype State = {\n  inputs: TransactionFlowInputs;\n  status: TransactionStatus;\n};\n\ntype Action =\n  | { type: \"setInputs\"; payload: Partial<TransactionFlowInputs> }\n  | { type: \"resetInputs\" }\n  | { type: \"setStatus\"; payload: TransactionStatus };\n\nexport function useTransactionFlow(props: UseTransactionFlowProps) {\n  const {\n    type,\n    network,\n    nexusSDK,\n    intent,\n    bridgableBalance,\n    prefill,\n    onComplete,\n    onStart,\n    onError,\n    fetchBalance,\n    allowance,\n    maxAmount,\n    isSourceMenuOpen = false,\n    notifyHistoryRefresh,\n    executeTransaction,\n  } = props;\n\n  const connectedAddress = props.connectedAddress;\n  const operationName = type === \"bridge\" ? \"bridge\" : \"transfer\";\n  const handleNexusError = useNexusError();\n  const initialState: State = {\n    inputs: buildInitialInputs({ type, network, connectedAddress, prefill }),\n    status: \"idle\",\n  };\n\n  function reducer(state: State, action: Action): State {\n    switch (action.type) {\n      case \"setInputs\":\n        return { ...state, inputs: { ...state.inputs, ...action.payload } };\n      case \"resetInputs\":\n        return {\n          ...state,\n          inputs: buildInitialInputs({\n            type,\n            network,\n            connectedAddress,\n            prefill,\n          }),\n        };\n      case \"setStatus\":\n        return { ...state, status: action.payload };\n      default:\n        return state;\n    }\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const inputs = state.inputs;\n  const setInputs = (\n    next: TransactionFlowInputs | Partial<TransactionFlowInputs>,\n  ) => {\n    dispatch({\n      type: \"setInputs\",\n      payload: next as Partial<TransactionFlowInputs>,\n    });\n  };\n\n  const loading = state.status === \"executing\";\n  const [refreshing, setRefreshing] = useState(false);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [txError, setTxError] = useState<string | null>(null);\n  const [lastExplorerUrl, setLastExplorerUrl] = useState<string>(\"\");\n  const previousConnectedAddressRef = useRef<Address | undefined>(\n    connectedAddress,\n  );\n  const maxAmountRequestIdRef = useRef(0);\n  const [selectedSourceChains, setSelectedSourceChains] = useState<\n    number[] | null\n  >(null);\n  const [selectedSourcesMaxAmount, setSelectedSourcesMaxAmount] = useState<\n    string | null\n  >(null);\n  const [appliedSourceSelectionKey, setAppliedSourceSelectionKey] =\n    useState(\"ALL\");\n  const {\n    steps,\n    onStepsList,\n    onStepComplete,\n    reset: resetSteps,\n  } = useTransactionSteps<BridgeStepType>();\n  const configuredMaxAmount = useMemo(\n    () => normalizeMaxAmount(maxAmount),\n    [maxAmount],\n  );\n\n  const areInputsValid = useMemo(() => {\n    const hasToken = inputs?.token !== undefined && inputs?.token !== null;\n    const hasChain = inputs?.chain !== undefined && inputs?.chain !== null;\n    const hasAmount = Boolean(inputs?.amount) && Number(inputs?.amount) > 0;\n    const hasValidRecipient =\n      Boolean(inputs?.recipient) && isAddress(inputs.recipient as string);\n    return hasToken && hasChain && hasAmount && hasValidRecipient;\n  }, [inputs]);\n\n  const filteredBridgableBalance = useMemo(() => {\n    return bridgableBalance?.find((bal) =>\n      inputs?.token === \"USDM\"\n        ? bal?.symbol === \"USDC\"\n        : bal?.symbol === inputs?.token,\n    );\n  }, [bridgableBalance, inputs?.token]);\n\n  const availableSources = useMemo(() => {\n    const breakdown = filteredBridgableBalance?.breakdown ?? [];\n    const destinationChainId = inputs?.chain;\n    const nonZero = breakdown.filter((source) => {\n      if (Number.parseFloat(source.balance ?? \"0\") <= 0) return false;\n      if (typeof destinationChainId === \"number\") {\n        return source.chain.id !== destinationChainId;\n      }\n      return true;\n    });\n    const decimals = filteredBridgableBalance?.decimals;\n    if (!nexusSDK || typeof decimals !== \"number\") {\n      return nonZero.sort(\n        (a, b) => Number.parseFloat(b.balance) - Number.parseFloat(a.balance),\n      );\n    }\n    return nonZero.sort((a, b) => {\n      try {\n        const aRaw = nexusSDK.utils.parseUnits(a.balance ?? \"0\", decimals);\n        const bRaw = nexusSDK.utils.parseUnits(b.balance ?? \"0\", decimals);\n        if (aRaw === bRaw) return 0;\n        return aRaw > bRaw ? -1 : 1;\n      } catch {\n        return Number.parseFloat(b.balance) - Number.parseFloat(a.balance);\n      }\n    });\n  }, [\n    inputs?.chain,\n    filteredBridgableBalance?.breakdown,\n    filteredBridgableBalance?.decimals,\n    nexusSDK,\n  ]);\n\n  const allAvailableSourceChainIds = useMemo(\n    () => availableSources.map((source) => source.chain.id),\n    [availableSources],\n  );\n\n  const effectiveSelectedSourceChains = useMemo(() => {\n    if (selectedSourceChains && selectedSourceChains.length > 0) {\n      const availableSet = new Set(allAvailableSourceChainIds);\n      const filteredSelection = selectedSourceChains.filter((id) =>\n        availableSet.has(id),\n      );\n      if (filteredSelection.length > 0) {\n        return filteredSelection;\n      }\n    }\n    return allAvailableSourceChainIds;\n  }, [selectedSourceChains, allAvailableSourceChainIds]);\n\n  const sourceChainsForSdk =\n    effectiveSelectedSourceChains.length > 0\n      ? effectiveSelectedSourceChains\n      : undefined;\n\n  const sourceSelectionKey = useMemo(() => {\n    if (allAvailableSourceChainIds.length === 0) return \"NONE\";\n    if (!selectedSourceChains || selectedSourceChains.length === 0) {\n      return \"ALL\";\n    }\n    return [...effectiveSelectedSourceChains].sort((a, b) => a - b).join(\"|\");\n  }, [\n    allAvailableSourceChainIds.length,\n    effectiveSelectedSourceChains,\n    selectedSourceChains,\n  ]);\n  const hasPendingSourceSelectionChanges =\n    sourceSelectionKey !== appliedSourceSelectionKey;\n  const intentSourceSpendAmount = intent.current?.intent?.sourcesTotal;\n\n  const getMaxForCurrentSelection = useCallback(async () => {\n    if (!nexusSDK || !inputs?.token || !inputs?.chain) return undefined;\n    const maxBalAvailable = await nexusSDK.calculateMaxForBridge({\n      token: inputs.token,\n      toChainId: inputs.chain,\n      recipient: inputs.recipient,\n      sourceChains: sourceChainsForSdk,\n    });\n    if (!maxBalAvailable?.amount) return \"0\";\n    return clampAmountToMax({\n      amount: maxBalAvailable.amount,\n      maxAmount: configuredMaxAmount,\n      nexusSDK,\n      token: inputs.token,\n      chainId: inputs.chain,\n    });\n  }, [\n    configuredMaxAmount,\n    inputs?.chain,\n    inputs?.recipient,\n    inputs?.token,\n    nexusSDK,\n    sourceChainsForSdk,\n  ]);\n\n  const toggleSourceChain = useCallback(\n    (chainId: number) => {\n      setSelectedSourceChains((prev) => {\n        if (allAvailableSourceChainIds.length === 0) return prev;\n        const current =\n          prev && prev.length > 0 ? prev : allAvailableSourceChainIds;\n        const next = current.includes(chainId)\n          ? current.filter((id) => id !== chainId)\n          : [...current, chainId];\n        if (next.length === 0) {\n          return current;\n        }\n        const isAllSelected =\n          next.length === allAvailableSourceChainIds.length &&\n          allAvailableSourceChainIds.every((id) => next.includes(id));\n        return isAllSelected ? null : next;\n      });\n    },\n    [allAvailableSourceChainIds],\n  );\n\n  const sourceSelection = useMemo(() => {\n    const amount = intentSourceSpendAmount?.trim() ?? inputs?.amount?.trim() ?? \"\";\n    const decimals = getCoverageDecimals({\n      type,\n      token: inputs?.token,\n      chainId: inputs?.chain,\n      fallback: filteredBridgableBalance?.decimals,\n    });\n    const selectedChainSet = new Set(effectiveSelectedSourceChains);\n    const selectedTotalRaw =\n      !nexusSDK || typeof decimals !== \"number\"\n        ? BigInt(0)\n        : availableSources.reduce((sum, source) => {\n            if (!selectedChainSet.has(source.chain.id)) return sum;\n            try {\n              return (\n                sum + nexusSDK.utils.parseUnits(source.balance ?? \"0\", decimals)\n              );\n            } catch {\n              return sum;\n            }\n          }, BigInt(0));\n    const selectedTotal =\n      !nexusSDK || typeof decimals !== \"number\"\n        ? \"0\"\n        : formatAmountForDisplay(selectedTotalRaw, decimals, nexusSDK);\n    const baseSelection = {\n      selectedTotal,\n      requiredTotal: amount || \"0\",\n      requiredSafetyTotal: amount || \"0\",\n      missingToProceed: \"0\",\n      missingToSafety: \"0\",\n      coverageState: \"healthy\" as SourceCoverageState,\n      coverageToSafetyPercent: 100,\n      isBelowRequired: false,\n      isBelowSafetyBuffer: false,\n    };\n\n    if (!nexusSDK || !inputs?.token || !inputs?.chain || !amount) {\n      return baseSelection;\n    }\n\n    try {\n      const requiredRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n        amount,\n        inputs.token,\n        inputs.chain,\n      );\n      if (requiredRaw <= BigInt(0)) {\n        return baseSelection;\n      }\n\n      const missingToProceedRaw =\n        selectedTotalRaw >= requiredRaw\n          ? BigInt(0)\n          : requiredRaw - selectedTotalRaw;\n      const missingToSafetyRaw = missingToProceedRaw;\n\n      const coverageState: SourceCoverageState =\n        selectedTotalRaw < requiredRaw\n          ? \"error\"\n          : \"healthy\";\n\n      const coverageBasisPoints =\n        requiredRaw === BigInt(0)\n          ? 10_000\n          : selectedTotalRaw >= requiredRaw\n            ? 10_000\n            : Number((selectedTotalRaw * BigInt(10_000)) / requiredRaw);\n\n      return {\n        selectedTotal,\n        requiredTotal: amount,\n        requiredSafetyTotal: amount,\n        missingToProceed: formatAmountForDisplay(\n          missingToProceedRaw,\n          decimals,\n          nexusSDK,\n        ),\n        missingToSafety: formatAmountForDisplay(\n          missingToSafetyRaw,\n          decimals,\n          nexusSDK,\n        ),\n        coverageState,\n        coverageToSafetyPercent: coverageBasisPoints / 100,\n        isBelowRequired: coverageState === \"error\",\n        isBelowSafetyBuffer: coverageState === \"error\",\n      };\n    } catch {\n      return baseSelection;\n    }\n  }, [\n    type,\n    filteredBridgableBalance?.decimals,\n    nexusSDK,\n    inputs?.chain,\n    inputs?.amount,\n    inputs?.token,\n    intentSourceSpendAmount,\n    availableSources,\n    effectiveSelectedSourceChains,\n  ]);\n\n  const stopwatch = useStopwatch({ intervalMs: 100 });\n  const setStatus = useCallback(\n    (status: TransactionStatus) =>\n      dispatch({ type: \"setStatus\", payload: status }),\n    [],\n  );\n\n  const resetInputs = useCallback(() => {\n    dispatch({ type: \"resetInputs\" });\n  }, []);\n\n  const {\n    refreshIntent,\n    handleTransaction,\n    startTransaction,\n    commitAmount,\n    reset,\n    invalidatePendingExecution,\n  } = useTransactionExecution({\n    operationName,\n    nexusSDK,\n    intent,\n    allowance,\n    inputs,\n    configuredMaxAmount,\n    allAvailableSourceChainIds,\n    sourceChainsForSdk,\n    sourceSelectionKey,\n    sourceSelection,\n    loading,\n    txError,\n    areInputsValid,\n    executeTransaction,\n    getMaxForCurrentSelection,\n    onStepsList,\n    onStepComplete,\n    resetSteps,\n    setStatus,\n    resetInputs,\n    setRefreshing,\n    setIsDialogOpen,\n    setTxError,\n    setLastExplorerUrl,\n    setSelectedSourceChains,\n    setAppliedSourceSelectionKey,\n    stopwatch,\n    handleNexusError,\n    onStart,\n    onComplete,\n    onError,\n    fetchBalance,\n    notifyHistoryRefresh,\n  });\n\n  usePolling(\n    Boolean(intent.current) &&\n      !isDialogOpen &&\n      !isSourceMenuOpen &&\n      !hasPendingSourceSelectionChanges,\n    async () => {\n      await refreshIntent();\n    },\n    15000,\n  );\n\n  const debouncedRefreshMaxForSelection = useDebouncedCallback(\n    async (requestId: number) => {\n      try {\n        const maxForCurrentSelection = await getMaxForCurrentSelection();\n        if (requestId !== maxAmountRequestIdRef.current) return;\n        setSelectedSourcesMaxAmount(maxForCurrentSelection ?? \"0\");\n      } catch (error) {\n        if (requestId !== maxAmountRequestIdRef.current) return;\n        console.error(\"Unable to calculate max for selected sources:\", error);\n        setSelectedSourcesMaxAmount(\"0\");\n      }\n    },\n    MAX_AMOUNT_DEBOUNCE_MS,\n  );\n\n  useEffect(() => {\n    debouncedRefreshMaxForSelection.cancel();\n    if (!nexusSDK || !inputs?.token || !inputs?.chain) {\n      maxAmountRequestIdRef.current += 1;\n      setSelectedSourcesMaxAmount(null);\n      return;\n    }\n    if (allAvailableSourceChainIds.length === 0) {\n      maxAmountRequestIdRef.current += 1;\n      setSelectedSourcesMaxAmount(\"0\");\n      return;\n    }\n    const requestId = ++maxAmountRequestIdRef.current;\n    debouncedRefreshMaxForSelection(requestId);\n  }, [\n    allAvailableSourceChainIds.length,\n    configuredMaxAmount,\n    debouncedRefreshMaxForSelection,\n    inputs?.recipient,\n    sourceSelectionKey,\n    inputs?.chain,\n    inputs?.token,\n    nexusSDK,\n  ]);\n\n  useEffect(() => {\n    if (type !== \"bridge\" || !connectedAddress) return;\n    const previousConnectedAddress = previousConnectedAddressRef.current;\n    if (!previousConnectedAddress) {\n      previousConnectedAddressRef.current = connectedAddress;\n      return;\n    }\n    if (connectedAddress === previousConnectedAddress) return;\n    previousConnectedAddressRef.current = connectedAddress;\n    if (prefill?.recipient) return;\n    if (!inputs?.recipient || inputs.recipient === previousConnectedAddress) {\n      dispatch({ type: \"setInputs\", payload: { recipient: connectedAddress } });\n    }\n  }, [type, connectedAddress, inputs?.recipient, prefill?.recipient]);\n\n  useEffect(() => {\n    invalidatePendingExecution();\n  }, [inputs, invalidatePendingExecution]);\n\n  useEffect(() => {\n    setSelectedSourceChains(null);\n  }, [inputs?.token]);\n\n  useEffect(() => {\n    if (!isDialogOpen) {\n      stopwatch.stop();\n      stopwatch.reset();\n    }\n  }, [isDialogOpen, stopwatch]);\n\n  useEffect(() => {\n    if (txError) {\n      setTxError(null);\n    }\n  }, [inputs, txError]);\n\n  return {\n    inputs,\n    setInputs,\n    timer: stopwatch.seconds,\n    setIsDialogOpen,\n    setTxError,\n    loading,\n    refreshing,\n    isDialogOpen,\n    txError,\n    handleTransaction,\n    reset,\n    filteredBridgableBalance,\n    startTransaction,\n    commitAmount,\n    lastExplorerUrl,\n    steps,\n    status: state.status,\n    availableSources,\n    selectedSourceChains: effectiveSelectedSourceChains,\n    toggleSourceChain,\n    isSourceSelectionInsufficient: sourceSelection.isBelowRequired,\n    isSourceSelectionBelowSafetyBuffer: sourceSelection.isBelowSafetyBuffer,\n    isSourceSelectionReadyForAccept:\n      sourceSelection.coverageState === \"healthy\",\n    sourceCoverageState: sourceSelection.coverageState,\n    sourceCoveragePercent: sourceSelection.coverageToSafetyPercent,\n    missingToProceed: sourceSelection.missingToProceed,\n    missingToSafety: sourceSelection.missingToSafety,\n    selectedTotal: sourceSelection.selectedTotal,\n    requiredTotal: sourceSelection.requiredTotal,\n    requiredSafetyTotal: sourceSelection.requiredSafetyTotal,\n    maxAvailableAmount: selectedSourcesMaxAmount ?? undefined,\n    isInputsValid: areInputsValid,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/hooks/useTransactionFlow.ts"
    },
    {
      "path": "registry/nexus-elements/common/index.ts",
      "content": "export * from \"./hooks/useStopwatch\";\nexport * from \"./hooks/usePolling\";\nexport * from \"./hooks/useInterval\";\nexport * from \"./hooks/useStableCallback\";\nexport * from \"./hooks/useLatest\";\nexport * from \"./hooks/useDebouncedValue\";\nexport * from \"./hooks/useDebouncedCallback\";\nexport * from \"./hooks/useNexusError\";\nexport * from \"./hooks/useTransactionFlow\";\nexport * from \"./types/transaction-flow\";\nexport * from \"./tx/types\";\nexport * from \"./tx/steps\";\nexport * from \"./tx/useTransactionSteps\";\nexport * from \"./utils/constant\";\nexport * from \"./components/ErrorBoundary\";\n",
      "type": "registry:component",
      "target": "components/common/index.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/steps.ts",
      "content": "import type { SwapStepType } from \"@avail-project/nexus-core\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\n\n/**\n * Predefined expected steps for swaps to seed UI before events arrive.\n * Kept here to avoid duplication across exact-in and exact-out hooks.\n */\nexport const SWAP_EXPECTED_STEPS: SwapStepType[] = [\n  { type: \"SWAP_START\", typeID: \"SWAP_START\" } as SwapStepType,\n  { type: \"DETERMINING_SWAP\", typeID: \"DETERMINING_SWAP\" } as SwapStepType,\n  {\n    type: \"CREATE_PERMIT_FOR_SOURCE_SWAP\",\n    typeID:\n      \"CREATE_PERMIT_FOR_SOURCE_SWAP\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_BATCH_TX\",\n    typeID: \"SOURCE_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"SOURCE_SWAP_HASH\",\n    typeID: \"SOURCE_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"RFF_ID\", typeID: \"RFF_ID\" } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_BATCH_TX\",\n    typeID: \"DESTINATION_SWAP_BATCH_TX\",\n  } as SwapStepType,\n  {\n    type: \"DESTINATION_SWAP_HASH\",\n    typeID: \"DESTINATION_SWAP_HASH\" as unknown as SwapStepType[\"typeID\"],\n  } as SwapStepType,\n  { type: \"SWAP_COMPLETE\", typeID: \"SWAP_COMPLETE\" } as SwapStepType,\n];\n\nexport function seedSteps<T>(expected: T[]): Array<GenericStep<T>> {\n  return expected.map((st, index) => ({\n    id: index,\n    completed: false,\n    step: st,\n  }));\n}\n\nexport function computeAllCompleted<T>(steps: Array<GenericStep<T>>): boolean {\n  return steps.length > 0 && steps.every((s) => s.completed);\n}\n\n/**\n * Replace the current list of steps with a new list, preserving completion\n * for any steps that were already marked completed (matched by key).\n */\nexport function mergeStepsList<T>(\n  prev: Array<GenericStep<T>>,\n  list: T[]\n): Array<GenericStep<T>> {\n  const completedKeys = new Set<string>();\n  for (const prevStep of prev) {\n    if (prevStep.completed) {\n      completedKeys.add(getStepKey(prevStep.step));\n    }\n  }\n  const next: Array<GenericStep<T>> = [];\n  for (let index = 0; index < list.length; index++) {\n    const step = list[index];\n    const key = getStepKey(step);\n    next.push({\n      id: index,\n      completed: completedKeys.has(key),\n      step,\n    });\n  }\n  return next;\n}\n\n/**\n * Mark a step complete in-place; if the step doesn't yet exist, append it.\n */\nexport function mergeStepComplete<T>(\n  prev: Array<GenericStep<T>>,\n  step: T\n): Array<GenericStep<T>> {\n  const key = getStepKey(step);\n  const updated: Array<GenericStep<T>> = [];\n  let found = false;\n  for (const s of prev) {\n    if (getStepKey(s.step) === key) {\n      updated.push({ ...s, completed: true, step: { ...s.step, ...step } });\n      found = true;\n    } else {\n      updated.push(s);\n    }\n  }\n  if (!found) {\n    updated.push({\n      id: updated.length,\n      completed: true,\n      step,\n    });\n  }\n  return updated;\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/steps.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/types.ts",
      "content": "export type TransactionStatus =\n  | \"idle\"\n  | \"preview\"\n  | \"awaiting-approval\"\n  | \"executing\"\n  | \"success\"\n  | \"error\";\n\nexport type GenericStep<TStep> = {\n  id: number;\n  completed: boolean;\n  step: TStep;\n};\n\n/**\n * Normalizes a step to a stable key. Prefers typeID, then type, otherwise JSON.\n */\nexport function getStepKey(step: any): string {\n  if (!step) return \"\";\n  if (typeof step.typeID === \"string\" && step.typeID.length > 0) {\n    return step.typeID;\n  }\n  if (typeof step.type === \"string\" && step.type.length > 0) {\n    return step.type;\n  }\n  try {\n    return JSON.stringify(step);\n  } catch {\n    return String(step);\n  }\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/types.ts"
    },
    {
      "path": "registry/nexus-elements/common/tx/useTransactionSteps.ts",
      "content": "import { useMemo, useRef, useState } from \"react\";\nimport type { GenericStep } from \"./types\";\nimport { getStepKey } from \"./types\";\nimport {\n  computeAllCompleted,\n  mergeStepComplete,\n  mergeStepsList,\n  seedSteps,\n} from \"./steps\";\n\ninterface UseTransactionStepsOptions<T> {\n  expected?: T[];\n}\n\n/**\n * Manages transaction steps with utilities to seed from expected steps,\n * replace the list on \"steps list\" events, and mark individual steps complete.\n */\nexport function useTransactionSteps<\n  T extends { typeID?: string; type?: string }\n>(options: UseTransactionStepsOptions<T> = {}) {\n  const { expected } = options;\n  const [steps, setSteps] = useState<Array<GenericStep<T>>>(() =>\n    expected ? seedSteps(expected) : []\n  );\n  const lastSignatureRef = useRef<string>(\"\");\n\n  const onStepsList = (list: T[]) => {\n    const signature = list.map((step) => getStepKey(step)).join(\"|\");\n    if (lastSignatureRef.current === signature) {\n      setSteps((prev) => mergeStepsList(prev, list));\n      return;\n    }\n    lastSignatureRef.current = signature;\n    setSteps((prev) => mergeStepsList(prev, list));\n  };\n\n  const onStepComplete = (step: T) => {\n    setSteps((prev) => mergeStepComplete(prev, step));\n  };\n\n  const seed = (expectedSteps: T[]) => {\n    setSteps(seedSteps(expectedSteps));\n  };\n\n  const reset = () => {\n    setSteps(expected ? seedSteps(expected) : []);\n    lastSignatureRef.current = \"\";\n  };\n\n  const allCompleted = useMemo(() => computeAllCompleted(steps), [steps]);\n\n  return {\n    steps,\n    allCompleted,\n    onStepsList,\n    onStepComplete,\n    seed,\n    reset,\n  };\n}\n",
      "type": "registry:component",
      "target": "components/common/tx/useTransactionSteps.ts"
    },
    {
      "path": "registry/nexus-elements/common/types/transaction-flow.ts",
      "content": "import {\n  type NexusSDK,\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\n\nexport type TransactionFlowType = \"bridge\" | \"transfer\";\n\nexport interface TransactionFlowInputs {\n  chain: SUPPORTED_CHAINS_IDS;\n  token: SUPPORTED_TOKENS;\n  amount?: string;\n  recipient?: `0x${string}`;\n}\n\nexport interface TransactionFlowPrefill {\n  token: string;\n  chainId: number;\n  amount?: string;\n  recipient?: Address;\n}\n\ntype BridgeOptions = NonNullable<Parameters<NexusSDK[\"bridge\"]>[1]>;\n\nexport type TransactionFlowEvent =\n  NonNullable<BridgeOptions[\"onEvent\"]> extends (event: infer E) => void\n    ? E\n    : never;\n\nexport type TransactionFlowOnEvent = NonNullable<BridgeOptions[\"onEvent\"]>;\n\nexport interface TransactionFlowExecuteParams {\n  token: SUPPORTED_TOKENS;\n  amount: bigint;\n  toChainId: SUPPORTED_CHAINS_IDS;\n  recipient: `0x${string}`;\n  sourceChains?: number[];\n  onEvent: TransactionFlowOnEvent;\n}\n\nexport type TransactionFlowExecutor = (\n  params: TransactionFlowExecuteParams,\n) => Promise<{ explorerUrl: string } | null>;\n\nexport type SourceCoverageState = \"healthy\" | \"warning\" | \"error\";\n\nexport interface SourceSelectionValidation {\n  coverageState: SourceCoverageState;\n  isBelowRequired: boolean;\n  missingToProceed: string;\n  missingToSafety: string;\n}\n",
      "type": "registry:component",
      "target": "components/common/types/transaction-flow.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/constant.ts",
      "content": "import { SUPPORTED_CHAINS } from \"@avail-project/nexus-core\";\nimport { formatUnits, parseUnits } from \"viem\";\n\nexport const SHORT_CHAIN_NAME: Record<number, string> = {\n  [SUPPORTED_CHAINS.ETHEREUM]: \"Ethereum\",\n  [SUPPORTED_CHAINS.BASE]: \"Base\",\n  [SUPPORTED_CHAINS.ARBITRUM]: \"Arbitrum\",\n  [SUPPORTED_CHAINS.OPTIMISM]: \"Optimism\",\n  [SUPPORTED_CHAINS.POLYGON]: \"Polygon\",\n  [SUPPORTED_CHAINS.AVALANCHE]: \"Avalanche\",\n  [SUPPORTED_CHAINS.SCROLL]: \"Scroll\",\n  [SUPPORTED_CHAINS.MEGAETH]: \"MegaETH\",\n  [SUPPORTED_CHAINS.KAIA]: \"Kaia\",\n  [SUPPORTED_CHAINS.BNB]: \"BNB\",\n  [SUPPORTED_CHAINS.MONAD]: \"Monad\",\n  [SUPPORTED_CHAINS.HYPEREVM]: \"HyperEVM\",\n  [SUPPORTED_CHAINS.CITREA]: \"Citrea\",\n  // [SUPPORTED_CHAINS.TRON]: \"Tron\",\n  [SUPPORTED_CHAINS.SEPOLIA]: \"Sepolia\",\n  [SUPPORTED_CHAINS.BASE_SEPOLIA]: \"Base Sepolia\",\n  [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: \"Arbitrum Sepolia\",\n  [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: \"Optimism Sepolia\",\n  [SUPPORTED_CHAINS.POLYGON_AMOY]: \"Polygon Amoy\",\n  [SUPPORTED_CHAINS.MONAD_TESTNET]: \"Monad Testnet\",\n  // [SUPPORTED_CHAINS.TRON_SHASTA]: \"Tron Shasta\",\n} as const;\n\nconst DEFAULT_SAFETY_MARGIN = 0.01; // 1%\n\n/**\n * Compute an amount string for fraction buttons (25%, 50%, 75%, 100%).\n *\n * @param balanceStr - user's balance as a human decimal string (e.g. \"12.345\") OR as base-unit integer string if `balanceIsBaseUnits` true\n * @param fraction - fraction e.g. 0.25, 0.5, 0.75, 1\n * @param decimals - token decimals (6 for USDC/USDT, 18 for ETH)\n * @param safetyMargin - 0.01 for 1% default\n * @param balanceIsBaseUnits - if true, balanceStr is already base units integer string (wei / smallest unit)\n * @returns decimal string clipped to token decimals (rounded down)\n */\nexport function computeAmountFromFraction(\n  balanceStr: string,\n  fraction: number,\n  decimals: number,\n  safetyMargin = DEFAULT_SAFETY_MARGIN,\n  balanceIsBaseUnits = false,\n): string {\n  if (!balanceStr) return \"0\";\n\n  // parse balance into base units (BigInt)\n  const balanceUnits: bigint = balanceIsBaseUnits\n    ? BigInt(balanceStr)\n    : parseUnits(balanceStr, decimals);\n\n  if (balanceUnits === BigInt(0)) return \"0\";\n\n  // Use an integer precision multiplier to avoid FP issues\n  const PREC = 1_000_000; // 1e6 precision for fraction & safety margin\n  const safetyMul = BigInt(Math.max(0, Math.floor((1 - safetyMargin) * PREC))); // (1 - safetyMargin) * PREC\n  const fractionMul = BigInt(Math.max(0, Math.floor(fraction * PREC))); // fraction * PREC\n\n  // Apply safety margin: floor(balance * (1 - safetyMargin))\n  const maxAfterSafety = (balanceUnits * safetyMul) / BigInt(PREC);\n\n  // Apply fraction and floor: floor(maxAfterSafety * fraction)\n  let desiredUnits = (maxAfterSafety * fractionMul) / BigInt(PREC);\n\n  // Extra clamp just in case\n  if (desiredUnits > balanceUnits) desiredUnits = balanceUnits;\n  if (desiredUnits < BigInt(0)) desiredUnits = BigInt(0);\n\n  // format back to human readable decimal string with token decimals (formatUnits truncates/keeps decimals)\n  // formatUnits will produce exactly decimals digits if fractional part exists; we'll strip trailing zeros.\n  const raw = formatUnits(desiredUnits, decimals);\n  // strip trailing zeros and possible trailing dot\n  return raw\n    .replace(/(\\.\\d*?[1-9])0+$/u, \"$1\")\n    .replace(/\\.0+$/u, \"\")\n    .replace(/^\\.$/u, \"0\");\n}\n\nexport const usdFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n",
      "type": "registry:component",
      "target": "components/common/utils/constant.ts"
    },
    {
      "path": "registry/nexus-elements/common/utils/transaction-flow.ts",
      "content": "import {\n  type NexusNetwork,\n  NexusSDK,\n  SUPPORTED_CHAINS,\n  type SUPPORTED_CHAINS_IDS,\n  type SUPPORTED_TOKENS,\n} from \"@avail-project/nexus-core\";\nimport { type Address } from \"viem\";\n\nconst MAX_AMOUNT_REGEX = /^\\d*\\.?\\d+$/;\n\nexport const MAX_AMOUNT_DEBOUNCE_MS = 300;\n\nexport const normalizeMaxAmount = (\n  maxAmount?: string | number,\n): string | undefined => {\n  if (maxAmount === undefined || maxAmount === null) return undefined;\n  const value = String(maxAmount).trim();\n  if (!value || value === \".\" || !MAX_AMOUNT_REGEX.test(value)) {\n    return undefined;\n  }\n  const parsed = Number.parseFloat(value);\n  if (!Number.isFinite(parsed) || parsed <= 0) return undefined;\n  return value;\n};\n\nexport const clampAmountToMax = ({\n  amount,\n  maxAmount,\n  nexusSDK,\n  token,\n  chainId,\n}: {\n  amount: string;\n  maxAmount?: string;\n  nexusSDK: NexusSDK;\n  token: SUPPORTED_TOKENS;\n  chainId: SUPPORTED_CHAINS_IDS;\n}): string => {\n  if (!maxAmount) return amount;\n  try {\n    const amountRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n      amount,\n      token,\n      chainId,\n    );\n    const maxRaw = nexusSDK.convertTokenReadableAmountToBigInt(\n      maxAmount,\n      token,\n      chainId,\n    );\n    return amountRaw > maxRaw ? maxAmount : amount;\n  } catch {\n    return amount;\n  }\n};\n\nexport const formatAmountForDisplay = (\n  amount: bigint,\n  decimals: number | undefined,\n  nexusSDK: NexusSDK,\n): string => {\n  if (typeof decimals !== \"number\") return amount.toString();\n  const formatted = nexusSDK.utils.formatUnits(amount, decimals);\n  if (!formatted.includes(\".\")) return formatted;\n  const [whole, fraction] = formatted.split(\".\");\n  const trimmedFraction = fraction.slice(0, 6).replace(/0+$/, \"\");\n  if (!trimmedFraction && whole === \"0\" && amount > BigInt(0)) {\n    return \"0.000001\";\n  }\n  return trimmedFraction ? `${whole}.${trimmedFraction}` : whole;\n};\n\nexport const buildInitialInputs = ({\n  type,\n  network,\n  connectedAddress,\n  prefill,\n}: {\n  type: \"bridge\" | \"transfer\";\n  network: NexusNetwork;\n  connectedAddress?: Address;\n  prefill?: {\n    token: string;\n    chainId: number;\n    amount?: string;\n    recipient?: Address;\n  };\n}) => {\n  return {\n    chain:\n      (prefill?.chainId as SUPPORTED_CHAINS_IDS) ??\n      (network === \"testnet\"\n        ? SUPPORTED_CHAINS.SEPOLIA\n        : SUPPORTED_CHAINS.ETHEREUM),\n    token: (prefill?.token as SUPPORTED_TOKENS) ?? \"USDC\",\n    amount: prefill?.amount ?? undefined,\n    recipient:\n      (prefill?.recipient as `0x${string}`) ??\n      (type === \"bridge\" ? connectedAddress : undefined),\n  };\n};\n\nexport const getCoverageDecimals = ({\n  type,\n  token,\n  chainId,\n  fallback,\n}: {\n  type: \"bridge\" | \"transfer\";\n  token?: SUPPORTED_TOKENS;\n  chainId?: SUPPORTED_CHAINS_IDS;\n  fallback: number | undefined;\n}) => {\n  if (token === \"USDM\") return 18;\n  if (type === \"bridge\" && token === \"USDC\" && chainId === SUPPORTED_CHAINS.BNB) {\n    return 18;\n  }\n  return fallback;\n};\n",
      "type": "registry:component",
      "target": "components/common/utils/transaction-flow.ts"
    }
  ]
}